
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">terraform-provider-arubacloud/internal/provider/backup_data_source.go (0.0%)</option>
				
				<option value="file1">terraform-provider-arubacloud/internal/provider/backup_resource.go (0.0%)</option>
				
				<option value="file2">terraform-provider-arubacloud/internal/provider/blockstorage_data_source.go (0.0%)</option>
				
				<option value="file3">terraform-provider-arubacloud/internal/provider/blockstorage_resource.go (0.0%)</option>
				
				<option value="file4">terraform-provider-arubacloud/internal/provider/cloudserver_data_source.go (0.0%)</option>
				
				<option value="file5">terraform-provider-arubacloud/internal/provider/cloudserver_resource.go (0.0%)</option>
				
				<option value="file6">terraform-provider-arubacloud/internal/provider/containerregistry_data_source.go (0.0%)</option>
				
				<option value="file7">terraform-provider-arubacloud/internal/provider/containerregistry_resource.go (0.0%)</option>
				
				<option value="file8">terraform-provider-arubacloud/internal/provider/database_data_source.go (0.0%)</option>
				
				<option value="file9">terraform-provider-arubacloud/internal/provider/database_resource.go (0.0%)</option>
				
				<option value="file10">terraform-provider-arubacloud/internal/provider/databasebackup_data_source.go (0.0%)</option>
				
				<option value="file11">terraform-provider-arubacloud/internal/provider/databasebackup_resource.go (0.0%)</option>
				
				<option value="file12">terraform-provider-arubacloud/internal/provider/databasegrant_data_source.go (0.0%)</option>
				
				<option value="file13">terraform-provider-arubacloud/internal/provider/databasegrant_resource.go (0.0%)</option>
				
				<option value="file14">terraform-provider-arubacloud/internal/provider/dbaas_data_source.go (0.0%)</option>
				
				<option value="file15">terraform-provider-arubacloud/internal/provider/dbaas_resource.go (0.0%)</option>
				
				<option value="file16">terraform-provider-arubacloud/internal/provider/dbaasuser_data_source.go (0.0%)</option>
				
				<option value="file17">terraform-provider-arubacloud/internal/provider/dbaasuser_resource.go (0.0%)</option>
				
				<option value="file18">terraform-provider-arubacloud/internal/provider/elasticip_data_source.go (0.0%)</option>
				
				<option value="file19">terraform-provider-arubacloud/internal/provider/elasticip_resource.go (0.0%)</option>
				
				<option value="file20">terraform-provider-arubacloud/internal/provider/kaas_data_source.go (0.0%)</option>
				
				<option value="file21">terraform-provider-arubacloud/internal/provider/kaas_resource.go (0.0%)</option>
				
				<option value="file22">terraform-provider-arubacloud/internal/provider/keypair_data_source.go (0.0%)</option>
				
				<option value="file23">terraform-provider-arubacloud/internal/provider/keypair_resource.go (0.0%)</option>
				
				<option value="file24">terraform-provider-arubacloud/internal/provider/kms_data_source.go (0.0%)</option>
				
				<option value="file25">terraform-provider-arubacloud/internal/provider/kms_resource.go (0.0%)</option>
				
				<option value="file26">terraform-provider-arubacloud/internal/provider/project_data_source.go (0.0%)</option>
				
				<option value="file27">terraform-provider-arubacloud/internal/provider/project_resource.go (0.0%)</option>
				
				<option value="file28">terraform-provider-arubacloud/internal/provider/provider.go (4.8%)</option>
				
				<option value="file29">terraform-provider-arubacloud/internal/provider/resource_wait.go (0.0%)</option>
				
				<option value="file30">terraform-provider-arubacloud/internal/provider/restore_data_source.go (0.0%)</option>
				
				<option value="file31">terraform-provider-arubacloud/internal/provider/restore_resource.go (0.0%)</option>
				
				<option value="file32">terraform-provider-arubacloud/internal/provider/schedulejob_data_source.go (0.0%)</option>
				
				<option value="file33">terraform-provider-arubacloud/internal/provider/schedulejob_resource.go (0.0%)</option>
				
				<option value="file34">terraform-provider-arubacloud/internal/provider/securitygroup_data_source.go (0.0%)</option>
				
				<option value="file35">terraform-provider-arubacloud/internal/provider/securitygroup_resource.go (0.0%)</option>
				
				<option value="file36">terraform-provider-arubacloud/internal/provider/securityrule_data_source.go (0.0%)</option>
				
				<option value="file37">terraform-provider-arubacloud/internal/provider/securityrule_resource.go (0.0%)</option>
				
				<option value="file38">terraform-provider-arubacloud/internal/provider/snapshot_data_source.go (0.0%)</option>
				
				<option value="file39">terraform-provider-arubacloud/internal/provider/snapshot_resource.go (0.0%)</option>
				
				<option value="file40">terraform-provider-arubacloud/internal/provider/subnet_data_source.go (0.0%)</option>
				
				<option value="file41">terraform-provider-arubacloud/internal/provider/subnet_resource.go (0.0%)</option>
				
				<option value="file42">terraform-provider-arubacloud/internal/provider/vpc_data_source.go (0.0%)</option>
				
				<option value="file43">terraform-provider-arubacloud/internal/provider/vpc_resource.go (0.0%)</option>
				
				<option value="file44">terraform-provider-arubacloud/internal/provider/vpcpeering_data_source.go (0.0%)</option>
				
				<option value="file45">terraform-provider-arubacloud/internal/provider/vpcpeering_resource.go (0.0%)</option>
				
				<option value="file46">terraform-provider-arubacloud/internal/provider/vpcpeeringroute_data_source.go (0.0%)</option>
				
				<option value="file47">terraform-provider-arubacloud/internal/provider/vpcpeeringroute_resource.go (0.0%)</option>
				
				<option value="file48">terraform-provider-arubacloud/internal/provider/vpnroute_data_source.go (0.0%)</option>
				
				<option value="file49">terraform-provider-arubacloud/internal/provider/vpnroute_resource.go (0.0%)</option>
				
				<option value="file50">terraform-provider-arubacloud/internal/provider/vpntunnel_data_source.go (0.0%)</option>
				
				<option value="file51">terraform-provider-arubacloud/internal/provider/vpntunnel_resource.go (0.0%)</option>
				
				<option value="file52">terraform-provider-arubacloud/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;BackupDataSource{}

func NewBackupDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;BackupDataSource{}
}</span>

type BackupDataSource struct {
        client *ArubaCloudClient
}

type BackupDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        Type          types.String `tfsdk:"type"`
        VolumeID      types.String `tfsdk:"volume_id"`
        RetentionDays types.Int64  `tfsdk:"retention_days"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

func (d *BackupDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_backup"
}</span>

func (d *BackupDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Backup data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Backup identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Backup name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Backup location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the backup resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this backup belongs to",
                                Computed:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Type of backup (Full, Incremental)",
                                Computed:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "Volume ID for the backup",
                                Computed:            true,
                        },
                        "retention_days": schema.Int64Attribute{
                                MarkdownDescription: "Retention days for the backup",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *BackupDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *BackupDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data BackupDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-backup")
        tflog.Trace(ctx, "read a Backup data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type BackupResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        Type          types.String `tfsdk:"type"`
        VolumeID      types.String `tfsdk:"volume_id"`
        RetentionDays types.Int64  `tfsdk:"retention_days"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

type BackupResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;BackupResource{}
var _ resource.ResourceWithImportState = &amp;BackupResource{}

func NewBackupResource() resource.Resource <span class="cov0" title="0">{
        return &amp;BackupResource{}
}</span>

func (r *BackupResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_backup"
}</span>

func (r *BackupResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Backup resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Backup identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Backup URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Backup name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Backup location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the backup resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this backup belongs to",
                                Required:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Type of backup (Full, Incremental)",
                                Required:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "Volume ID for the backup",
                                Required:            true,
                        },
                        "retention_days": schema.Int64Attribute{
                                MarkdownDescription: "Retention days for the backup",
                                Optional:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *BackupResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *BackupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data BackupResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        volumeID := data.VolumeID.ValueString()

        if projectID == "" || volumeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Volume ID are required to create a backup",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Get the volume details to get the full URI
        <span class="cov0" title="0">volumeResponse, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting volume details",
                        fmt.Sprintf("Unable to get volume details: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if volumeResponse == nil || volumeResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Volume Not Found",
                        "Volume not found",
                )
                return
        }</span>

        <span class="cov0" title="0">volumeURI := ""
        if volumeResponse.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                volumeURI = *volumeResponse.Data.Metadata.URI
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid Volume Response",
                        "Volume URI not found in response",
                )
                return
        }</span>

        // Build the backup create request
        <span class="cov0" title="0">createRequest := sdktypes.StorageBackupRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.StorageBackupPropertiesRequest{
                        StorageBackupType: sdktypes.StorageBackupType(data.Type.ValueString()),
                        Origin: sdktypes.ReferenceResource{
                                URI: volumeURI,
                        },
                },
        }

        // Add optional fields
        if !data.RetentionDays.IsNull() &amp;&amp; !data.RetentionDays.IsUnknown() </span><span class="cov0" title="0">{
                retentionDays := int(data.RetentionDays.ValueInt64())
                createRequest.Properties.RetentionDays = &amp;retentionDays
        }</span>

        <span class="cov0" title="0">if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                billingPeriod := data.BillingPeriod.ValueString()
                createRequest.Properties.BillingPeriod = &amp;billingPeriod
        }</span>

        // Create the backup using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Backups().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating backup",
                        fmt.Sprintf("Unable to create backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create backup"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Backup created but no data returned from API",
                )
                return
        }</span>

        // Wait for Backup to be active before returning
        // This ensures Terraform doesn't proceed until Backup is ready
        <span class="cov0" title="0">backupID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Backup to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Backup", backupID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Backup Not Active",
                        fmt.Sprintf("Backup was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Backup resource", map[string]interface{}{
                "backup_id":   data.Id.ValueString(),
                "backup_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BackupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data BackupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to read the backup",
                )
                return
        }</span>

        // Get backup details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading backup",
                        fmt.Sprintf("Unable to read backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read backup"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                backup := response.Data

                if backup.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*backup.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*backup.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if backup.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*backup.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(backup.Metadata.LocationResponse.Value)
                }</span>
                // Note: StorageBackupType field may not be available in the response
                // If type is needed, it should be stored from the create request
                <span class="cov0" title="0">if backup.Properties.Origin.URI != "" </span><span class="cov0" title="0">{
                        // Extract Volume ID from URI
                        parts := strings.Split(backup.Properties.Origin.URI, "/")
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                data.VolumeID = types.StringValue(parts[len(parts)-1])
                        }</span>
                }
                <span class="cov0" title="0">if backup.Properties.RetentionDays != nil </span><span class="cov0" title="0">{
                        data.RetentionDays = types.Int64Value(int64(*backup.Properties.RetentionDays))
                }</span>
                <span class="cov0" title="0">if backup.Properties.BillingPeriod != nil </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(*backup.Properties.BillingPeriod)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(backup.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(backup.Metadata.Tags))
                        for i, tag := range backup.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BackupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data BackupResourceModel
        var state BackupResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        backupID := state.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to update the backup",
                )
                return
        }</span>

        // Get current backup details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current backup",
                        fmt.Sprintf("Unable to get current backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Backup Not Found",
                        "Backup not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for backup",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated
        <span class="cov0" title="0">updateRequest := sdktypes.StorageBackupRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.StorageBackupPropertiesRequest{
                        // Properties cannot be updated - use current values
                        // Note: StorageBackupType may not be available in result type
                        // If needed, preserve from state or use default
                        Origin:        current.Properties.Origin,
                        RetentionDays: current.Properties.RetentionDays,
                        BillingPeriod: current.Properties.BillingPeriod,
                },
        }

        // Update the backup using the SDK
        response, err := r.client.Client.FromStorage().Backups().Update(ctx, projectID, backupID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating backup",
                        fmt.Sprintf("Unable to update backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update backup"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Uri = state.Uri                     // Preserve URI from state
        data.VolumeID = state.VolumeID           // Immutable
        data.Type = state.Type                   // Immutable
        data.RetentionDays = state.RetentionDays // Immutable
        data.BillingPeriod = state.BillingPeriod // Immutable

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the backup to get the latest state including URI
                getResp, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if not in response
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BackupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data BackupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to delete the backup",
                )
                return
        }</span>

        // Delete the backup using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromStorage().Backups().Delete(ctx, projectID, backupID, nil)
                }</span>,
                ExtractSDKError,
                "Backup",
                backupID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting backup",
                        fmt.Sprintf("Unable to delete backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Backup resource", map[string]interface{}{
                "backup_id": backupID,
        })</span>
}

func (r *BackupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;BlockStorageDataSource{}

func NewBlockStorageDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;BlockStorageDataSource{}
}</span>

type BlockStorageDataSource struct {
        client *ArubaCloudClient
}

type BlockStorageDataSourceModel struct {
        Id         types.String                `tfsdk:"id"`
        Name       types.String                `tfsdk:"name"`
        ProjectId  types.String                `tfsdk:"project_id"`
        Properties BlockStoragePropertiesModel `tfsdk:"properties"`
}

type BlockStoragePropertiesModel struct {
        SizeGB        types.Int64  `tfsdk:"size_gb"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Zone          types.String `tfsdk:"zone"`
        Type          types.String `tfsdk:"type"`
        SnapshotId    types.String `tfsdk:"snapshot_id"`
        Bootable      types.Bool   `tfsdk:"bootable"`
        Image         types.String `tfsdk:"image"`
}

func (d *BlockStorageDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_blockstorage"
}</span>

func (d *BlockStorageDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Block Storage data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Block Storage identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Block Storage name",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Block Storage belongs to",
                                Computed:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                MarkdownDescription: "Properties of the Block Storage",
                                Computed:            true,
                                Attributes: map[string]schema.Attribute{
                                        "size_gb": schema.Int64Attribute{
                                                MarkdownDescription: "Size of the block storage in GB",
                                                Computed:            true,
                                        },
                                        "billing_period": schema.StringAttribute{
                                                MarkdownDescription: "Billing period of the block storage (only 'Hour' allowed)",
                                                Computed:            true,
                                        },
                                        "zone": schema.StringAttribute{
                                                MarkdownDescription: "Zone of the block storage",
                                                Computed:            true,
                                        },
                                        "type": schema.StringAttribute{
                                                MarkdownDescription: "Type of block storage (Standard, Performance)",
                                                Computed:            true,
                                        },
                                        "snapshot_id": schema.StringAttribute{
                                                MarkdownDescription: "Snapshot ID for the block storage",
                                                Computed:            true,
                                        },
                                        "bootable": schema.BoolAttribute{
                                                MarkdownDescription: "Whether the block storage is bootable",
                                                Computed:            true,
                                        },
                                        "image": schema.StringAttribute{
                                                MarkdownDescription: "Image for the block storage",
                                                Computed:            true,
                                        },
                                },
                        },
                },
        }
}</span>

func (d *BlockStorageDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *BlockStorageDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data BlockStorageDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-blockstorage")
        tflog.Trace(ctx, "read a Block Storage data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;BlockStorageResource{}
var _ resource.ResourceWithImportState = &amp;BlockStorageResource{}

func NewBlockStorageResource() resource.Resource <span class="cov0" title="0">{
        return &amp;BlockStorageResource{}
}</span>

type BlockStorageResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        ProjectID     types.String `tfsdk:"project_id"`
        Location      types.String `tfsdk:"location"`
        SizeGB        types.Int64  `tfsdk:"size_gb"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Zone          types.String `tfsdk:"zone"`
        Type          types.String `tfsdk:"type"`
        Bootable      types.Bool   `tfsdk:"bootable"`
        Image         types.String `tfsdk:"image"`
        Tags          types.List   `tfsdk:"tags"`
}

type BlockStorageResource struct {
        client *ArubaCloudClient
}

func (r *BlockStorageResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_blockstorage"
}</span>

func (r *BlockStorageResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Block Storage resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Block Storage identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Block Storage URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Block Storage name",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Block Storage belongs to",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Block Storage location/region",
                                Required:            true,
                        },
                        "size_gb": schema.Int64Attribute{
                                MarkdownDescription: "Size of the block storage in GB",
                                Required:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Required:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone where blockstorage will be created. If not specified, the block storage will be regional (available across all zones in the location). If specified, the block storage will be zonal (tied to a specific zone).",
                                Optional:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Type of block storage (Standard, Performance)",
                                Required:            true,
                        },
                        "bootable": schema.BoolAttribute{
                                MarkdownDescription: "Whether the block storage is bootable. Must be set to true along with image to create a bootable disk.",
                                Optional:            true,
                        },
                        "image": schema.StringAttribute{
                                MarkdownDescription: "Image ID for bootable block storage. Required when bootable is true. See [available images](https://api.arubacloud.com/docs/metadata/#cloud-server-bootvolume) for a list of supported image IDs.",
                                Optional:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the block storage",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *BlockStorageResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *BlockStorageResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data BlockStorageResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create block storage",
                )
                return
        }</span>

        // Validate bootable and image
        <span class="cov0" title="0">if !data.Bootable.IsNull() &amp;&amp; !data.Bootable.IsUnknown() &amp;&amp; data.Bootable.ValueBool() </span><span class="cov0" title="0">{
                if data.Image.IsNull() || data.Image.IsUnknown() || data.Image.ValueString() == "" </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Missing Image",
                                "Image is required when bootable is set to true",
                        )
                        return
                }</span>
        }

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.BlockStorageRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.BlockStoragePropertiesRequest{
                        SizeGB:        int(data.SizeGB.ValueInt64()),
                        BillingPeriod: data.BillingPeriod.ValueString(),
                        Type:          sdktypes.BlockStorageType(data.Type.ValueString()),
                },
        }

        // Add zone if provided
        if !data.Zone.IsNull() &amp;&amp; !data.Zone.IsUnknown() </span><span class="cov0" title="0">{
                zone := data.Zone.ValueString()
                createRequest.Properties.Zone = &amp;zone
        }</span>

        // Add bootable and image if provided
        <span class="cov0" title="0">if !data.Bootable.IsNull() &amp;&amp; !data.Bootable.IsUnknown() </span><span class="cov0" title="0">{
                bootable := data.Bootable.ValueBool()
                createRequest.Properties.Bootable = &amp;bootable
        }</span>
        <span class="cov0" title="0">if !data.Image.IsNull() &amp;&amp; !data.Image.IsUnknown() </span><span class="cov0" title="0">{
                image := data.Image.ValueString()
                createRequest.Properties.Image = &amp;image
        }</span>

        // Create the block storage using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Volumes().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating block storage",
                        fmt.Sprintf("Unable to create block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create block storage"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(response.Data.Properties.Zone)
                }</span> else<span class="cov0" title="0"> {
                        data.Zone = types.StringNull()
                }</span>
                // Populate bootable and image from API response
                // Only set if API provides a value, otherwise preserve null from plan
                <span class="cov0" title="0">if response.Data.Properties.Bootable != nil </span><span class="cov0" title="0">{
                        data.Bootable = types.BoolValue(*response.Data.Properties.Bootable)
                }</span> else<span class="cov0" title="0"> {
                        // Keep as null if API doesn't provide a value (preserves plan state)
                        data.Bootable = types.BoolNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Properties.Image != nil </span><span class="cov0" title="0">{
                        data.Image = types.StringValue(*response.Data.Properties.Image)
                }</span> else<span class="cov0" title="0"> {
                        data.Image = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Block storage created but no data returned from API",
                )
                return
        }</span>

        // Wait for Block Storage to be active before returning (Volume is referenced by Snapshot, CloudServer)
        // This ensures Terraform doesn't proceed to create dependent resources until BlockStorage is ready
        <span class="cov0" title="0">volumeID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Block Storage to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "BlockStorage", volumeID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Block Storage Not Active",
                        fmt.Sprintf("Block storage was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Read the Block Storage again to ensure URI and other fields are properly set from metadata
        <span class="cov0" title="0">getResp, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(getResp.Data.Properties.Zone)
                }</span> else<span class="cov0" title="0"> {
                        data.Zone = types.StringNull()
                }</span>
                // Update bootable and image from re-read
                <span class="cov0" title="0">if getResp.Data.Properties.Bootable != nil </span><span class="cov0" title="0">{
                        data.Bootable = types.BoolValue(*getResp.Data.Properties.Bootable)
                }</span> else<span class="cov0" title="0"> {
                        data.Bootable = types.BoolNull()
                }</span>
                <span class="cov0" title="0">if getResp.Data.Properties.Image != nil </span><span class="cov0" title="0">{
                        data.Image = types.StringValue(*getResp.Data.Properties.Image)
                }</span> else<span class="cov0" title="0"> {
                        data.Image = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Block Storage after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Block Storage resource", map[string]interface{}{
                "blockstorage_id":   data.Id.ValueString(),
                "blockstorage_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BlockStorageResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data BlockStorageResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        volumeID := data.Id.ValueString()

        // If ID is unknown or null, check if this is a new resource (no state) or existing resource (state exists but ID missing)
        // For new resources (during plan), we can return early
        // For existing resources, we need the ID to read - if it's missing, that's an error
        if data.Id.IsUnknown() || data.Id.IsNull() || volumeID == "" </span><span class="cov0" title="0">{
                // Check if we have any other state data that indicates this is an existing resource
                // If name is set in state, this is likely an existing resource with missing ID (error case)
                if !data.Name.IsUnknown() &amp;&amp; !data.Name.IsNull() &amp;&amp; data.Name.ValueString() != "" </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Block Storage exists in state but ID is missing - this indicates a state corruption issue")
                        resp.Diagnostics.AddError(
                                "Missing Block Storage ID",
                                "Block Storage ID is required to read the block storage. The resource exists in state but the ID is missing. This may indicate a state corruption issue. Try running 'terraform refresh' or 'terraform import arubacloud_blockstorage.test &lt;volume_id&gt;'.",
                        )
                        return
                }</span>
                // Otherwise, this is likely a new resource during plan - return early
                <span class="cov0" title="0">tflog.Info(ctx, "Block Storage ID is unknown or null during read, skipping API call (likely new resource).")
                return</span> // Do not error, as this is expected during plan for new resources
        }

        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                // Check if ProjectID is unknown (new resource) vs missing (error)
                if data.ProjectID.IsUnknown() || data.ProjectID.IsNull() </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Block Storage Project ID is unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to read the block storage",
                )
                return</span>
        }

        // Get block storage details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading block storage",
                        fmt.Sprintf("Unable to read block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read block storage"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                volume := response.Data

                if volume.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*volume.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if volume.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*volume.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If API doesn't return URI, try to preserve from state, or construct it from ID
                        if !data.Uri.IsNull() &amp;&amp; !data.Uri.IsUnknown() </span>{<span class="cov0" title="0">
                                // Preserve URI from state if available
                                // (data.Uri already has the state value, so no change needed)
                        }</span> else<span class="cov0" title="0"> if volume.Metadata.ID != nil </span><span class="cov0" title="0">{
                                // Construct URI from ID if we have it
                                uri := fmt.Sprintf("/projects/%s/providers/Aruba.Storage/volumes/%s", projectID, *volume.Metadata.ID)
                                data.Uri = types.StringValue(uri)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                }
                <span class="cov0" title="0">if volume.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*volume.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if volume.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(volume.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">data.SizeGB = types.Int64Value(int64(volume.Properties.SizeGB))
                data.Type = types.StringValue(string(volume.Properties.Type))
                // Zone: if empty, it's regional storage; if set, it's zonal storage
                if volume.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(volume.Properties.Zone)
                }</span> else<span class="cov0" title="0"> {
                        // Regional storage - zone is null/empty
                        data.Zone = types.StringNull()
                }</span>

                // Populate bootable and image from API response
                // Only set if API provides a value, otherwise preserve null from plan
                <span class="cov0" title="0">if volume.Properties.Bootable != nil </span><span class="cov0" title="0">{
                        data.Bootable = types.BoolValue(*volume.Properties.Bootable)
                }</span> else<span class="cov0" title="0"> {
                        // Keep as null if API doesn't provide a value (preserves plan state)
                        data.Bootable = types.BoolNull()
                }</span>
                <span class="cov0" title="0">if volume.Properties.Image != nil </span><span class="cov0" title="0">{
                        data.Image = types.StringValue(*volume.Properties.Image)
                }</span> else<span class="cov0" title="0"> {
                        data.Image = types.StringNull()
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(volume.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(volume.Metadata.Tags))
                        for i, tag := range volume.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BlockStorageResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data BlockStorageResourceModel
        var state BlockStorageResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        volumeID := state.Id.ValueString()

        if projectID == "" || volumeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Volume ID are required to update the block storage",
                )
                return
        }</span>

        // Get current block storage details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current block storage",
                        fmt.Sprintf("Unable to get current block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Block Storage Not Found",
                        "Block storage not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if the volume status allows updates
        if current.Status.State != nil </span><span class="cov0" title="0">{
                status := *current.Status.State
                if status != "Used" &amp;&amp; status != "NotUsed" </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Cannot Update",
                                fmt.Sprintf("Cannot update block storage with status '%s'. Block storage can only be updated when status is 'Used' or 'NotUsed'", status),
                        )
                        return
                }</span>
        }

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for block storage",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Handle zone
        <span class="cov0" title="0">var zone *string
        if current.Properties.Zone != "" </span><span class="cov0" title="0">{
                zone = &amp;current.Properties.Zone
        }</span>

        // Build the update request
        // Use size from plan (data) if provided, otherwise preserve current size
        <span class="cov0" title="0">sizeGB := current.Properties.SizeGB
        if !data.SizeGB.IsNull() &amp;&amp; !data.SizeGB.IsUnknown() </span><span class="cov0" title="0">{
                sizeGB = int(data.SizeGB.ValueInt64())
        }</span>

        // Use billing period from plan (data) if provided, otherwise preserve current
        <span class="cov0" title="0">billingPeriod := current.Properties.BillingPeriod
        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                billingPeriod = data.BillingPeriod.ValueString()
        }</span>

        <span class="cov0" title="0">updateRequest := sdktypes.BlockStorageRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.BlockStoragePropertiesRequest{
                        SizeGB:        sizeGB,
                        BillingPeriod: billingPeriod,
                        Zone:          zone,
                        Type:          current.Properties.Type,
                },
        }

        // Update the block storage using the SDK
        response, err := r.client.Client.FromStorage().Volumes().Update(ctx, projectID, volumeID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating block storage",
                        fmt.Sprintf("Unable to update block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update block storage"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Wait for Block Storage update to complete before returning
        // This ensures Terraform doesn't proceed until the update is fully applied
        <span class="cov0" title="0">checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Block Storage to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "BlockStorage", volumeID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Block Storage Update Not Complete",
                        fmt.Sprintf("Block storage update was initiated but did not complete within the timeout period: %s", err),
                )
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Uri = state.Uri   // Preserve URI from state
        data.Zone = state.Zone // Preserve zone from state (immutable)

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = state.Uri // Fallback to state if not in response
                }</span>
                // Update zone from response (empty = regional, set = zonal)
                <span class="cov0" title="0">if response.Data.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(response.Data.Properties.Zone)
                }</span> else<span class="cov0" title="0"> {
                        data.Zone = types.StringNull() // Regional storage
                }</span>
                // Update size from response
                <span class="cov0" title="0">data.SizeGB = types.Int64Value(int64(response.Data.Properties.SizeGB))
                // Update billing period from response if available
                if response.Data.Properties.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(response.Data.Properties.BillingPeriod)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the resource to get the latest state after update
                getResp, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        // Update from the re-read response
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri
                        }</span>
                        <span class="cov0" title="0">if getResp.Data.Properties.Zone != "" </span><span class="cov0" title="0">{
                                data.Zone = types.StringValue(getResp.Data.Properties.Zone)
                        }</span> else<span class="cov0" title="0"> {
                                data.Zone = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">data.SizeGB = types.Int64Value(int64(getResp.Data.Properties.SizeGB))
                        if getResp.Data.Properties.BillingPeriod != "" </span><span class="cov0" title="0">{
                                data.BillingPeriod = types.StringValue(getResp.Data.Properties.BillingPeriod)
                        }</span> else<span class="cov0" title="0"> {
                                data.BillingPeriod = state.BillingPeriod
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                        data.Zone = state.Zone
                        data.SizeGB = state.SizeGB
                        data.BillingPeriod = state.BillingPeriod
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BlockStorageResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data BlockStorageResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        volumeID := data.Id.ValueString()

        if projectID == "" || volumeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Volume ID are required to delete the block storage",
                )
                return
        }</span>

        // Delete the block storage using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromStorage().Volumes().Delete(ctx, projectID, volumeID, nil)
                }</span>,
                ExtractSDKError,
                "BlockStorage",
                volumeID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting block storage",
                        fmt.Sprintf("Unable to delete block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Block Storage resource", map[string]interface{}{
                "volume_id": volumeID,
        })</span>
}

func (r *BlockStorageResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type CloudServerDataSourceModel struct {
        Id             types.String `tfsdk:"id"`
        Name           types.String `tfsdk:"name"`
        Location       types.String `tfsdk:"location"`
        ProjectID      types.String `tfsdk:"project_id"`
        Zone           types.String `tfsdk:"zone"`
        VpcID          types.String `tfsdk:"vpc_id"`
        FlavorName     types.String `tfsdk:"flavor_name"`
        ElasticIPID    types.String `tfsdk:"elastic_ip_id"`
        BootVolume     types.String `tfsdk:"boot_volume"`
        KeyPairID      types.String `tfsdk:"key_pair_id"`
        Subnets        types.List   `tfsdk:"subnets"`
        SecurityGroups types.List   `tfsdk:"securitygroups"`
}

type CloudServerDataSource struct {
        client *ArubaCloudClient
}

var _ datasource.DataSource = &amp;CloudServerDataSource{}

func NewCloudServerDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;CloudServerDataSource{}
}</span>

func (d *CloudServerDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_cloudserver"
}</span>

func (d *CloudServerDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "CloudServer data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "CloudServer identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "CloudServer name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "CloudServer location",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "Project ID",
                                Computed:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone",
                                Computed:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "VPC ID",
                                Computed:            true,
                        },
                        "flavor_name": schema.StringAttribute{
                                MarkdownDescription: "Flavor name",
                                Computed:            true,
                        },
                        "elastic_ip_id": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP ID",
                                Computed:            true,
                        },
                        "boot_volume": schema.StringAttribute{
                                MarkdownDescription: "Boot volume ID",
                                Computed:            true,
                        },
                        "key_pair_id": schema.StringAttribute{
                                MarkdownDescription: "Key pair ID",
                                Computed:            true,
                        },
                        "subnets": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of subnet IDs",
                                Computed:            true,
                        },
                        "securitygroups": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of security group reference IDs",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *CloudServerDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected DataSource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *CloudServerDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data CloudServerDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response
        <span class="cov0" title="0">data.Id = types.StringValue("cloudserver-id")
        tflog.Trace(ctx, "read a CloudServer data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type CloudServerResourceModel struct {
        Id                   types.String `tfsdk:"id"`
        Uri                  types.String `tfsdk:"uri"`
        Name                 types.String `tfsdk:"name"`
        Location             types.String `tfsdk:"location"`
        ProjectID            types.String `tfsdk:"project_id"`
        Zone                 types.String `tfsdk:"zone"`
        VpcUriRef            types.String `tfsdk:"vpc_uri_ref"`
        FlavorName           types.String `tfsdk:"flavor_name"`
        ElasticIpUriRef      types.String `tfsdk:"elastic_ip_uri_ref"`
        BootVolumeUriRef     types.String `tfsdk:"boot_volume_uri_ref"`
        KeyPairUriRef        types.String `tfsdk:"key_pair_uri_ref"`
        SubnetUriRefs        types.List   `tfsdk:"subnet_uri_refs"`
        SecurityGroupUriRefs types.List   `tfsdk:"securitygroup_uri_refs"`
        Tags                 types.List   `tfsdk:"tags"`
}

type CloudServerResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;CloudServerResource{}
var _ resource.ResourceWithImportState = &amp;CloudServerResource{}

func NewCloudServerResource() resource.Resource <span class="cov0" title="0">{
        return &amp;CloudServerResource{}
}</span>

func (r *CloudServerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_cloudserver"
}</span>

func (r *CloudServerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "CloudServer resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "CloudServer identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "CloudServer URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "CloudServer name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "CloudServer location",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "Project ID",
                                Required:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone",
                                Required:            true,
                        },
                        "vpc_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "URI reference to the VPC. Should be the VPC URI (e.g., `/projects/{project_id}/providers/Aruba.Network/vpcs/{vpc_id}`). You can reference the `uri` attribute from an `arubacloud_vpc` resource.",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "flavor_name": schema.StringAttribute{
                                MarkdownDescription: "Flavor name. Available flavors are described in the [ArubaCloud API documentation](https://api.arubacloud.com/docs/metadata/#cloudserver-flavors). For example, `CSO4A8` means 4 CPU and 8GB RAM.",
                                Required:            true,
                        },
                        "elastic_ip_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "URI reference to the Elastic IP. Should be the Elastic IP URI. You can reference the `uri` attribute from an `arubacloud_elasticip` resource.",
                                Optional:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "boot_volume_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "URI reference to the boot volume (block storage). Should be the block storage URI. You can reference the `uri` attribute from an `arubacloud_blockstorage` resource.",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "key_pair_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "URI reference to the Key Pair. Should be the Key Pair URI. You can reference the `uri` attribute from an `arubacloud_keypair` resource.",
                                Optional:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "subnet_uri_refs": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of subnet URI references. Should be subnet URIs. You can reference the `uri` attribute from `arubacloud_subnet` resources like `[arubacloud_subnet.example.uri]`",
                                Required:            true,
                        },
                        "securitygroup_uri_refs": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of security group URI references. Should be security group URIs. You can reference the `uri` attribute from `arubacloud_securitygroup` resources like `[arubacloud_securitygroup.example.uri]`",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Cloud Server",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *CloudServerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *CloudServerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data CloudServerResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a cloud server",
                )
                return
        }</span>

        // Extract subnets from Terraform list (these are URIs)
        <span class="cov0" title="0">var subnetRefs []sdktypes.ReferenceResource
        if !data.SubnetUriRefs.IsNull() &amp;&amp; !data.SubnetUriRefs.IsUnknown() </span><span class="cov0" title="0">{
                var subnetURIs []string
                diags := data.SubnetUriRefs.ElementsAs(ctx, &amp;subnetURIs, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                // Subnet URIs should already be full URIs from resource references
                <span class="cov0" title="0">for _, subnetURI := range subnetURIs </span><span class="cov0" title="0">{
                        subnetRefs = append(subnetRefs, sdktypes.ReferenceResource{
                                URI: subnetURI,
                        })
                }</span>
        }

        // Extract security groups from Terraform list (these are URIs)
        <span class="cov0" title="0">var securityGroupRefs []sdktypes.ReferenceResource
        if !data.SecurityGroupUriRefs.IsNull() &amp;&amp; !data.SecurityGroupUriRefs.IsUnknown() </span><span class="cov0" title="0">{
                var sgURIs []string
                diags := data.SecurityGroupUriRefs.ElementsAs(ctx, &amp;sgURIs, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                // Security group URIs should already be full URIs from resource references
                <span class="cov0" title="0">for _, sgURI := range sgURIs </span><span class="cov0" title="0">{
                        securityGroupRefs = append(securityGroupRefs, sdktypes.ReferenceResource{
                                URI: sgURI,
                        })
                }</span>
        }

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Boot volume URI should already be a full URI from resource reference
        <span class="cov0" title="0">bootVolumeURI := data.BootVolumeUriRef.ValueString()

        // VPC URI should already be a full URI from resource reference
        vpcURI := data.VpcUriRef.ValueString()

        // Note: Elastic IP might be handled differently in the API
        // For now, we'll include VPC, subnets, security groups, and zone which are required

        // Build the create request
        flavorName := data.FlavorName.ValueString()
        zone := data.Zone.ValueString()
        createRequest := sdktypes.CloudServerRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.CloudServerPropertiesRequest{
                        FlavorName: &amp;flavorName,
                        Zone:       zone,
                        BootVolume: sdktypes.ReferenceResource{
                                URI: bootVolumeURI,
                        },
                        VPC: sdktypes.ReferenceResource{
                                URI: vpcURI,
                        },
                        Subnets:        subnetRefs,
                        SecurityGroups: securityGroupRefs,
                },
        }

        // Add keypair if provided (URI should already be a full URI from resource reference)
        if !data.KeyPairUriRef.IsNull() &amp;&amp; !data.KeyPairUriRef.IsUnknown() </span><span class="cov0" title="0">{
                createRequest.Properties.KeyPair = sdktypes.ReferenceResource{
                        URI: data.KeyPairUriRef.ValueString(),
                }
        }</span>

        // Note: Elastic IP attachment might be handled separately after server creation
        // or through a different API endpoint. The elastic_ip_id is stored in state for reference.

        // Create the cloud server using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromCompute().CloudServers().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating cloud server",
                        fmt.Sprintf("Unable to create cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create cloud server"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Create response may not have ID in metadata (it's a request type)
        // Use name as ID initially, then get actual ID after wait
        <span class="cov0" title="0">serverID := data.Name.ValueString()
        data.Id = types.StringValue(serverID)
        // CloudServer response uses RegionalResourceMetadataRequest which doesn't have URI
        // Set URI to null for now
        data.Uri = types.StringNull()

        // Wait for Cloud Server to be active before returning
        // This ensures Terraform doesn't proceed until CloudServer is fully ready
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromCompute().CloudServers().Get(ctx, projectID, serverID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Check if response indicates an error state
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.IsError() </span><span class="cov0" title="0">{
                        if getResp.Error != nil </span><span class="cov0" title="0">{
                                errMsg := "Unknown error"
                                if getResp.Error.Title != nil </span><span class="cov0" title="0">{
                                        errMsg = *getResp.Error.Title
                                }</span>
                                <span class="cov0" title="0">if getResp.Error.Detail != nil </span><span class="cov0" title="0">{
                                        errMsg = fmt.Sprintf("%s: %s", errMsg, *getResp.Error.Detail)
                                }</span>
                                <span class="cov0" title="0">return "", fmt.Errorf("cloud server in error state: %s", errMsg)</span>
                        }
                        <span class="cov0" title="0">return "", fmt.Errorf("cloud server API returned error response")</span>
                }
                // If we can successfully get the resource, check its status
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                // If Status.State is nil, assume it's still creating
                <span class="cov0" title="0">return "InCreation", nil</span>
        }

        // Wait for Cloud Server to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "CloudServer", serverID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cloud Server Not Active",
                        fmt.Sprintf("Cloud server was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the Cloud Server to ensure all fields are properly set
        // Note: CloudServer uses name as ID and RegionalResourceMetadataRequest doesn't have URI
        <span class="cov0" title="0">getResp, err := r.client.Client.FromCompute().CloudServers().Get(ctx, projectID, serverID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // CloudServer uses name as ID
                if getResp.Data.Metadata.Name != "" </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(getResp.Data.Metadata.Name)
                        data.Name = types.StringValue(getResp.Data.Metadata.Name)
                }</span>
                // CloudServer response uses RegionalResourceMetadataRequest which doesn't have URI
                // Set URI to null (as per Read function)
                <span class="cov0" title="0">data.Uri = types.StringNull()</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Cloud Server after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a CloudServer resource", map[string]interface{}{
                "cloudserver_id":   data.Id.ValueString(),
                "cloudserver_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CloudServerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data CloudServerResourceModel
        var state CloudServerResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Preserve immutable URI refs from state (they're not returned by API)
        <span class="cov0" title="0">data = state

        projectID := data.ProjectID.ValueString()
        serverID := data.Id.ValueString()

        if projectID == "" || serverID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Server ID are required to read the cloud server",
                )
                return
        }</span>

        // Get cloud server details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromCompute().CloudServers().Get(ctx, projectID, serverID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading cloud server",
                        fmt.Sprintf("Unable to read cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                // If cloud server not found, mark as removed
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read cloud server"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                server := response.Data

                // Update data from API response
                // CloudServer uses name as ID (Metadata doesn't have ID field)
                data.Id = types.StringValue(server.Metadata.Name)
                // CloudServer response uses RegionalResourceMetadataRequest which doesn't have URI
                // Set URI to null for now
                data.Uri = types.StringNull()
                data.Name = types.StringValue(server.Metadata.Name)
                data.Location = types.StringValue(server.Metadata.Location.Value)
                data.FlavorName = types.StringValue(server.Properties.Flavor.Name)

                if server.Properties.BootVolume.URI != "" </span><span class="cov0" title="0">{
                        data.BootVolumeUriRef = types.StringValue(server.Properties.BootVolume.URI)
                }</span>

                // Update VPC URI reference
                <span class="cov0" title="0">if server.Properties.VPC.URI != "" </span><span class="cov0" title="0">{
                        data.VpcUriRef = types.StringValue(server.Properties.VPC.URI)
                }</span>

                // Update KeyPair URI reference
                <span class="cov0" title="0">if server.Properties.KeyPair.URI != "" </span><span class="cov0" title="0">{
                        data.KeyPairUriRef = types.StringValue(server.Properties.KeyPair.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.KeyPairUriRef = types.StringNull()
                }</span>

                // Note: Subnets and SecurityGroups are not returned in the API response
                // They are immutable after creation, so we preserve them from state
                // These will be set from state in the Update function

                // Update tags from response
                <span class="cov0" title="0">if len(server.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(server.Metadata.Tags))
                        for i, tag := range server.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }

                // Note: Subnets and SecurityGroups might need to be extracted from LinkedResources
                // This is a simplified version - you may need to adjust based on actual API response structure
        } else<span class="cov0" title="0"> {
                // Cloud server not found, mark as removed
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CloudServerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data CloudServerResourceModel
        var state CloudServerResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read current state to preserve values
        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        serverID := state.Id.ValueString()

        if projectID == "" || serverID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Server ID are required to update the cloud server",
                )
                return
        }</span>

        // Get current cloud server details to preserve existing values
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromCompute().CloudServers().Get(ctx, projectID, serverID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current cloud server",
                        fmt.Sprintf("Unable to get current cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cloud Server Not Found",
                        "Cloud server not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Extract tags from Terraform list
        var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Preserve existing tags if not provided
                tags = current.Metadata.Tags
        }</span>

        // Build the update request, preserving existing values
        <span class="cov0" title="0">flavorName := current.Properties.Flavor.Name
        updateRequest := sdktypes.CloudServerRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: current.Metadata.Location.Value,
                        },
                },
                Properties: sdktypes.CloudServerPropertiesRequest{
                        FlavorName: &amp;flavorName,
                        BootVolume: current.Properties.BootVolume,
                },
        }

        // Preserve keypair if it exists
        if current.Properties.KeyPair.URI != "" </span><span class="cov0" title="0">{
                updateRequest.Properties.KeyPair = current.Properties.KeyPair
        }</span>

        // Update the cloud server using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromCompute().CloudServers().Update(ctx, projectID, serverID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating cloud server",
                        fmt.Sprintf("Unable to update cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update cloud server"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Update state with response data if available
        // Note: Update response may have different structure
        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Response may be a request type, so handle carefully
                if response.Data.Metadata.Name != "" </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(response.Data.Metadata.Name)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(response.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(response.Data.Metadata.Tags))
                        for i, tag := range response.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.VpcUriRef = state.VpcUriRef
        data.Zone = state.Zone
        data.FlavorName = state.FlavorName
        data.BootVolumeUriRef = state.BootVolumeUriRef
        data.KeyPairUriRef = state.KeyPairUriRef
        data.SubnetUriRefs = state.SubnetUriRefs
        data.SecurityGroupUriRefs = state.SecurityGroupUriRefs
        // Preserve elastic_ip_uri_ref from state if not in plan
        if data.ElasticIpUriRef.IsNull() || data.ElasticIpUriRef.IsUnknown() </span><span class="cov0" title="0">{
                data.ElasticIpUriRef = state.ElasticIpUriRef
        }</span>

        // Note: CloudServer uses name as ID and response doesn't have Metadata.ID
        // ID is already set from state above

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CloudServerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data CloudServerResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        serverID := data.Id.ValueString()

        if projectID == "" || serverID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Server ID are required to delete the cloud server",
                )
                return
        }</span>

        // Delete the cloud server using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromCompute().CloudServers().Delete(ctx, projectID, serverID, nil)
                }</span>,
                ExtractSDKError,
                "CloudServer",
                serverID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting cloud server",
                        fmt.Sprintf("Unable to delete cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a CloudServer resource", map[string]interface{}{
                "cloudserver_id": serverID,
        })</span>
}

func (r *CloudServerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;ContainerRegistryDataSource{}

func NewContainerRegistryDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;ContainerRegistryDataSource{}
}</span>

type ContainerRegistryDataSource struct {
        client *ArubaCloudClient
}

type ContainerRegistryDataSourceModel struct {
        Id              types.String `tfsdk:"id"`
        Name            types.String `tfsdk:"name"`
        Location        types.String `tfsdk:"location"`
        Tags            types.List   `tfsdk:"tags"`
        ProjectID       types.String `tfsdk:"project_id"`
        ElasticIPID     types.String `tfsdk:"elasticip_id"`
        SubnetID        types.String `tfsdk:"subnet_id"`
        SecurityGroupID types.String `tfsdk:"security_group_id"`
        BlockStorageID  types.String `tfsdk:"block_storage_id"`
        BillingPeriod   types.String `tfsdk:"billing_period"`
        AdminUser       types.String `tfsdk:"admin_user"`
}

func (d *ContainerRegistryDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_containerregistry"
}</span>

func (d *ContainerRegistryDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Container Registry data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Container Registry identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Container Registry name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Container Registry location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Container Registry resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Container Registry belongs to",
                                Computed:            true,
                        },
                        "elasticip_id": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP ID",
                                Computed:            true,
                        },
                        "subnet_id": schema.StringAttribute{
                                MarkdownDescription: "Subnet ID",
                                Computed:            true,
                        },
                        "security_group_id": schema.StringAttribute{
                                MarkdownDescription: "Security Group ID",
                                Computed:            true,
                        },
                        "block_storage_id": schema.StringAttribute{
                                MarkdownDescription: "Block Storage ID",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Computed:            true,
                        },
                        "admin_user": schema.StringAttribute{
                                MarkdownDescription: "Admin user for the Container Registry",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *ContainerRegistryDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *ContainerRegistryDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data ContainerRegistryDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-containerregistry")
        tflog.Trace(ctx, "read a Container Registry data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type ContainerRegistryResourceModel struct {
        Id                  types.String `tfsdk:"id"`
        Uri                 types.String `tfsdk:"uri"`
        Name                types.String `tfsdk:"name"`
        Location            types.String `tfsdk:"location"`
        Tags                types.List   `tfsdk:"tags"`
        ProjectID           types.String `tfsdk:"project_id"`
        PublicIpUriRef      types.String `tfsdk:"public_ip_uri_ref"`
        VpcUriRef           types.String `tfsdk:"vpc_uri_ref"`
        SubnetUriRef        types.String `tfsdk:"subnet_uri_ref"`
        SecurityGroupUriRef types.String `tfsdk:"security_group_uri_ref"`
        BlockStorageUriRef  types.String `tfsdk:"block_storage_uri_ref"`
        BillingPeriod       types.String `tfsdk:"billing_period"`
        AdminUser           types.String `tfsdk:"admin_user"`
        ConcurrentUsers     types.String `tfsdk:"concurrent_users"`
}

type ContainerRegistryResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;ContainerRegistryResource{}
var _ resource.ResourceWithImportState = &amp;ContainerRegistryResource{}

func NewContainerRegistryResource() resource.Resource <span class="cov0" title="0">{
        return &amp;ContainerRegistryResource{}
}</span>

func (r *ContainerRegistryResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_containerregistry"
}</span>

func (r *ContainerRegistryResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Container Registry resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Container Registry identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Container Registry URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Container Registry name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Container Registry location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Container Registry resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Container Registry belongs to",
                                Required:            true,
                        },
                        "public_ip_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Public IP URI reference (e.g., /projects/{project-id}/providers/Aruba.Network/elasticIps/{elasticip-id})",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "vpc_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "VPC URI reference (e.g., /projects/{project-id}/providers/Aruba.Network/vpcs/{vpc-id})",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "subnet_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Subnet URI reference (e.g., /projects/{project-id}/providers/Aruba.Network/subnets/{subnet-id})",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "security_group_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Security Group URI reference (e.g., /projects/{project-id}/providers/Aruba.Network/securityGroups/{sg-id})",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "block_storage_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Block Storage URI reference (e.g., /projects/{project-id}/providers/Aruba.Storage/volumes/{volume-id})",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Optional:            true,
                        },
                        "admin_user": schema.StringAttribute{
                                MarkdownDescription: "Administrator username",
                                Optional:            true,
                        },
                        "concurrent_users": schema.StringAttribute{
                                MarkdownDescription: "Number of concurrent users",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *ContainerRegistryResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *ContainerRegistryResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ContainerRegistryResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a container registry",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Use URI references directly from the plan
        <span class="cov0" title="0">publicIPURI := data.PublicIpUriRef.ValueString()
        vpcURI := data.VpcUriRef.ValueString()
        subnetURI := data.SubnetUriRef.ValueString()
        securityGroupURI := data.SecurityGroupUriRef.ValueString()
        blockStorageURI := data.BlockStorageUriRef.ValueString()

        // Build the create request
        createRequest := sdktypes.ContainerRegistryRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.ContainerRegistryPropertiesRequest{
                        PublicIp: sdktypes.ReferenceResource{
                                URI: publicIPURI,
                        },
                        VPC: sdktypes.ReferenceResource{
                                URI: vpcURI,
                        },
                        Subnet: sdktypes.ReferenceResource{
                                URI: subnetURI,
                        },
                        SecurityGroup: sdktypes.ReferenceResource{
                                URI: securityGroupURI,
                        },
                        BlockStorage: sdktypes.ReferenceResource{
                                URI: blockStorageURI,
                        },
                },
        }

        // Add optional fields
        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                createRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: data.BillingPeriod.ValueString(),
                }
        }</span>

        <span class="cov0" title="0">if !data.AdminUser.IsNull() &amp;&amp; !data.AdminUser.IsUnknown() </span><span class="cov0" title="0">{
                createRequest.Properties.AdminUser = &amp;sdktypes.UserCredential{
                        Username: data.AdminUser.ValueString(),
                }
        }</span>

        <span class="cov0" title="0">if !data.ConcurrentUsers.IsNull() &amp;&amp; !data.ConcurrentUsers.IsUnknown() </span><span class="cov0" title="0">{
                concurrentUsers := data.ConcurrentUsers.ValueString()
                createRequest.Properties.ConcurrentUsers = &amp;concurrentUsers
        }</span>

        // Create the container registry using the SDK
        <span class="cov0" title="0">containerClient := r.client.Client.FromContainer()
        if containerClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Client Not Available",
                        "Container client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">registryClient := containerClient.ContainerRegistry()
        if registryClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Client Not Available",
                        "Container Registry client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">response, err := registryClient.Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating container registry",
                        fmt.Sprintf("Unable to create container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create container registry"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Container registry created but no data returned from API",
                )
                return
        }</span>

        // Wait for Container Registry to be active before returning
        // This ensures Terraform doesn't proceed until Container Registry is ready
        <span class="cov0" title="0">registryID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := registryClient.Get(ctx, projectID, registryID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Container Registry to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "ContainerRegistry", registryID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Not Active",
                        fmt.Sprintf("Container registry was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Container Registry resource", map[string]interface{}{
                "containerregistry_id":   data.Id.ValueString(),
                "containerregistry_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ContainerRegistryResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ContainerRegistryResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        registryID := data.Id.ValueString()

        if projectID == "" || registryID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Registry ID are required to read the container registry",
                )
                return
        }</span>

        <span class="cov0" title="0">containerClient := r.client.Client.FromContainer()
        if containerClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Client Not Available",
                        "Container client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">registryClient := containerClient.ContainerRegistry()
        if registryClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Client Not Available",
                        "Container Registry client is not available",
                )
                return
        }</span>

        // Get container registry details using the SDK
        <span class="cov0" title="0">response, err := registryClient.Get(ctx, projectID, registryID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading container registry",
                        fmt.Sprintf("Unable to read container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read container registry"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                registry := response.Data

                if registry.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*registry.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if registry.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*registry.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if registry.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*registry.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if registry.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(registry.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if registry.Properties.PublicIp.URI != "" </span><span class="cov0" title="0">{
                        data.PublicIpUriRef = types.StringValue(registry.Properties.PublicIp.URI)
                }</span>
                <span class="cov0" title="0">if registry.Properties.VPC.URI != "" </span><span class="cov0" title="0">{
                        data.VpcUriRef = types.StringValue(registry.Properties.VPC.URI)
                }</span>
                <span class="cov0" title="0">if registry.Properties.Subnet.URI != "" </span><span class="cov0" title="0">{
                        data.SubnetUriRef = types.StringValue(registry.Properties.Subnet.URI)
                }</span>
                <span class="cov0" title="0">if registry.Properties.SecurityGroup.URI != "" </span><span class="cov0" title="0">{
                        data.SecurityGroupUriRef = types.StringValue(registry.Properties.SecurityGroup.URI)
                }</span>
                <span class="cov0" title="0">if registry.Properties.BlockStorage.URI != "" </span><span class="cov0" title="0">{
                        data.BlockStorageUriRef = types.StringValue(registry.Properties.BlockStorage.URI)
                }</span>
                <span class="cov0" title="0">if registry.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(registry.Properties.BillingPlan.BillingPeriod)
                }</span>
                <span class="cov0" title="0">if registry.Properties.AdminUser.Username != "" </span><span class="cov0" title="0">{
                        data.AdminUser = types.StringValue(registry.Properties.AdminUser.Username)
                }</span>
                <span class="cov0" title="0">if registry.Properties.ConcurrentUsers != nil </span><span class="cov0" title="0">{
                        data.ConcurrentUsers = types.StringValue(*registry.Properties.ConcurrentUsers)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(registry.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(registry.Metadata.Tags))
                        for i, tag := range registry.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ContainerRegistryResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ContainerRegistryResourceModel
        var state ContainerRegistryResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        registryID := state.Id.ValueString()

        if projectID == "" || registryID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Registry ID are required to update the container registry",
                )
                return
        }</span>

        <span class="cov0" title="0">containerClient := r.client.Client.FromContainer()
        if containerClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Client Not Available",
                        "Container client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">registryClient := containerClient.ContainerRegistry()
        if registryClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Client Not Available",
                        "Container Registry client is not available",
                )
                return
        }</span>

        // Get current container registry details
        <span class="cov0" title="0">getResponse, err := registryClient.Get(ctx, projectID, registryID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current container registry",
                        fmt.Sprintf("Unable to get current container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Not Found",
                        "Container registry not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for container registry",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - use ContainerRegistryRequest for updates (same as create)
        <span class="cov0" title="0">updateRequest := sdktypes.ContainerRegistryRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.ContainerRegistryPropertiesRequest{
                        // Preserve existing required properties
                        PublicIp:      current.Properties.PublicIp,
                        VPC:           current.Properties.VPC,
                        Subnet:        current.Properties.Subnet,
                        SecurityGroup: current.Properties.SecurityGroup,
                        BlockStorage:  current.Properties.BlockStorage,
                },
        }

        // Update billing period if provided, otherwise preserve current
        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: data.BillingPeriod.ValueString(),
                }
        }</span> else<span class="cov0" title="0"> if current.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: current.Properties.BillingPlan.BillingPeriod,
                }
        }</span>

        // Update concurrent users if provided, otherwise preserve current
        <span class="cov0" title="0">if !data.ConcurrentUsers.IsNull() &amp;&amp; !data.ConcurrentUsers.IsUnknown() </span><span class="cov0" title="0">{
                concurrentUsers := data.ConcurrentUsers.ValueString()
                updateRequest.Properties.ConcurrentUsers = &amp;concurrentUsers
        }</span> else<span class="cov0" title="0"> if current.Properties.ConcurrentUsers != nil </span><span class="cov0" title="0">{
                updateRequest.Properties.ConcurrentUsers = current.Properties.ConcurrentUsers
        }</span>

        // Preserve admin user if it exists
        <span class="cov0" title="0">if current.Properties.AdminUser.Username != "" </span><span class="cov0" title="0">{
                updateRequest.Properties.AdminUser = &amp;sdktypes.UserCredential{
                        Username: current.Properties.AdminUser.Username,
                }
        }</span>

        // Update the container registry using the SDK
        <span class="cov0" title="0">response, err := registryClient.Update(ctx, projectID, registryID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating container registry",
                        fmt.Sprintf("Unable to update container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update container registry"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.Uri = state.Uri // Preserve URI from state
        data.ProjectID = state.ProjectID
        data.PublicIpUriRef = state.PublicIpUriRef
        data.VpcUriRef = state.VpcUriRef
        data.SubnetUriRef = state.SubnetUriRef
        data.SecurityGroupUriRef = state.SecurityGroupUriRef
        data.BlockStorageUriRef = state.BlockStorageUriRef

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the container registry to get the latest state including URI
                getResp, err := registryClient.Get(ctx, projectID, registryID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if not in response
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                }</span>
        }

        // Re-read to get the latest state and update all fields
        <span class="cov0" title="0">getResp, err := registryClient.Get(ctx, projectID, registryID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                registry := getResp.Data
                // Update URI if available
                if registry.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*registry.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = state.Uri // Fallback to state if not available
                }</span>
                // Update URI refs
                <span class="cov0" title="0">if registry.Properties.PublicIp.URI != "" </span><span class="cov0" title="0">{
                        data.PublicIpUriRef = types.StringValue(registry.Properties.PublicIp.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.PublicIpUriRef = state.PublicIpUriRef // Fallback to state if not available
                }</span>
                <span class="cov0" title="0">if registry.Properties.VPC.URI != "" </span><span class="cov0" title="0">{
                        data.VpcUriRef = types.StringValue(registry.Properties.VPC.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.VpcUriRef = state.VpcUriRef // Fallback to state if not available
                }</span>
                <span class="cov0" title="0">if registry.Properties.Subnet.URI != "" </span><span class="cov0" title="0">{
                        data.SubnetUriRef = types.StringValue(registry.Properties.Subnet.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.SubnetUriRef = state.SubnetUriRef // Fallback to state if not available
                }</span>
                <span class="cov0" title="0">if registry.Properties.SecurityGroup.URI != "" </span><span class="cov0" title="0">{
                        data.SecurityGroupUriRef = types.StringValue(registry.Properties.SecurityGroup.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.SecurityGroupUriRef = state.SecurityGroupUriRef // Fallback to state if not available
                }</span>
                <span class="cov0" title="0">if registry.Properties.BlockStorage.URI != "" </span><span class="cov0" title="0">{
                        data.BlockStorageUriRef = types.StringValue(registry.Properties.BlockStorage.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.BlockStorageUriRef = state.BlockStorageUriRef // Fallback to state if not available
                }</span>
                // Update other fields from re-read to ensure consistency
                <span class="cov0" title="0">if registry.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*registry.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if registry.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(registry.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if registry.Properties.BillingPlan != nil &amp;&amp; registry.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(registry.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        data.BillingPeriod = types.StringNull()
                }</span>
                <span class="cov0" title="0">if registry.Properties.AdminUser != nil &amp;&amp; registry.Properties.AdminUser.Username != "" </span><span class="cov0" title="0">{
                        data.AdminUser = types.StringValue(registry.Properties.AdminUser.Username)
                }</span> else<span class="cov0" title="0"> {
                        data.AdminUser = types.StringNull()
                }</span>
                <span class="cov0" title="0">if registry.Properties.ConcurrentUsers != nil </span><span class="cov0" title="0">{
                        data.ConcurrentUsers = types.StringValue(*registry.Properties.ConcurrentUsers)
                }</span> else<span class="cov0" title="0"> {
                        data.ConcurrentUsers = types.StringNull()
                }</span>
                // Update tags from re-read
                <span class="cov0" title="0">if len(registry.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(registry.Metadata.Tags))
                        for i, tag := range registry.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If re-read fails, preserve immutable fields from state
                data.Uri = state.Uri
                data.PublicIpUriRef = state.PublicIpUriRef
                data.VpcUriRef = state.VpcUriRef
                data.SubnetUriRef = state.SubnetUriRef
                data.SecurityGroupUriRef = state.SecurityGroupUriRef
                data.BlockStorageUriRef = state.BlockStorageUriRef
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ContainerRegistryResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ContainerRegistryResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        registryID := data.Id.ValueString()

        if projectID == "" || registryID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Registry ID are required to delete the container registry",
                )
                return
        }</span>

        <span class="cov0" title="0">containerClient := r.client.Client.FromContainer()
        if containerClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Client Not Available",
                        "Container client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">registryClient := containerClient.ContainerRegistry()
        if registryClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Client Not Available",
                        "Container Registry client is not available",
                )
                return
        }</span>

        // Delete the container registry using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return registryClient.Delete(ctx, projectID, registryID, nil)
                }</span>,
                ExtractSDKError,
                "ContainerRegistry",
                registryID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting container registry",
                        fmt.Sprintf("Unable to delete container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Container Registry resource", map[string]interface{}{
                "containerregistry_id": registryID,
        })</span>
}

func (r *ContainerRegistryResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;DatabaseDataSource{}

func NewDatabaseDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;DatabaseDataSource{}
}</span>

type DatabaseDataSource struct {
        client *ArubaCloudClient
}

type DatabaseDataSourceModel struct {
        Id      types.String `tfsdk:"id"`
        DBaaSID types.String `tfsdk:"dbaas_id"`
        Name    types.String `tfsdk:"name"`
}

func (d *DatabaseDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_database"
}</span>

func (d *DatabaseDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database identifier",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this database belongs to",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Database name",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *DatabaseDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *DatabaseDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-database")
        tflog.Trace(ctx, "read a Database data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DatabaseResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        ProjectID types.String `tfsdk:"project_id"`
        DBaaSID   types.String `tfsdk:"dbaas_id"`
        Name      types.String `tfsdk:"name"`
}

type DatabaseResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DatabaseResource{}
var _ resource.ResourceWithImportState = &amp;DatabaseResource{}

func NewDatabaseResource() resource.Resource <span class="cov0" title="0">{
        return &amp;DatabaseResource{}
}</span>

func (r *DatabaseResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_database"
}</span>

func (r *DatabaseResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database identifier (same as name)",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Database URI",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this database belongs to",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this database belongs to",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Database name",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *DatabaseResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DatabaseResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DatabaseResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to create a database",
                )
                return
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.DatabaseRequest{
                Name: data.Name.ValueString(),
        }

        // Create the database using the SDK
        response, err := r.client.Client.FromDatabase().Databases().Create(ctx, projectID, dbaasID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating database",
                        fmt.Sprintf("Unable to create database: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create database"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Database uses name as ID
                data.Id = types.StringValue(response.Data.Name)
                // Database response doesn't have Metadata.URI
                data.Uri = types.StringNull()
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Database created but no data returned from API",
                )
                return
        }</span>

        // Wait for Database to be active before returning
        // This ensures Terraform doesn't proceed until Database is ready
        <span class="cov0" title="0">databaseName := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromDatabase().Databases().Get(ctx, projectID, dbaasID, databaseName, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Databases don't have a status field, so if we can get it, it's ready
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        return "Active", nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Database to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Database", databaseName, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Database Not Active",
                        fmt.Sprintf("Database was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Database resource", map[string]interface{}{
                "database_id":   data.Id.ValueString(),
                "database_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Id.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Database Name are required to read the database",
                )
                return
        }</span>

        // Get database details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().Databases().Get(ctx, projectID, dbaasID, databaseName, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading database",
                        fmt.Sprintf("Unable to read database: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read database"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                db := response.Data
                data.Id = types.StringValue(db.Name)
                data.Name = types.StringValue(db.Name)
                // Database response doesn't have Metadata.URI
                data.Uri = types.StringNull()
        }</span> else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DatabaseResourceModel
        var state DatabaseResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        dbaasID := state.DBaaSID.ValueString()
        oldDatabaseName := state.Id.ValueString()

        if projectID == "" || dbaasID == "" || oldDatabaseName == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Database Name are required to update the database",
                )
                return
        }</span>

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.DatabaseRequest{
                Name: data.Name.ValueString(),
        }

        // Update the database using the SDK
        response, err := r.client.Client.FromDatabase().Databases().Update(ctx, projectID, dbaasID, oldDatabaseName, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating database",
                        fmt.Sprintf("Unable to update database: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update database"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update ID to new name
                data.Id = types.StringValue(response.Data.Name)
                // Database response doesn't have Metadata.URI
                data.Uri = types.StringNull()
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.DBaaSID = state.DBaaSID

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update ID from response (database name can change, so use response)
                data.Id = types.StringValue(response.Data.Name)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DatabaseResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Id.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Database Name are required to delete the database",
                )
                return
        }</span>

        // Delete the database using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().Databases().Delete(ctx, projectID, dbaasID, databaseName, nil)
                }</span>,
                ExtractSDKError,
                "Database",
                databaseName,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting database",
                        fmt.Sprintf("Unable to delete database: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Database resource", map[string]interface{}{
                "database_id": databaseName,
        })</span>
}

func (r *DatabaseResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;DatabaseBackupDataSource{}

func NewDatabaseBackupDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;DatabaseBackupDataSource{}
}</span>

type DatabaseBackupDataSource struct {
        client *ArubaCloudClient
}

type DatabaseBackupDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        Zone          types.String `tfsdk:"zone"`
        DBaaSID       types.String `tfsdk:"dbaas_id"`
        Database      types.String `tfsdk:"database"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

func (d *DatabaseBackupDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_databasebackup"
}</span>

func (d *DatabaseBackupDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database Backup data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database Backup identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Database Backup name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Database Backup location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Database Backup resource",
                                Computed:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone for the Database Backup",
                                Computed:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this backup belongs to",
                                Computed:            true,
                        },
                        "database": schema.StringAttribute{
                                MarkdownDescription: "Database to backup (ID or name)",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *DatabaseBackupDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *DatabaseBackupDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseBackupDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-databasebackup")
        tflog.Trace(ctx, "read a Database Backup data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DatabaseBackupResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        ProjectID     types.String `tfsdk:"project_id"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        Zone          types.String `tfsdk:"zone"`
        DBaaSID       types.String `tfsdk:"dbaas_id"`
        Database      types.String `tfsdk:"database"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

type DatabaseBackupResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DatabaseBackupResource{}
var _ resource.ResourceWithImportState = &amp;DatabaseBackupResource{}

func NewDatabaseBackupResource() resource.Resource <span class="cov0" title="0">{
        return &amp;DatabaseBackupResource{}
}</span>

func (r *DatabaseBackupResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_databasebackup"
}</span>

func (r *DatabaseBackupResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database Backup resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database Backup identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Database Backup URI",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this backup belongs to",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Database Backup name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Database Backup location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Database Backup resource",
                                Optional:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone for the Database Backup",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this backup belongs to",
                                Required:            true,
                        },
                        "database": schema.StringAttribute{
                                MarkdownDescription: "Database name to backup",
                                Required:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *DatabaseBackupResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DatabaseBackupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DatabaseBackupResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Database.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Database name are required to create a database backup",
                )
                return
        }</span>

        // Get DBaaS instance to get its URI
        <span class="cov0" title="0">dbaasResp, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting DBaaS instance",
                        fmt.Sprintf("Unable to get DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if dbaasResp == nil || dbaasResp.Data == nil || dbaasResp.Data.Metadata.URI == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "DBaaS Instance Not Found",
                        "DBaaS instance not found or missing URI",
                )
                return
        }</span>

        <span class="cov0" title="0">dbaasURI := *dbaasResp.Data.Metadata.URI
        // Construct database URI
        databaseURI := fmt.Sprintf("%s/databases/%s", dbaasURI, databaseName)

        var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.BackupRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.BackupPropertiesRequest{
                        Zone: data.Zone.ValueString(),
                        DBaaS: sdktypes.ReferenceResource{
                                URI: dbaasURI,
                        },
                        Database: sdktypes.ReferenceResource{
                                URI: databaseURI,
                        },
                        BillingPlan: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Create the backup using the SDK
        response, err := r.client.Client.FromDatabase().Backups().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating database backup",
                        fmt.Sprintf("Unable to create database backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create database backup"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Database backup created but no ID returned from API",
                )
                return
        }</span>

        // Wait for Database Backup to be active before returning
        // This ensures Terraform doesn't proceed until Backup is ready
        <span class="cov0" title="0">backupID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromDatabase().Backups().Get(ctx, projectID, backupID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Database Backup to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "DatabaseBackup", backupID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Database Backup Not Active",
                        fmt.Sprintf("Database backup was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Database Backup resource", map[string]interface{}{
                "backup_id":   data.Id.ValueString(),
                "backup_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseBackupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseBackupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to read the database backup",
                )
                return
        }</span>

        // Get backup details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().Backups().Get(ctx, projectID, backupID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading database backup",
                        fmt.Sprintf("Unable to read database backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read database backup"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                backup := response.Data
                if backup.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*backup.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*backup.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if backup.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*backup.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(backup.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.Tags != nil </span><span class="cov0" title="0">{
                        tagValues := make([]attr.Value, len(backup.Metadata.Tags))
                        for i, tag := range backup.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValue(types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.Tags = types.ListNull(types.StringType)
                }</span>
                <span class="cov0" title="0">if backup.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(backup.Properties.Zone)
                }</span>
                <span class="cov0" title="0">if backup.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(backup.Properties.BillingPlan.BillingPeriod)
                }</span>
                // Extract DBaaS ID and Database name from URIs if needed
                // Note: These may need to be stored separately or extracted from URIs
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseBackupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DatabaseBackupResourceModel
        var state DatabaseBackupResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Database backups typically don't support updates
        // If they do, implement update logic here
        <span class="cov0" title="0">resp.Diagnostics.AddWarning(
                "Update Not Supported",
                "Database backups do not support updates. Changes will be ignored.",
        )

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseBackupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DatabaseBackupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to delete the database backup",
                )
                return
        }</span>

        // Delete the backup using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().Backups().Delete(ctx, projectID, backupID, nil)
                }</span>,
                ExtractSDKError,
                "DatabaseBackup",
                backupID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting database backup",
                        fmt.Sprintf("Unable to delete database backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Database Backup resource", map[string]interface{}{
                "backup_id": backupID,
        })</span>
}

func (r *DatabaseBackupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;DatabaseGrantDataSource{}

func NewDatabaseGrantDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;DatabaseGrantDataSource{}
}</span>

type DatabaseGrantDataSource struct {
        client *ArubaCloudClient
}

type DatabaseGrantDataSourceModel struct {
        Id       types.String `tfsdk:"id"`
        Database types.String `tfsdk:"database"`
        UserID   types.String `tfsdk:"user_id"`
        Role     types.String `tfsdk:"role"`
}

func (d *DatabaseGrantDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_databasegrant"
}</span>

func (d *DatabaseGrantDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database Grant data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database Grant identifier",
                                Required:            true,
                        },
                        "database": schema.StringAttribute{
                                MarkdownDescription: "Database name or ID",
                                Computed:            true,
                        },
                        "user_id": schema.StringAttribute{
                                MarkdownDescription: "User ID to grant access",
                                Computed:            true,
                        },
                        "role": schema.StringAttribute{
                                MarkdownDescription: "Role to grant (e.g., read, write, admin)",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *DatabaseGrantDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *DatabaseGrantDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseGrantDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response for all attributes
        <span class="cov0" title="0">data.Database = types.StringValue("example-database")
        data.UserID = types.StringValue("example-user-id")
        data.Role = types.StringValue("read")
        tflog.Trace(ctx, "read a Database Grant data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DatabaseGrantResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        ProjectID types.String `tfsdk:"project_id"`
        DBaaSID   types.String `tfsdk:"dbaas_id"`
        Database  types.String `tfsdk:"database"`
        UserID    types.String `tfsdk:"user_id"`
        Role      types.String `tfsdk:"role"`
}

type DatabaseGrantResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DatabaseGrantResource{}
var _ resource.ResourceWithImportState = &amp;DatabaseGrantResource{}

func NewDatabaseGrantResource() resource.Resource <span class="cov0" title="0">{
        return &amp;DatabaseGrantResource{}
}</span>

func (r *DatabaseGrantResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_databasegrant"
}</span>

func (r *DatabaseGrantResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database Grant resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database Grant identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Database Grant URI",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this grant belongs to",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this grant belongs to",
                                Required:            true,
                        },
                        "database": schema.StringAttribute{
                                MarkdownDescription: "Database name",
                                Required:            true,
                        },
                        "user_id": schema.StringAttribute{
                                MarkdownDescription: "User ID (username) to grant access",
                                Required:            true,
                        },
                        "role": schema.StringAttribute{
                                MarkdownDescription: "Role to grant (e.g., read, write, admin)",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *DatabaseGrantResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DatabaseGrantResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DatabaseGrantResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Database.ValueString()
        userID := data.UserID.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" || userID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, Database name, and User ID are required to create a database grant",
                )
                return
        }</span>

        // Build the create request
        // NOTE: GrantRole is a custom type that doesn't accept string conversion
        // This requires checking the SDK for GrantRole enum constants or if Role field accepts string
        // TODO: Fix GrantRole - check if Role field in GrantRequest is actually string type
        // or if we need to use GrantRole enum constants like sdktypes.GrantRoleRead, etc.
        <span class="cov0" title="0">roleStr := data.Role.ValueString()

        resp.Diagnostics.AddError(
                "Unimplemented: GrantRole Type",
                fmt.Sprintf("DatabaseGrant resource requires proper GrantRole type handling. Role value: %s. Please check SDK for GrantRole enum values (e.g., sdktypes.GrantRoleRead) or if Role field accepts string directly.", roleStr),
        )</span>
}

func (r *DatabaseGrantResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseGrantResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Database.ValueString()
        userID := data.UserID.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" || userID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, Database name, and User ID are required to read the database grant",
                )
                return
        }</span>

        // Get grant details using the SDK
        // Grants().Get signature: (ctx, projectID, dbaasID, databaseName, userID, nil)
        // NOTE: DatabaseGrant resource is temporarily disabled due to GrantRole type issue
        <span class="cov0" title="0">resp.Diagnostics.AddError(
                "Unimplemented: DatabaseGrant Resource",
                "DatabaseGrant resource is temporarily disabled. GrantRole type conversion needs to be resolved. Please check SDK for GrantRole enum values.",
        )</span>
}

func (r *DatabaseGrantResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DatabaseGrantResourceModel
        var state DatabaseGrantResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        dbaasID := state.DBaaSID.ValueString()
        databaseName := state.Database.ValueString()
        userID := state.UserID.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" || userID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, Database name, and User ID are required to update the database grant",
                )
                return
        }</span>

        // Build update request
        // NOTE: Same GrantRole issue as Create
        <span class="cov0" title="0">roleStr := data.Role.ValueString()
        resp.Diagnostics.AddError(
                "Unimplemented: GrantRole Type",
                fmt.Sprintf("DatabaseGrant update requires proper GrantRole type handling. Role value: %s. Please check SDK for GrantRole enum values.", roleStr),
        )</span>
}

func (r *DatabaseGrantResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DatabaseGrantResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Database.ValueString()
        userID := data.UserID.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" || userID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, Database name, and User ID are required to delete the database grant",
                )
                return
        }</span>

        // Delete the grant using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">grantID := data.Id.ValueString()
        err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().Grants().Delete(ctx, projectID, dbaasID, databaseName, userID, nil)
                }</span>,
                ExtractSDKError,
                "DatabaseGrant",
                grantID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting database grant",
                        fmt.Sprintf("Unable to delete database grant: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Database Grant resource", map[string]interface{}{
                "grant_id": grantID,
        })</span>
}

func (r *DatabaseGrantResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;DBaaSDataSource{}

func NewDBaaSDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;DBaaSDataSource{}
}</span>

type DBaaSDataSource struct {
        client *ArubaCloudClient
}

type DBaaSDataSourceModel struct {
        Id            types.String           `tfsdk:"id"`
        Name          types.String           `tfsdk:"name"`
        Location      types.String           `tfsdk:"location"`
        Tags          types.List             `tfsdk:"tags"`
        ProjectID     types.String           `tfsdk:"project_id"`
        Engine        types.String           `tfsdk:"engine"`
        Zone          types.String           `tfsdk:"zone"`
        Flavor        types.String           `tfsdk:"flavor"`
        StorageSize   types.Int64            `tfsdk:"storage_size"`
        BillingPeriod types.String           `tfsdk:"billing_period"`
        Network       *DBaaSNetworkModel     `tfsdk:"network"`
        Autoscaling   *DBaaSAutoscalingModel `tfsdk:"autoscaling"`
}

type DBaaSNetworkModel struct {
        VpcID           types.String `tfsdk:"vpc_id"`
        SubnetID        types.String `tfsdk:"subnet_id"`
        SecurityGroupID types.String `tfsdk:"security_group_id"`
        ElasticIpID     types.String `tfsdk:"elastic_ip_id"`
}

type DBaaSAutoscalingModel struct {
        Enabled        types.Bool  `tfsdk:"enabled"`
        AvailableSpace types.Int64 `tfsdk:"available_space"`
        StepSize       types.Int64 `tfsdk:"step_size"`
}

func (d *DBaaSDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaas"
}</span>

func (d *DBaaSDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "DBaaS data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "DBaaS name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "DBaaS location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the DBaaS resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this DBaaS belongs to",
                                Computed:            true,
                        },
                        "engine": schema.StringAttribute{
                                MarkdownDescription: "Database engine (mysql-8.0, mssql-2022-web, mssql-2022-standard, mssql-2022-enterprise)",
                                Computed:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone (ITBG-1, ITBG-2, ITBG-3)",
                                Computed:            true,
                        },
                        "flavor": schema.StringAttribute{
                                MarkdownDescription: "Flavor type",
                                Computed:            true,
                        },
                        "storage_size": schema.Int64Attribute{
                                MarkdownDescription: "Storage size",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Computed:            true,
                        },
                        "network": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "vpc_id": schema.StringAttribute{
                                                MarkdownDescription: "VPC ID",
                                                Computed:            true,
                                        },
                                        "subnet_id": schema.StringAttribute{
                                                MarkdownDescription: "Subnet ID",
                                                Computed:            true,
                                        },
                                        "security_group_id": schema.StringAttribute{
                                                MarkdownDescription: "Security Group ID",
                                                Computed:            true,
                                        },
                                        "elastic_ip_id": schema.StringAttribute{
                                                MarkdownDescription: "Elastic IP ID",
                                                Computed:            true,
                                        },
                                },
                                Computed: true,
                        },
                        "autoscaling": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "enabled": schema.BoolAttribute{
                                                MarkdownDescription: "Autoscaling enabled",
                                                Computed:            true,
                                        },
                                        "available_space": schema.Int64Attribute{
                                                MarkdownDescription: "Available space for autoscaling",
                                                Computed:            true,
                                        },
                                        "step_size": schema.Int64Attribute{
                                                MarkdownDescription: "Step size for autoscaling",
                                                Computed:            true,
                                        },
                                },
                                Computed: true,
                        },
                },
        }
}</span>

func (d *DBaaSDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *DBaaSDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DBaaSDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-dbaas")
        tflog.Trace(ctx, "read a DBaaS data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DBaaSResourceModel struct {
        Id                  types.String `tfsdk:"id"`
        Uri                 types.String `tfsdk:"uri"`
        Name                types.String `tfsdk:"name"`
        Location            types.String `tfsdk:"location"`
        Tags                types.List   `tfsdk:"tags"`
        ProjectID           types.String `tfsdk:"project_id"`
        EngineID            types.String `tfsdk:"engine_id"`
        Flavor              types.String `tfsdk:"flavor"`
        VpcUriRef           types.String `tfsdk:"vpc_uri_ref"`
        SubnetUriRef        types.String `tfsdk:"subnet_uri_ref"`
        SecurityGroupUriRef types.String `tfsdk:"security_group_uri_ref"`
        ElasticIpUriRef     types.String `tfsdk:"elastic_ip_uri_ref"`
        Autoscaling         types.Object `tfsdk:"autoscaling"`
}

type DBaaSResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DBaaSResource{}
var _ resource.ResourceWithImportState = &amp;DBaaSResource{}

func NewDBaaSResource() resource.Resource <span class="cov0" title="0">{
        return &amp;DBaaSResource{}
}</span>

func (r *DBaaSResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaas"
}</span>

func (r *DBaaSResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "DBaaS resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "DBaaS URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "DBaaS name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "DBaaS location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the DBaaS resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this DBaaS belongs to",
                                Required:            true,
                        },
                        "engine_id": schema.StringAttribute{
                                MarkdownDescription: "Database engine ID. Available engines are described in the [ArubaCloud API documentation](https://api.arubacloud.com/docs/metadata/#dbaas-engines). For example, `mysql-8.0` for MySQL version 8.0.",
                                Required:            true,
                        },
                        "flavor": schema.StringAttribute{
                                MarkdownDescription: "DBaaS flavor name. Available flavors are described in the [ArubaCloud API documentation](https://api.arubacloud.com/docs/metadata/#dbaas-flavors). For example, `DBO2A4` means 2 CPU and 4GB RAM.",
                                Required:            true,
                        },
                        "vpc_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "URI reference to the VPC resource (e.g., `arubacloud_vpc.example.uri`)",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "subnet_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "URI reference to the Subnet resource (e.g., `arubacloud_subnet.example.uri`)",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "security_group_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "URI reference to the Security Group resource (e.g., `arubacloud_securitygroup.example.uri`)",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "elastic_ip_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "URI reference to the Elastic IP resource (e.g., `arubacloud_elasticip.example.uri`)",
                                Optional:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "autoscaling": schema.SingleNestedAttribute{
                                MarkdownDescription: "Autoscaling configuration for the DBaaS instance",
                                Optional:            true,
                                Attributes: map[string]schema.Attribute{
                                        "enabled": schema.BoolAttribute{
                                                MarkdownDescription: "Enable autoscaling",
                                                Required:            true,
                                        },
                                        "available_space": schema.Int64Attribute{
                                                MarkdownDescription: "Available space for autoscaling (in GB)",
                                                Required:            true,
                                        },
                                        "step_size": schema.Int64Attribute{
                                                MarkdownDescription: "Step size for autoscaling (in GB)",
                                                Required:            true,
                                        },
                                },
                        },
                },
        }
}</span>

func (r *DBaaSResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DBaaSResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaaSResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a DBaaS instance",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">engineID := data.EngineID.ValueString()
        flavor := data.Flavor.ValueString()

        // Validate required network fields
        if data.VpcUriRef.IsNull() || data.VpcUriRef.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing VPC URI Reference",
                        "VPC URI reference is required to create a DBaaS instance",
                )
                return
        }</span>
        <span class="cov0" title="0">if data.SubnetUriRef.IsNull() || data.SubnetUriRef.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Subnet URI Reference",
                        "Subnet URI reference is required to create a DBaaS instance",
                )
                return
        }</span>
        <span class="cov0" title="0">if data.SecurityGroupUriRef.IsNull() || data.SecurityGroupUriRef.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Security Group URI Reference",
                        "Security Group URI reference is required to create a DBaaS instance",
                )
                return
        }</span>

        // Build the create request
        // Note: Network fields (VPC, Subnet, SecurityGroup, ElasticIp) and Autoscaling
        // are stored in state but the SDK structure needs to be verified.
        // For now, we preserve them in state for future use when SDK supports them.
        <span class="cov0" title="0">createRequest := sdktypes.DBaaSRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.DBaaSPropertiesRequest{
                        Engine: &amp;sdktypes.DBaaSEngine{
                                ID: &amp;engineID,
                        },
                        Flavor: &amp;sdktypes.DBaaSFlavor{
                                Name: &amp;flavor,
                        },
                },
        }

        // Create the DBaaS instance using the SDK
        response, err := r.client.Client.FromDatabase().DBaaS().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating DBaaS instance",
                        fmt.Sprintf("Unable to create DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create DBaaS instance"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "DBaaS instance created but no data returned from API",
                )
                return
        }</span>

        // Wait for DBaaS to be active before returning
        // This ensures Terraform doesn't proceed until DBaaS is ready
        <span class="cov0" title="0">dbaasID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for DBaaS to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "DBaaS", dbaasID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "DBaaS Not Active",
                        fmt.Sprintf("DBaaS instance was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the DBaaS instance to populate URI
        <span class="cov0" title="0">getResp, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                dbaas := getResp.Data
                if dbaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*dbaas.Metadata.URI)
                }</span>
                // Preserve network URI references and autoscaling from plan/state
                // They are not yet available in the SDK response structure
        }

        <span class="cov0" title="0">tflog.Trace(ctx, "created a DBaaS resource", map[string]interface{}{
                "dbaas_id":   data.Id.ValueString(),
                "dbaas_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DBaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.Id.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to read the DBaaS instance",
                )
                return
        }</span>

        // Get DBaaS instance details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading DBaaS instance",
                        fmt.Sprintf("Unable to read DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read DBaaS instance"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                dbaas := response.Data

                if dbaas.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*dbaas.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if dbaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*dbaas.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if dbaas.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*dbaas.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if dbaas.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(dbaas.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if dbaas.Properties.Engine != nil &amp;&amp; dbaas.Properties.Engine.ID != nil </span><span class="cov0" title="0">{
                        data.EngineID = types.StringValue(*dbaas.Properties.Engine.ID)
                }</span>
                <span class="cov0" title="0">if dbaas.Properties.Flavor != nil &amp;&amp; dbaas.Properties.Flavor.Name != nil </span><span class="cov0" title="0">{
                        data.Flavor = types.StringValue(*dbaas.Properties.Flavor.Name)
                }</span>

                // Preserve network URI references and autoscaling from state
                // The SDK response structure for these fields needs to be verified
                // For now, they are preserved from state to maintain consistency

                // Update tags
                <span class="cov0" title="0">if len(dbaas.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(dbaas.Metadata.Tags))
                        for i, tag := range dbaas.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DBaaSResourceModel
        var state DBaaSResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        dbaasID := state.Id.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to update the DBaaS instance",
                )
                return
        }</span>

        // Get current DBaaS instance details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current DBaaS instance",
                        fmt.Sprintf("Unable to get current DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "DBaaS Instance Not Found",
                        "DBaaS instance not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for DBaaS instance",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated
        <span class="cov0" title="0">updateRequest := sdktypes.DBaaSRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.DBaaSPropertiesRequest{
                        // Preserve current engine if it exists
                        Engine: func() *sdktypes.DBaaSEngine </span><span class="cov0" title="0">{
                                if current.Properties.Engine != nil </span><span class="cov0" title="0">{
                                        return &amp;sdktypes.DBaaSEngine{
                                                ID: current.Properties.Engine.ID,
                                        }
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        // Preserve current flavor if it exists
                        Flavor: func() *sdktypes.DBaaSFlavor <span class="cov0" title="0">{
                                if current.Properties.Flavor != nil </span><span class="cov0" title="0">{
                                        return &amp;sdktypes.DBaaSFlavor{
                                                Name: current.Properties.Flavor.Name,
                                        }
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                },
        }

        // Update the DBaaS instance using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().DBaaS().Update(ctx, projectID, dbaasID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating DBaaS instance",
                        fmt.Sprintf("Unable to update DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update DBaaS instance"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Preserve immutable fields from state
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Uri = state.Uri
        data.VpcUriRef = state.VpcUriRef
        data.SubnetUriRef = state.SubnetUriRef
        data.SecurityGroupUriRef = state.SecurityGroupUriRef
        data.ElasticIpUriRef = state.ElasticIpUriRef
        data.Autoscaling = state.Autoscaling

        // Re-read the DBaaS instance to get the latest state
        getResp, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                dbaas := getResp.Data
                if dbaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*dbaas.Metadata.URI)
                }</span>
                // Note: Network URI references are preserved from state
                // They are not yet available in the SDK response structure
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DBaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.Id.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to delete the DBaaS instance",
                )
                return
        }</span>

        // Delete the DBaaS instance using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().DBaaS().Delete(ctx, projectID, dbaasID, nil)
                }</span>,
                ExtractSDKError,
                "DBaaS",
                dbaasID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting DBaaS instance",
                        fmt.Sprintf("Unable to delete DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a DBaaS resource", map[string]interface{}{
                "dbaas_id": dbaasID,
        })</span>
}

func (r *DBaaSResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DBaaSUserDataSourceModel struct {
        Id       types.String `tfsdk:"id"`
        DBaaSID  types.String `tfsdk:"dbaas_id"`
        Username types.String `tfsdk:"username"`
        Password types.String `tfsdk:"password"`
}

type DBaaSUserDataSource struct {
        client *ArubaCloudClient
}

var _ datasource.DataSource = &amp;DBaaSUserDataSource{}

func NewDBaaSUserDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;DBaaSUserDataSource{}
}</span>

func (d *DBaaSUserDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaasuser"
}</span>

func (d *DBaaSUserDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "DBaaS User data source",
                Attributes: map[string]schema.Attribute{
                        "username": schema.StringAttribute{
                                MarkdownDescription: "Username for the DBaaS user (lookup key)",
                                Required:            true,
                        },
                        "id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS User identifier",
                                Computed:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this user belongs to",
                                Computed:            true,
                        },
                        "password": schema.StringAttribute{
                                MarkdownDescription: "Password for the DBaaS user",
                                Computed:            true,
                                Sensitive:           true,
                        },
                },
        }
}</span>

func (d *DBaaSUserDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected DataSource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *DBaaSUserDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DBaaSUserDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response
        <span class="cov0" title="0">data.Id = types.StringValue("dbaasuser-id")
        data.Password = types.StringValue("simulated-password")
        tflog.Trace(ctx, "read a DBaaS User data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DBaaSUserResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        ProjectID types.String `tfsdk:"project_id"`
        DBaaSID   types.String `tfsdk:"dbaas_id"`
        Username  types.String `tfsdk:"username"`
        Password  types.String `tfsdk:"password"`
}

type DBaaSUserResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DBaaSUserResource{}
var _ resource.ResourceWithImportState = &amp;DBaaSUserResource{}

func NewDBaaSUserResource() resource.Resource <span class="cov0" title="0">{
        return &amp;DBaaSUserResource{}
}</span>

func (r *DBaaSUserResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaasuser"
}</span>

func (r *DBaaSUserResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "DBaaS User resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS User identifier (same as username)",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "DBaaS User URI",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this user belongs to",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this user belongs to",
                                Required:            true,
                        },
                        "username": schema.StringAttribute{
                                MarkdownDescription: "Username for the DBaaS user",
                                Required:            true,
                        },
                        "password": schema.StringAttribute{
                                MarkdownDescription: "Password for the DBaaS user",
                                Required:            true,
                                Sensitive:           true,
                        },
                },
        }
}</span>

func (r *DBaaSUserResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DBaaSUserResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaaSUserResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to create a DBaaS user",
                )
                return
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.UserRequest{
                Username: data.Username.ValueString(),
                Password: data.Password.ValueString(),
        }

        // Create the user using the SDK
        response, err := r.client.Client.FromDatabase().Users().Create(ctx, projectID, dbaasID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating DBaaS user",
                        fmt.Sprintf("Unable to create DBaaS user: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create DBaaS user"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // User uses username as ID
                data.Id = types.StringValue(response.Data.Username)
                // UserResponse doesn't have Metadata.URI
                data.Uri = types.StringNull()
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "DBaaS user created but no data returned from API",
                )
                return
        }</span>

        // Wait for DBaaS User to be active before returning
        // This ensures Terraform doesn't proceed until User is ready
        <span class="cov0" title="0">username := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromDatabase().Users().Get(ctx, projectID, dbaasID, username, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Users don't have a status field, so if we can get it, it's ready
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        return "Active", nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for DBaaS User to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "DBaaSUser", username, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "DBaaS User Not Active",
                        fmt.Sprintf("DBaaS user was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a DBaaS User resource", map[string]interface{}{
                "user_id":  data.Id.ValueString(),
                "username": data.Username.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSUserResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DBaaSUserResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        username := data.Id.ValueString()

        if projectID == "" || dbaasID == "" || username == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Username are required to read the DBaaS user",
                )
                return
        }</span>

        // Get user details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().Users().Get(ctx, projectID, dbaasID, username, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading DBaaS user",
                        fmt.Sprintf("Unable to read DBaaS user: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read DBaaS user"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                user := response.Data
                data.Id = types.StringValue(user.Username)
                // UserResponse doesn't have Metadata.URI
                data.Uri = types.StringNull()
                data.Username = types.StringValue(user.Username)
                // Password is not returned from API, so we keep the existing value
        }</span> else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSUserResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DBaaSUserResourceModel
        var state DBaaSUserResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        dbaasID := state.DBaaSID.ValueString()
        username := state.Id.ValueString()

        if projectID == "" || dbaasID == "" || username == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Username are required to update the DBaaS user",
                )
                return
        }</span>

        // Only password can be updated
        <span class="cov0" title="0">updateRequest := sdktypes.UserRequest{
                Username: username,
                Password: data.Password.ValueString(),
        }

        // Update the user using the SDK
        response, err := r.client.Client.FromDatabase().Users().Update(ctx, projectID, dbaasID, username, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating DBaaS user",
                        fmt.Sprintf("Unable to update DBaaS user: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update DBaaS user"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(response.Data.Username)
                // UserResponse doesn't have Metadata.URI
                data.Uri = types.StringNull()
                data.Username = types.StringValue(response.Data.Username)
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.DBaaSID = state.DBaaSID

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update ID from response (username can change, so use response)
                data.Id = types.StringValue(response.Data.Username)
                data.Username = types.StringValue(response.Data.Username)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSUserResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DBaaSUserResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        username := data.Id.ValueString()

        if projectID == "" || dbaasID == "" || username == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Username are required to delete the DBaaS user",
                )
                return
        }</span>

        // Delete the user using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().Users().Delete(ctx, projectID, dbaasID, username, nil)
                }</span>,
                ExtractSDKError,
                "DBaaSUser",
                username,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting DBaaS user",
                        fmt.Sprintf("Unable to delete DBaaS user: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a DBaaS User resource", map[string]interface{}{
                "user_id": username,
        })</span>
}

func (r *DBaaSUserResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;ElasticIPDataSource{}

func NewElasticIPDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;ElasticIPDataSource{}
}</span>

type ElasticIPDataSource struct {
        client *ArubaCloudClient
}

type ElasticIPDataSourceModel struct {
        Id types.String `tfsdk:"id"`
        Ip types.String `tfsdk:"ip"`
}

func (d *ElasticIPDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_elasticip"
}</span>

func (d *ElasticIPDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Elastic IP data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP identifier",
                                Required:            true,
                        },
                        "ip": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP address",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *ElasticIPDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *ElasticIPDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data ElasticIPDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Ip = types.StringValue("1.2.3.4")
        tflog.Trace(ctx, "read an Elastic IP data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;ElasticIPResource{}
var _ resource.ResourceWithImportState = &amp;ElasticIPResource{}

func NewElasticIPResource() resource.Resource <span class="cov0" title="0">{
        return &amp;ElasticIPResource{}
}</span>

type ElasticIPResource struct {
        client *ArubaCloudClient
}

type ElasticIPResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Address       types.String `tfsdk:"address"`
        ProjectId     types.String `tfsdk:"project_id"`
}

func (r *ElasticIPResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_elasticip"
}</span>

func (r *ElasticIPResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Project resource",
                Attributes: map[string]schema.Attribute{
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Elastic IP",
                                Optional:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period for the Elastic IP (only 'hourly' allowed)",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                                // Validators removed for v1.16.1 compatibility
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Elastic IP belongs to",
                                Required:            true,
                        },
                        "address": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP address (computed from ElasticIpPropertiesResponse)",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP Identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
        }
}</span>

func (r *ElasticIPResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *ElasticIPResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ElasticIPResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create an Elastic IP",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.ElasticIPRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.ElasticIPPropertiesRequest{
                        BillingPlan: sdktypes.BillingPeriodResource{
                                BillingPeriod: func() string </span><span class="cov0" title="0">{
                                        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                                return data.BillingPeriod.ValueString()
                                        }</span>
                                        // Default to "hourly" if not provided
                                        <span class="cov0" title="0">return "hourly"</span>
                                }(),
                        },
                },
        }

        // Create the Elastic IP using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().ElasticIPs().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating Elastic IP",
                        fmt.Sprintf("Unable to create Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create Elastic IP"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span> else<span class="cov0" title="0"> {
                        resp.Diagnostics.AddError(
                                "Invalid API Response",
                                "Elastic IP created but ID not returned from API",
                        )
                        return
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                        data.Address = types.StringValue(*response.Data.Properties.Address)
                }</span>
                // Set billing_period from create response if available
                <span class="cov0" title="0">if response.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(response.Data.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> if data.BillingPeriod.IsNull() || data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                        // Fallback to plan value or default
                        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span>{<span class="cov0" title="0">
                                // Keep plan value
                        }</span> else<span class="cov0" title="0"> {
                                data.BillingPeriod = types.StringValue("hourly")
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Elastic IP created but no data returned from API",
                )
                return
        }</span>

        // Wait for Elastic IP to be active before returning (ElasticIP is referenced by CloudServer)
        // This ensures Terraform doesn't proceed to create dependent resources until ElasticIP is ready
        <span class="cov0" title="0">eipID := data.Id.ValueString()
        if eipID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Elastic IP ID",
                        "Elastic IP ID is required but was not set",
                )
                return
        }</span>
        <span class="cov0" title="0">checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Elastic IP to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "ElasticIP", eipID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Elastic IP Not Active",
                        fmt.Sprintf("Elastic IP was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Read the Elastic IP again to get the address and ensure ID is set (it might not be available immediately after creation)
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Update address from re-read response (computed field from ElasticIpPropertiesResponse)
                <span class="cov0" title="0">if getResp.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                        data.Address = types.StringValue(*getResp.Data.Properties.Address)
                }</span> else<span class="cov0" title="0"> {
                        // Address might not be available yet, set to null
                        data.Address = types.StringNull()
                }</span>
                // Update billing_period from the re-read response
                <span class="cov0" title="0">if getResp.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(getResp.Data.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to plan value or default if not available
                        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span>{<span class="cov0" title="0">
                                // Keep the plan value
                        }</span> else<span class="cov0" title="0"> {
                                data.BillingPeriod = types.StringValue("hourly")
                        }</span>
                }
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Elastic IP after creation: %v", err))
                // Ensure billing_period is set even if re-read fails
                if data.BillingPeriod.IsNull() || data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue("hourly")
                }</span>
        }

        <span class="cov0" title="0">tflog.Trace(ctx, "created an Elastic IP resource", map[string]interface{}{
                "elasticip_id":   data.Id.ValueString(),
                "elasticip_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ElasticIPResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ElasticIPResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        eipID := data.Id.ValueString()

        // If ID is unknown or empty, the resource doesn't exist yet (e.g., during plan for new resources)
        // Return early without error - this is expected behavior
        if data.Id.IsUnknown() || data.Id.IsNull() || eipID == "" </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Elastic IP ID is unknown or empty, skipping read", map[string]interface{}{
                        "eip_id": eipID,
                })
                return
        }</span>

        // Project ID should always be set, but check to be safe
        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to read the Elastic IP",
                )
                return
        }</span>

        // Get Elastic IP details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading Elastic IP",
                        fmt.Sprintf("Unable to read Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read Elastic IP"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                eip := response.Data

                if eip.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*eip.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if eip.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*eip.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if eip.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*eip.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if eip.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(eip.Metadata.LocationResponse.Value)
                }</span>
                // Update address from response (computed field from ElasticIpPropertiesResponse)
                <span class="cov0" title="0">if eip.Properties.Address != nil </span><span class="cov0" title="0">{
                        data.Address = types.StringValue(*eip.Properties.Address)
                }</span> else<span class="cov0" title="0"> {
                        // Address might not be available yet, set to null
                        data.Address = types.StringNull()
                }</span>
                // Always set billing_period from API response (it's always available from API)
                // This ensures it's always in state, preventing false changes in plan
                <span class="cov0" title="0">if eip.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(eip.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to "hourly" if API doesn't return it (shouldn't happen)
                        data.BillingPeriod = types.StringValue("hourly")
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(eip.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(eip.Metadata.Tags))
                        for i, tag := range eip.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ElasticIPResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ElasticIPResourceModel
        var state ElasticIPResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Use IDs from state (they are immutable)
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        eipID := state.Id.ValueString()

        if projectID == "" || eipID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Elastic IP ID are required to update the Elastic IP",
                )
                return
        }</span>

        // Get current Elastic IP details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current Elastic IP",
                        fmt.Sprintf("Unable to get current Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Elastic IP Not Found",
                        "Elastic IP not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if Elastic IP is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update During Creation",
                        "Cannot update Elastic IP while it is in 'InCreation' state. Please wait until the Elastic IP is fully created.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for Elastic IP",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build the update request
        <span class="cov0" title="0">updateRequest := sdktypes.ElasticIPRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.ElasticIPPropertiesRequest{
                        BillingPlan: current.Properties.BillingPlan,
                },
        }

        // Update the Elastic IP using the SDK
        response, err := r.client.Client.FromNetwork().ElasticIPs().Update(ctx, projectID, eipID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating Elastic IP",
                        fmt.Sprintf("Unable to update Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update Elastic IP"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.Uri = state.Uri         // Preserve URI from state
        data.Address = state.Address // Preserve address from state (computed field)

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If no URI in response, re-read the Elastic IP to get the latest state
                        getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                                }</span> else<span class="cov0" title="0"> {
                                        data.Uri = state.Uri // Fallback to state if not available
                                }</span>
                                // Also update address from re-read if available
                                <span class="cov0" title="0">if getResp.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                                        data.Address = types.StringValue(*getResp.Data.Properties.Address)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if re-read fails
                        }</span>
                }
                // Update address from response if available (computed field from ElasticIpPropertiesResponse)
                <span class="cov0" title="0">if response.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                        data.Address = types.StringValue(*response.Data.Properties.Address)
                }</span>
                // Always set billing_period from response if available
                <span class="cov0" title="0">if response.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(response.Data.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        // If not in response, re-read to get it
                        getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                                        data.BillingPeriod = types.StringValue(getResp.Data.Properties.BillingPlan.BillingPeriod)
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to state or default
                                        if !state.BillingPeriod.IsNull() &amp;&amp; !state.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                                data.BillingPeriod = state.BillingPeriod
                                        }</span> else<span class="cov0" title="0"> {
                                                data.BillingPeriod = types.StringValue("hourly")
                                        }</span>
                                }
                                // Also update address from re-read if available (computed field from ElasticIpPropertiesResponse)
                                <span class="cov0" title="0">if getResp.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                                        data.Address = types.StringValue(*getResp.Data.Properties.Address)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Fallback to state or default
                                if !state.BillingPeriod.IsNull() &amp;&amp; !state.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                        data.BillingPeriod = state.BillingPeriod
                                }</span> else<span class="cov0" title="0"> {
                                        data.BillingPeriod = types.StringValue("hourly")
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI from state and set billing_period from API or default
                data.Uri = state.Uri
                // Re-read to get billing_period
                getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                                data.BillingPeriod = types.StringValue(getResp.Data.Properties.BillingPlan.BillingPeriod)
                        }</span> else<span class="cov0" title="0"> {
                                if !state.BillingPeriod.IsNull() &amp;&amp; !state.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                        data.BillingPeriod = state.BillingPeriod
                                }</span> else<span class="cov0" title="0"> {
                                        data.BillingPeriod = types.StringValue("hourly")
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Fallback to state or default
                        if !state.BillingPeriod.IsNull() &amp;&amp; !state.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                data.BillingPeriod = state.BillingPeriod
                        }</span> else<span class="cov0" title="0"> {
                                data.BillingPeriod = types.StringValue("hourly")
                        }</span>
                }
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ElasticIPResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ElasticIPResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        eipID := data.Id.ValueString()

        // If ID is unknown or empty, the resource doesn't exist (e.g., during plan or if never created)
        // Return early without error - this is expected behavior
        if data.Id.IsUnknown() || data.Id.IsNull() || eipID == "" </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Elastic IP ID is unknown or empty, skipping delete", map[string]interface{}{
                        "eip_id": eipID,
                })
                return
        }</span>

        // Project ID should always be set, but check to be safe
        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to delete the Elastic IP",
                )
                return
        }</span>

        // Delete the Elastic IP using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().ElasticIPs().Delete(ctx, projectID, eipID, nil)
                }</span>,
                ExtractSDKError,
                "ElasticIP",
                eipID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting Elastic IP",
                        fmt.Sprintf("Unable to delete Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted an Elastic IP resource", map[string]interface{}{
                "elasticip_id": eipID,
        })</span>
}

func (r *ElasticIPResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;KaaSDataSource{}

func NewKaaSDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;KaaSDataSource{}
}</span>

type KaaSDataSource struct {
        client *ArubaCloudClient
}

type KaaSDataSourceModel struct {
        Id                types.String    `tfsdk:"id"`
        Name              types.String    `tfsdk:"name"`
        Location          types.String    `tfsdk:"location"`
        Tags              types.List      `tfsdk:"tags"`
        ProjectID         types.String    `tfsdk:"project_id"`
        Preset            types.Bool      `tfsdk:"preset"`
        VpcID             types.String    `tfsdk:"vpc_id"`
        SubnetID          types.String    `tfsdk:"subnet_id"`
        NodeCIDR          NodeCIDRModel   `tfsdk:"node_cidr"`
        SecurityGroupName types.String    `tfsdk:"security_group_name"`
        Version           types.String    `tfsdk:"version"`
        NodePools         []NodePoolModel `tfsdk:"node_pools"`
        HA                types.Bool      `tfsdk:"ha"`
        BillingPeriod     types.String    `tfsdk:"billing_period"`
}

type NodeCIDRModel struct {
        Address    types.String `tfsdk:"address"`
        SubnetName types.String `tfsdk:"subnet_name"`
}

type NodePoolModel struct {
        NodePoolName types.String `tfsdk:"node_pool_name"`
        Replicas     types.Int64  `tfsdk:"replicas"`
        Type         types.String `tfsdk:"type"`
        Zone         types.String `tfsdk:"zone"`
}

func (d *KaaSDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_kaas"
}</span>

func (d *KaaSDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "KaaS data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "KaaS identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "KaaS name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "KaaS location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the KaaS resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this KaaS resource belongs to",
                                Computed:            true,
                        },
                        "preset": schema.BoolAttribute{
                                MarkdownDescription: "Whether to use a preset configuration",
                                Computed:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "VPC ID for the KaaS resource",
                                Computed:            true,
                        },
                        "subnet_id": schema.StringAttribute{
                                MarkdownDescription: "Subnet ID for the KaaS resource",
                                Computed:            true,
                        },
                        "node_cidr": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "address": schema.StringAttribute{
                                                MarkdownDescription: "Node CIDR address",
                                                Computed:            true,
                                        },
                                        "subnet_name": schema.StringAttribute{
                                                MarkdownDescription: "Node CIDR subnet name",
                                                Computed:            true,
                                        },
                                },
                                Computed: true,
                        },
                        "security_group_name": schema.StringAttribute{
                                MarkdownDescription: "Security group name",
                                Computed:            true,
                        },
                        "version": schema.StringAttribute{
                                MarkdownDescription: "Kubernetes version",
                                Computed:            true,
                        },
                        "node_pools": schema.ListNestedAttribute{
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "node_pool_name": schema.StringAttribute{Computed: true},
                                                "replicas":       schema.Int64Attribute{Computed: true},
                                                "type":           schema.StringAttribute{Computed: true},
                                                "zone":           schema.StringAttribute{Computed: true},
                                        },
                                },
                                Computed: true,
                        },
                        "ha": schema.BoolAttribute{
                                MarkdownDescription: "High availability",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *KaaSDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *KaaSDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data KaaSDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-kaas")
        tflog.Trace(ctx, "read a KaaS data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KaaSResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;KaaSResource{}
var _ resource.ResourceWithImportState = &amp;KaaSResource{}

func NewKaaSResource() resource.Resource <span class="cov0" title="0">{
        return &amp;KaaSResource{}
}</span>

type KaaSResourceModel struct {
        Id                types.String `tfsdk:"id"`
        Uri               types.String `tfsdk:"uri"`
        Name              types.String `tfsdk:"name"`
        Location          types.String `tfsdk:"location"`
        Tags              types.List   `tfsdk:"tags"`
        ProjectID         types.String `tfsdk:"project_id"`
        VpcUriRef         types.String `tfsdk:"vpc_uri_ref"`
        SubnetUriRef      types.String `tfsdk:"subnet_uri_ref"`
        NodeCIDR          types.Object `tfsdk:"node_cidr"`
        SecurityGroupName types.String `tfsdk:"security_group_name"`
        KubernetesVersion types.String `tfsdk:"kubernetes_version"`
        NodePools         types.List   `tfsdk:"node_pools"`
        HA                types.Bool   `tfsdk:"ha"`
        BillingPeriod     types.String `tfsdk:"billing_period"`
        PodCIDR           types.String `tfsdk:"pod_cidr"`
}

type KaaSNodeCIDRModel struct {
        Address types.String `tfsdk:"address"`
        Name    types.String `tfsdk:"name"`
}

type KaaSNodePoolModel struct {
        Name        types.String `tfsdk:"name"`
        Nodes       types.Int64  `tfsdk:"nodes"`
        Instance    types.String `tfsdk:"instance"`
        Zone        types.String `tfsdk:"zone"`
        Autoscaling types.Bool   `tfsdk:"autoscaling"`
        MinCount    types.Int64  `tfsdk:"min_count"`
        MaxCount    types.Int64  `tfsdk:"max_count"`
}

func (r *KaaSResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_kaas"
}</span>

func (r *KaaSResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "KaaS (Kubernetes as a Service) resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "KaaS identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "KaaS URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "KaaS name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "KaaS location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the KaaS resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this KaaS resource belongs to",
                                Required:            true,
                        },
                        "vpc_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "VPC URI reference for the KaaS resource (e.g., /projects/{project-id}/providers/Aruba.Network/vpcs/{vpc-id})",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "subnet_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Subnet URI reference for the KaaS resource (e.g., /projects/{project-id}/providers/Aruba.Network/subnets/{subnet-id})",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "node_cidr": schema.SingleNestedAttribute{
                                MarkdownDescription: "Node CIDR configuration",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "address": schema.StringAttribute{
                                                MarkdownDescription: "Node CIDR address in CIDR notation (e.g., 10.0.0.0/16)",
                                                Required:            true,
                                        },
                                        "name": schema.StringAttribute{
                                                MarkdownDescription: "Node CIDR name",
                                                Required:            true,
                                        },
                                },
                        },
                        "security_group_name": schema.StringAttribute{
                                MarkdownDescription: "Security group name",
                                Required:            true,
                        },
                        "kubernetes_version": schema.StringAttribute{
                                MarkdownDescription: "Kubernetes version (e.g., 1.28.0)",
                                Required:            true,
                        },
                        "node_pools": schema.ListNestedAttribute{
                                MarkdownDescription: "Node pools configuration",
                                Required:            true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "name": schema.StringAttribute{
                                                        MarkdownDescription: "Node pool name",
                                                        Required:            true,
                                                },
                                                "nodes": schema.Int64Attribute{
                                                        MarkdownDescription: "Number of nodes in the node pool",
                                                        Required:            true,
                                                },
                                                "instance": schema.StringAttribute{
                                                        MarkdownDescription: "Instance configuration name for nodes",
                                                        Required:            true,
                                                },
                                                "zone": schema.StringAttribute{
                                                        MarkdownDescription: "Datacenter/zone code for nodes",
                                                        Required:            true,
                                                },
                                                "autoscaling": schema.BoolAttribute{
                                                        MarkdownDescription: "Enable autoscaling for node pool",
                                                        Optional:            true,
                                                },
                                                "min_count": schema.Int64Attribute{
                                                        MarkdownDescription: "Minimum number of nodes for autoscaling",
                                                        Optional:            true,
                                                },
                                                "max_count": schema.Int64Attribute{
                                                        MarkdownDescription: "Maximum number of nodes for autoscaling",
                                                        Optional:            true,
                                                },
                                        },
                                },
                        },
                        "ha": schema.BoolAttribute{
                                MarkdownDescription: "High availability",
                                Optional:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Optional:            true,
                        },
                        "pod_cidr": schema.StringAttribute{
                                MarkdownDescription: "Pod CIDR",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *KaaSResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *KaaSResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data KaaSResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a KaaS cluster",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Use VPC and Subnet URIs directly from the plan
        <span class="cov0" title="0">vpcURI := data.VpcUriRef.ValueString()
        subnetURI := data.SubnetUriRef.ValueString()

        // Extract Node CIDR
        var nodeCIDRModel KaaSNodeCIDRModel
        diags := data.NodeCIDR.As(ctx, &amp;nodeCIDRModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract Node Pools
        <span class="cov0" title="0">var nodePoolModels []KaaSNodePoolModel
        if !data.NodePools.IsNull() &amp;&amp; !data.NodePools.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.NodePools.ElementsAs(ctx, &amp;nodePoolModels, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">if len(nodePoolModels) == 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Node Pools",
                        "At least one node pool is required",
                )
                return
        }</span>

        // Build node pools
        <span class="cov0" title="0">nodePools := make([]sdktypes.NodePoolProperties, len(nodePoolModels))
        for i, np := range nodePoolModels </span><span class="cov0" title="0">{
                nodePool := sdktypes.NodePoolProperties{
                        Name:        np.Name.ValueString(),
                        Nodes:       int32(np.Nodes.ValueInt64()),
                        Instance:    np.Instance.ValueString(),
                        Zone:        np.Zone.ValueString(),
                        Autoscaling: np.Autoscaling.ValueBool(),
                }
                if !np.MinCount.IsNull() &amp;&amp; np.MinCount.ValueInt64() &gt; 0 </span><span class="cov0" title="0">{
                        minCount := int32(np.MinCount.ValueInt64())
                        nodePool.MinCount = &amp;minCount
                }</span>
                <span class="cov0" title="0">if !np.MaxCount.IsNull() &amp;&amp; np.MaxCount.ValueInt64() &gt; 0 </span><span class="cov0" title="0">{
                        maxCount := int32(np.MaxCount.ValueInt64())
                        nodePool.MaxCount = &amp;maxCount
                }</span>
                <span class="cov0" title="0">nodePools[i] = nodePool</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.KaaSRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.KaaSPropertiesRequest{
                        VPC: sdktypes.ReferenceResource{
                                URI: vpcURI,
                        },
                        Subnet: sdktypes.ReferenceResource{
                                URI: subnetURI,
                        },
                        NodeCIDR: sdktypes.NodeCIDRProperties{
                                Address: nodeCIDRModel.Address.ValueString(),
                                Name:    nodeCIDRModel.Name.ValueString(),
                        },
                        SecurityGroup: sdktypes.SecurityGroupProperties{
                                Name: data.SecurityGroupName.ValueString(),
                        },
                        KubernetesVersion: sdktypes.KubernetesVersionInfo{
                                Value: data.KubernetesVersion.ValueString(),
                        },
                        NodePools: nodePools,
                },
        }

        // Add optional fields
        if !data.PodCIDR.IsNull() &amp;&amp; !data.PodCIDR.IsUnknown() </span><span class="cov0" title="0">{
                podCIDR := data.PodCIDR.ValueString()
                createRequest.Properties.PodCIDR = &amp;podCIDR
        }</span>

        <span class="cov0" title="0">if !data.HA.IsNull() &amp;&amp; !data.HA.IsUnknown() </span><span class="cov0" title="0">{
                ha := data.HA.ValueBool()
                createRequest.Properties.HA = &amp;ha
        }</span>

        <span class="cov0" title="0">if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                createRequest.Properties.BillingPlan = sdktypes.BillingPeriodResource{
                        BillingPeriod: data.BillingPeriod.ValueString(),
                }
        }</span>

        // Create the KaaS cluster using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromContainer().KaaS().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating KaaS cluster",
                        fmt.Sprintf("Unable to create KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create KaaS cluster"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "KaaS cluster created but no data returned from API",
                )
                return
        }</span>

        // Wait for KaaS to be active before returning
        // This ensures Terraform doesn't proceed until KaaS is ready
        <span class="cov0" title="0">kaasID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for KaaS to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "KaaS", kaasID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "KaaS Not Active",
                        fmt.Sprintf("KaaS cluster was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a KaaS resource", map[string]interface{}{
                "kaas_id":   data.Id.ValueString(),
                "kaas_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KaaSResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data KaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        kaasID := data.Id.ValueString()

        if projectID == "" || kaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KaaS ID are required to read the KaaS cluster",
                )
                return
        }</span>

        // Get KaaS cluster details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading KaaS cluster",
                        fmt.Sprintf("Unable to read KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read KaaS cluster"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                kaas := response.Data

                if kaas.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*kaas.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if kaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*kaas.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if kaas.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*kaas.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if kaas.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(kaas.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.KubernetesVersion.Value != nil </span><span class="cov0" title="0">{
                        data.KubernetesVersion = types.StringValue(*kaas.Properties.KubernetesVersion.Value)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.VPC.URI != nil &amp;&amp; *kaas.Properties.VPC.URI != "" </span><span class="cov0" title="0">{
                        data.VpcUriRef = types.StringValue(*kaas.Properties.VPC.URI)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.Subnet.URI != nil &amp;&amp; *kaas.Properties.Subnet.URI != "" </span><span class="cov0" title="0">{
                        data.SubnetUriRef = types.StringValue(*kaas.Properties.Subnet.URI)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.SecurityGroup.Name != nil &amp;&amp; *kaas.Properties.SecurityGroup.Name != "" </span><span class="cov0" title="0">{
                        data.SecurityGroupName = types.StringValue(*kaas.Properties.SecurityGroup.Name)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.NodeCIDR.Address != nil &amp;&amp; *kaas.Properties.NodeCIDR.Address != "" </span><span class="cov0" title="0">{
                        nodeCIDRObj, diags := types.ObjectValue(map[string]attr.Type{
                                "address": types.StringType,
                                "name":    types.StringType,
                        }, map[string]attr.Value{
                                "address": types.StringValue(*kaas.Properties.NodeCIDR.Address),
                                "name": types.StringValue(func() string </span><span class="cov0" title="0">{
                                        if kaas.Properties.NodeCIDR.Name != nil </span><span class="cov0" title="0">{
                                                return *kaas.Properties.NodeCIDR.Name
                                        }</span>
                                        <span class="cov0" title="0">return ""</span>
                                }()),
                        })
                        <span class="cov0" title="0">resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.NodeCIDR = nodeCIDRObj
                        }</span>
                }
                <span class="cov0" title="0">if kaas.Properties.HA != nil </span><span class="cov0" title="0">{
                        data.HA = types.BoolValue(*kaas.Properties.HA)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.PodCIDR != nil &amp;&amp; kaas.Properties.PodCIDR.Address != nil </span><span class="cov0" title="0">{
                        data.PodCIDR = types.StringValue(*kaas.Properties.PodCIDR.Address)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.BillingPlan != nil &amp;&amp; kaas.Properties.BillingPlan.BillingPeriod != nil </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(*kaas.Properties.BillingPlan.BillingPeriod)
                }</span>

                // Update node pools
                <span class="cov0" title="0">if kaas.Properties.NodePools != nil </span><span class="cov0" title="0">{
                        nodePoolValues := make([]attr.Value, 0)
                        for _, np := range *kaas.Properties.NodePools </span><span class="cov0" title="0">{
                                nodePoolMap := map[string]attr.Value{
                                        "name": types.StringValue(func() string </span><span class="cov0" title="0">{
                                                if np.Name != nil </span><span class="cov0" title="0">{
                                                        return *np.Name
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "nodes": types.Int64Value(func() int64 <span class="cov0" title="0">{
                                                if np.Nodes != nil </span><span class="cov0" title="0">{
                                                        return int64(*np.Nodes)
                                                }</span>
                                                <span class="cov0" title="0">return 0</span>
                                        }()),
                                        "instance": types.StringValue(func() string <span class="cov0" title="0">{
                                                if np.Instance != nil &amp;&amp; np.Instance.Name != nil </span><span class="cov0" title="0">{
                                                        return *np.Instance.Name
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "zone": types.StringValue(func() string <span class="cov0" title="0">{
                                                if np.DataCenter != nil &amp;&amp; np.DataCenter.Code != nil </span><span class="cov0" title="0">{
                                                        return *np.DataCenter.Code
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "autoscaling": types.BoolValue(np.Autoscaling),
                                }
                                <span class="cov0" title="0">if np.MinCount != nil </span><span class="cov0" title="0">{
                                        nodePoolMap["min_count"] = types.Int64Value(int64(*np.MinCount))
                                }</span> else<span class="cov0" title="0"> {
                                        nodePoolMap["min_count"] = types.Int64Null()
                                }</span>
                                <span class="cov0" title="0">if np.MaxCount != nil </span><span class="cov0" title="0">{
                                        nodePoolMap["max_count"] = types.Int64Value(int64(*np.MaxCount))
                                }</span> else<span class="cov0" title="0"> {
                                        nodePoolMap["max_count"] = types.Int64Null()
                                }</span>

                                <span class="cov0" title="0">nodePoolObj, diags := types.ObjectValue(map[string]attr.Type{
                                        "name":        types.StringType,
                                        "nodes":       types.Int64Type,
                                        "instance":    types.StringType,
                                        "zone":        types.StringType,
                                        "autoscaling": types.BoolType,
                                        "min_count":   types.Int64Type,
                                        "max_count":   types.Int64Type,
                                }, nodePoolMap)
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        nodePoolValues = append(nodePoolValues, nodePoolObj)
                                }</span>
                        }
                        <span class="cov0" title="0">nodePoolsList, diags := types.ListValue(types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "name":        types.StringType,
                                        "nodes":       types.Int64Type,
                                        "instance":    types.StringType,
                                        "zone":        types.StringType,
                                        "autoscaling": types.BoolType,
                                        "min_count":   types.Int64Type,
                                        "max_count":   types.Int64Type,
                                },
                        }, nodePoolValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.NodePools = nodePoolsList
                        }</span>
                }

                // Update tags
                <span class="cov0" title="0">if len(kaas.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(kaas.Metadata.Tags))
                        for i, tag := range kaas.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KaaSResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data KaaSResourceModel
        var state KaaSResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        kaasID := state.Id.ValueString()

        if projectID == "" || kaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KaaS ID are required to update the KaaS cluster",
                )
                return
        }</span>

        // Get current KaaS cluster details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current KaaS cluster",
                        fmt.Sprintf("Unable to get current KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "KaaS Cluster Not Found",
                        "KaaS cluster not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for KaaS cluster",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Extract Node Pools
        <span class="cov0" title="0">var nodePoolModels []KaaSNodePoolModel
        if !data.NodePools.IsNull() &amp;&amp; !data.NodePools.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.NodePools.ElementsAs(ctx, &amp;nodePoolModels, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build node pools
        <span class="cov0" title="0">nodePools := make([]sdktypes.NodePoolProperties, len(nodePoolModels))
        for i, np := range nodePoolModels </span><span class="cov0" title="0">{
                nodePool := sdktypes.NodePoolProperties{
                        Name:        np.Name.ValueString(),
                        Nodes:       int32(np.Nodes.ValueInt64()),
                        Instance:    np.Instance.ValueString(),
                        Zone:        np.Zone.ValueString(),
                        Autoscaling: np.Autoscaling.ValueBool(),
                }
                if !np.MinCount.IsNull() &amp;&amp; np.MinCount.ValueInt64() &gt; 0 </span><span class="cov0" title="0">{
                        minCount := int32(np.MinCount.ValueInt64())
                        nodePool.MinCount = &amp;minCount
                }</span>
                <span class="cov0" title="0">if !np.MaxCount.IsNull() &amp;&amp; np.MaxCount.ValueInt64() &gt; 0 </span><span class="cov0" title="0">{
                        maxCount := int32(np.MaxCount.ValueInt64())
                        nodePool.MaxCount = &amp;maxCount
                }</span>
                <span class="cov0" title="0">nodePools[i] = nodePool</span>
        }

        // Build Kubernetes version update
        <span class="cov0" title="0">kubernetesVersionValue := data.KubernetesVersion.ValueString()
        if kubernetesVersionValue == "" &amp;&amp; current.Properties.KubernetesVersion.Value != nil </span><span class="cov0" title="0">{
                kubernetesVersionValue = *current.Properties.KubernetesVersion.Value
        }</span>

        <span class="cov0" title="0">kubernetesVersionUpdate := sdktypes.KubernetesVersionInfoUpdate{
                Value: kubernetesVersionValue,
        }

        // Build update request
        updateRequest := sdktypes.KaaSUpdateRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.KaaSPropertiesUpdateRequest{
                        KubernetesVersion: kubernetesVersionUpdate,
                        NodePools:         nodePools,
                },
        }

        // Add optional fields
        if !data.HA.IsNull() &amp;&amp; !data.HA.IsUnknown() </span><span class="cov0" title="0">{
                ha := data.HA.ValueBool()
                updateRequest.Properties.HA = &amp;ha
        }</span> else<span class="cov0" title="0"> if current.Properties.HA != nil </span><span class="cov0" title="0">{
                updateRequest.Properties.HA = current.Properties.HA
        }</span>

        <span class="cov0" title="0">if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: data.BillingPeriod.ValueString(),
                }
        }</span> else<span class="cov0" title="0"> if current.Properties.BillingPlan != nil &amp;&amp; current.Properties.BillingPlan.BillingPeriod != nil </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: *current.Properties.BillingPlan.BillingPeriod,
                }
        }</span>

        // Update the KaaS cluster using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromContainer().KaaS().Update(ctx, projectID, kaasID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating KaaS cluster",
                        fmt.Sprintf("Unable to update KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update KaaS cluster"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.Uri = state.Uri // Preserve URI from state
        data.ProjectID = state.ProjectID
        data.VpcUriRef = state.VpcUriRef
        data.SubnetUriRef = state.SubnetUriRef

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the KaaS cluster to get the latest state including URI
                getResp, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if not in response
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                }</span>
        }

        // Re-read to get the latest state and update all fields
        <span class="cov0" title="0">getResp, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                kaas := getResp.Data
                // Update URI if available
                if kaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*kaas.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = state.Uri // Fallback to state if not available
                }</span>
                // Update VPC and Subnet URI refs
                <span class="cov0" title="0">if kaas.Properties.VPC.URI != nil </span><span class="cov0" title="0">{
                        data.VpcUriRef = types.StringValue(*kaas.Properties.VPC.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.VpcUriRef = state.VpcUriRef // Fallback to state if not available
                }</span>
                <span class="cov0" title="0">if kaas.Properties.Subnet.URI != nil </span><span class="cov0" title="0">{
                        data.SubnetUriRef = types.StringValue(*kaas.Properties.Subnet.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.SubnetUriRef = state.SubnetUriRef // Fallback to state if not available
                }</span>
                // Update other fields from re-read to ensure consistency
                <span class="cov0" title="0">if kaas.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*kaas.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if kaas.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(kaas.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.KubernetesVersion.Value != nil </span><span class="cov0" title="0">{
                        data.KubernetesVersion = types.StringValue(*kaas.Properties.KubernetesVersion.Value)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.SecurityGroup.Name != nil </span><span class="cov0" title="0">{
                        data.SecurityGroupName = types.StringValue(*kaas.Properties.SecurityGroup.Name)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.NodeCIDR.Address != nil &amp;&amp; kaas.Properties.NodeCIDR.Name != nil </span><span class="cov0" title="0">{
                        nodeCIDRObj, diags := types.ObjectValue(map[string]attr.Type{
                                "address": types.StringType,
                                "name":    types.StringType,
                        }, map[string]attr.Value{
                                "address": types.StringValue(*kaas.Properties.NodeCIDR.Address),
                                "name":    types.StringValue(*kaas.Properties.NodeCIDR.Name),
                        })
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.NodeCIDR = nodeCIDRObj
                        }</span>
                }
                <span class="cov0" title="0">if kaas.Properties.HA != nil </span><span class="cov0" title="0">{
                        data.HA = types.BoolValue(*kaas.Properties.HA)
                }</span> else<span class="cov0" title="0"> {
                        data.HA = types.BoolNull()
                }</span>
                <span class="cov0" title="0">if kaas.Properties.PodCIDR != nil &amp;&amp; kaas.Properties.PodCIDR.Address != nil </span><span class="cov0" title="0">{
                        data.PodCIDR = types.StringValue(*kaas.Properties.PodCIDR.Address)
                }</span> else<span class="cov0" title="0"> {
                        data.PodCIDR = types.StringNull()
                }</span>
                <span class="cov0" title="0">if kaas.Properties.BillingPlan != nil &amp;&amp; kaas.Properties.BillingPlan.BillingPeriod != nil </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(*kaas.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        data.BillingPeriod = types.StringNull()
                }</span>
                // Update node pools from re-read
                <span class="cov0" title="0">if kaas.Properties.NodePools != nil </span><span class="cov0" title="0">{
                        nodePoolValues := make([]attr.Value, 0)
                        for _, np := range *kaas.Properties.NodePools </span><span class="cov0" title="0">{
                                nodePoolMap := map[string]attr.Value{
                                        "name": types.StringValue(func() string </span><span class="cov0" title="0">{
                                                if np.Name != nil </span><span class="cov0" title="0">{
                                                        return *np.Name
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "nodes": types.Int64Value(func() int64 <span class="cov0" title="0">{
                                                if np.Nodes != nil </span><span class="cov0" title="0">{
                                                        return int64(*np.Nodes)
                                                }</span>
                                                <span class="cov0" title="0">return 0</span>
                                        }()),
                                        "instance": types.StringValue(func() string <span class="cov0" title="0">{
                                                if np.Instance != nil &amp;&amp; np.Instance.Name != nil </span><span class="cov0" title="0">{
                                                        return *np.Instance.Name
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "zone": types.StringValue(func() string <span class="cov0" title="0">{
                                                if np.DataCenter != nil &amp;&amp; np.DataCenter.Code != nil </span><span class="cov0" title="0">{
                                                        return *np.DataCenter.Code
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "autoscaling": types.BoolValue(np.Autoscaling),
                                }
                                <span class="cov0" title="0">if np.MinCount != nil </span><span class="cov0" title="0">{
                                        nodePoolMap["min_count"] = types.Int64Value(int64(*np.MinCount))
                                }</span> else<span class="cov0" title="0"> {
                                        nodePoolMap["min_count"] = types.Int64Null()
                                }</span>
                                <span class="cov0" title="0">if np.MaxCount != nil </span><span class="cov0" title="0">{
                                        nodePoolMap["max_count"] = types.Int64Value(int64(*np.MaxCount))
                                }</span> else<span class="cov0" title="0"> {
                                        nodePoolMap["max_count"] = types.Int64Null()
                                }</span>

                                <span class="cov0" title="0">nodePoolObj, diags := types.ObjectValue(map[string]attr.Type{
                                        "name":        types.StringType,
                                        "nodes":       types.Int64Type,
                                        "instance":    types.StringType,
                                        "zone":        types.StringType,
                                        "autoscaling": types.BoolType,
                                        "min_count":   types.Int64Type,
                                        "max_count":   types.Int64Type,
                                }, nodePoolMap)
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        nodePoolValues = append(nodePoolValues, nodePoolObj)
                                }</span>
                        }
                        <span class="cov0" title="0">nodePoolsList, diags := types.ListValue(types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "name":        types.StringType,
                                        "nodes":       types.Int64Type,
                                        "instance":    types.StringType,
                                        "zone":        types.StringType,
                                        "autoscaling": types.BoolType,
                                        "min_count":   types.Int64Type,
                                        "max_count":   types.Int64Type,
                                },
                        }, nodePoolValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.NodePools = nodePoolsList
                        }</span>
                }
                // Update tags from re-read
                <span class="cov0" title="0">if len(kaas.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(kaas.Metadata.Tags))
                        for i, tag := range kaas.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If re-read fails, preserve immutable fields from state
                data.Uri = state.Uri
                data.VpcUriRef = state.VpcUriRef
                data.SubnetUriRef = state.SubnetUriRef
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KaaSResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data KaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        kaasID := data.Id.ValueString()

        if projectID == "" || kaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KaaS ID are required to delete the KaaS cluster",
                )
                return
        }</span>

        // Delete the KaaS cluster using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromContainer().KaaS().Delete(ctx, projectID, kaasID, nil)
                }</span>,
                ExtractSDKError,
                "KaaS",
                kaasID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting KaaS cluster",
                        fmt.Sprintf("Unable to delete KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a KaaS resource", map[string]interface{}{
                "kaas_id": kaasID,
        })</span>
}

func (r *KaaSResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KeypairDataSourceModel struct {
        Id       types.String `tfsdk:"id"`
        Name     types.String `tfsdk:"name"`
        Location types.String `tfsdk:"location"`
        Tags     types.List   `tfsdk:"tags"`
        Value    types.String `tfsdk:"value"`
}

type KeypairDataSource struct {
        client *ArubaCloudClient
}

var _ datasource.DataSource = &amp;KeypairDataSource{}

func NewKeypairDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;KeypairDataSource{}
}</span>

func (d *KeypairDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_keypair"
}</span>

func (d *KeypairDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Keypair data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Keypair identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Keypair name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Keypair location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the keypair",
                                Computed:            true,
                        },
                        "value": schema.StringAttribute{
                                MarkdownDescription: "Keypair value",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *KeypairDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected DataSource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *KeypairDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data KeypairDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response
        <span class="cov0" title="0">data.Id = types.StringValue("keypair-id")
        data.Value = types.StringValue("ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC...")
        tflog.Trace(ctx, "read a Keypair data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KeypairResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        ProjectID types.String `tfsdk:"project_id"`
        Value     types.String `tfsdk:"value"`
        Tags      types.List   `tfsdk:"tags"`
}

type KeypairResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;KeypairResource{}
var _ resource.ResourceWithImportState = &amp;KeypairResource{}

func NewKeypairResource() resource.Resource <span class="cov0" title="0">{
        return &amp;KeypairResource{}
}</span>

func (r *KeypairResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_keypair"
}</span>

func (r *KeypairResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Keypair resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Keypair identifier (name)",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Keypair URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Keypair name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Keypair location",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "Project ID",
                                Required:            true,
                        },
                        "value": schema.StringAttribute{
                                MarkdownDescription: "Public key value",
                                Required:            true,
                                Sensitive:           true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the keypair",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *KeypairResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *KeypairResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data KeypairResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a keypair",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.KeyPairRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.KeyPairPropertiesRequest{
                        Value: data.Value.ValueString(),
                },
        }

        // Create the keypair using the SDK
        response, err := r.client.Client.FromCompute().KeyPairs().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating keypair",
                        fmt.Sprintf("Unable to create keypair: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create keypair"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                // Include status code for better debugging
                <span class="cov0" title="0">if response.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s (HTTP %d)", errorMsg, response.StatusCode)
                }</span>

                // Log the full error for debugging
                <span class="cov0" title="0">tflog.Error(ctx, "Keypair creation failed", map[string]interface{}{
                        "error_title":  response.Error.Title,
                        "error_detail": response.Error.Detail,
                        "status_code":  response.StatusCode,
                        "keypair_name": data.Name.ValueString(),
                        "project_id":   projectID,
                })

                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Get ID from Metadata.ID (like other resources)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span> else<span class="cov0" title="0"> {
                        resp.Diagnostics.AddError(
                                "Invalid API Response",
                                "Keypair created but ID is missing from response",
                        )
                        return
                }</span>

                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Keypair created but no data returned from API",
                )
                return
        }</span>

        // Wait for Keypair to be active before returning (Keypair is referenced by CloudServer)
        // This ensures Terraform doesn't proceed to create dependent resources until Keypair is ready
        <span class="cov0" title="0">keypairID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromCompute().KeyPairs().Get(ctx, projectID, keypairID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Keypairs don't have a Status field - if we can get it, it's ready
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        return "Active", nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Keypair to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Keypair", keypairID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Keypair Not Active",
                        fmt.Sprintf("Keypair was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Keypair resource", map[string]interface{}{
                "keypair_id":   data.Id.ValueString(),
                "keypair_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KeypairResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data KeypairResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get project ID and keypair ID from state
        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        keypairID := data.Id.ValueString()

        // If ID is unknown or null, check if this is a new resource (no state) or existing resource (state exists but ID missing)
        // For new resources (during plan), we can return early
        // For existing resources, we need the ID to read - if it's missing, that's an error
        if data.Id.IsUnknown() || data.Id.IsNull() || keypairID == "" </span><span class="cov0" title="0">{
                // Check if ProjectID is also unknown - if so, this is definitely a new resource
                if data.ProjectID.IsUnknown() || data.ProjectID.IsNull() </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair ID and Project ID are unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
                // If ProjectID is set but ID is unknown, still skip (new resource)
                <span class="cov0" title="0">if keypairID == "" </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair ID is unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
        }

        // If ProjectID is missing, we can't read the keypair
        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                // Check if ProjectID is unknown (new resource) vs missing (error)
                if data.ProjectID.IsUnknown() || data.ProjectID.IsNull() </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair Project ID is unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to read the keypair",
                )
                return</span>
        }

        // Get keypair details using the SDK
        // The API Get method accepts the keypair ID
        <span class="cov0" title="0">tflog.Debug(ctx, "Reading keypair", map[string]interface{}{
                "project_id":   projectID,
                "keypair_id":   keypairID,
                "keypair_name": data.Name.ValueString(),
                "keypair_uri":  data.Uri.ValueString(),
        })

        response, err := r.client.Client.FromCompute().KeyPairs().Get(ctx, projectID, keypairID, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Error calling keypair Get API", map[string]interface{}{
                        "error":      err,
                        "project_id": projectID,
                        "keypair_id": keypairID,
                })
                resp.Diagnostics.AddError(
                        "Error reading keypair",
                        fmt.Sprintf("Unable to read keypair: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair not found (404), removing from state", map[string]interface{}{
                                "project_id": projectID,
                                "keypair_id": keypairID,
                        })
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read keypair"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">tflog.Error(ctx, "API error reading keypair", map[string]interface{}{
                        "status_code":  response.StatusCode,
                        "error_title":  response.Error.Title,
                        "error_detail": response.Error.Detail,
                        "project_id":   projectID,
                        "keypair_id":   keypairID,
                })
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                keypair := response.Data

                // Preserve ProjectID and Value from state (they're not in the API response)
                projectIDFromState := data.ProjectID
                valueFromState := data.Value
                idFromState := data.Id

                // Get ID from Metadata.ID (like other resources)
                if keypair.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*keypair.Metadata.ID)
                }</span> else<span class="cov0" title="0"> {
                        // If API doesn't provide ID, preserve from state
                        data.Id = idFromState
                }</span>

                <span class="cov0" title="0">if keypair.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*keypair.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if keypair.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*keypair.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if keypair.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(keypair.Metadata.LocationResponse.Value)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(keypair.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(keypair.Metadata.Tags))
                        for i, tag := range keypair.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Set tags to null when empty to match state (prevents false changes)
                        data.Tags = types.ListNull(types.StringType)
                }</span>

                // Restore ProjectID and Value from state (they're not returned by the API)
                <span class="cov0" title="0">data.ProjectID = projectIDFromState
                data.Value = valueFromState</span>
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KeypairResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data KeypairResourceModel
        var state KeypairResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Use IDs from state (they are immutable)
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        keypairID := state.Id.ValueString()

        if projectID == "" || keypairID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Keypair ID are required to update the keypair",
                )
                return
        }</span>

        // Keypair update is not supported by the API
        // Check if immutable fields changed
        <span class="cov0" title="0">if !data.Name.Equal(state.Name) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Keypair Name Update Not Supported",
                        "Changing the keypair name is not supported by the API. Please delete and recreate the keypair with the new name.",
                )
                return
        }</span>

        <span class="cov0" title="0">if !data.Value.Equal(state.Value) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Keypair Public Key Update Not Supported",
                        "Changing the public key value is not supported by the API. Please delete and recreate the keypair with the new public key.",
                )
                return
        }</span>

        <span class="cov0" title="0">if !data.Location.Equal(state.Location) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Keypair Location Update Not Supported",
                        "Changing the keypair location is not supported by the API. Please delete and recreate the keypair in the new location.",
                )
                return
        }</span>

        // Since updates aren't supported, we just read the resource to refresh state
        // This ensures URI and other computed fields are up to date
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromCompute().KeyPairs().Get(ctx, projectID, keypairID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading keypair",
                        fmt.Sprintf("Unable to read keypair: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.IsError() || getResponse.Data == nil </span><span class="cov0" title="0">{
                if getResponse != nil &amp;&amp; getResponse.StatusCode == 404 </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair not found (404), removing from state", map[string]interface{}{
                                "project_id": projectID,
                                "keypair_id": keypairID,
                        })
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Keypair Not Found",
                        "Keypair not found or no data returned",
                )
                return</span>
        }

        <span class="cov0" title="0">keypair := getResponse.Data

        // Ensure immutable fields are set from state before saving
        data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Location = state.Location
        data.Value = state.Value

        // Update URI from API response
        if keypair.Metadata.URI != nil </span><span class="cov0" title="0">{
                data.Uri = types.StringValue(*keypair.Metadata.URI)
        }</span> else<span class="cov0" title="0"> {
                data.Uri = state.Uri
        }</span>

        // Tags cannot be updated via API, so preserve tags from state
        // (The API doesn't support tag updates, so we keep what's in state)
        <span class="cov0" title="0">data.Tags = state.Tags

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KeypairResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data KeypairResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        keypairID := data.Id.ValueString()

        if projectID == "" || keypairID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Keypair ID are required to delete the keypair",
                )
                return
        }</span>

        // Delete the keypair using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromCompute().KeyPairs().Delete(ctx, projectID, keypairID, nil)
                }</span>,
                ExtractSDKError,
                "Keypair",
                keypairID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting keypair",
                        fmt.Sprintf("Unable to delete keypair: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Keypair resource", map[string]interface{}{
                "keypair_id": keypairID,
        })</span>
}

func (r *KeypairResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KMSDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Endpoint    types.String `tfsdk:"endpoint"`
}

type KMSDataSource struct {
        client *ArubaCloudClient
}

var _ datasource.DataSource = &amp;KMSDataSource{}

func NewKMSDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;KMSDataSource{}
}</span>

func (d *KMSDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_kms"
}</span>

func (d *KMSDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "KMS data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "KMS identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Name of the KMS resource",
                                Computed:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Description of the KMS resource",
                                Computed:            true,
                        },
                        "endpoint": schema.StringAttribute{
                                MarkdownDescription: "KMS endpoint URL",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *KMSDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected DataSource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *KMSDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data KMSDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response
        <span class="cov0" title="0">data.Id = types.StringValue("kms-id")
        data.Description = types.StringValue("Simulated KMS description")
        data.Endpoint = types.StringValue("https://kms.example.com")
        tflog.Trace(ctx, "read a KMS data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KMSResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        ProjectID     types.String `tfsdk:"project_id"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

type KMSResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;KMSResource{}
var _ resource.ResourceWithImportState = &amp;KMSResource{}

func NewKMSResource() resource.Resource <span class="cov0" title="0">{
        return &amp;KMSResource{}
}</span>

func (r *KMSResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_kms"
}</span>

func (r *KMSResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "KMS resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "KMS identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "KMS URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "KMS name",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this KMS belongs to",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Location for the KMS",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the KMS",
                                Optional:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period for the KMS",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *KMSResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *KMSResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data KMSResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()

        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to create a KMS",
                )
                return
        }</span>

        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.KmsRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.KmsPropertiesRequest{
                        BillingPeriod: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Create the KMS using the SDK
        response, err := r.client.Client.FromSecurity().KMSKeys().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating KMS",
                        fmt.Sprintf("Unable to create KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create KMS"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "KMS created but no ID returned from API",
                )
                return
        }</span>

        // Wait for KMS to be active before returning
        // This ensures Terraform doesn't proceed until KMS is ready
        <span class="cov0" title="0">kmsID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromSecurity().KMSKeys().Get(ctx, projectID, kmsID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for KMS to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "KMS", kmsID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "KMS Not Active",
                        fmt.Sprintf("KMS was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a KMS resource", map[string]interface{}{
                "kms_id":   data.Id.ValueString(),
                "kms_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KMSResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data KMSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        kmsID := data.Id.ValueString()

        if projectID == "" || kmsID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KMS ID are required to read the KMS",
                )
                return
        }</span>

        // Get KMS details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromSecurity().KMSKeys().Get(ctx, projectID, kmsID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading KMS",
                        fmt.Sprintf("Unable to read KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read KMS"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                kms := response.Data
                if kms.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*kms.Metadata.ID)
                        if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                }
                <span class="cov0" title="0">if kms.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*kms.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if kms.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(kms.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if kms.Metadata.Tags != nil </span><span class="cov0" title="0">{
                        tagValues := make([]attr.Value, len(kms.Metadata.Tags))
                        for i, tag := range kms.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValue(types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.Tags = types.ListNull(types.StringType)
                }</span>
                <span class="cov0" title="0">if kms.Properties.BillingPeriod.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(kms.Properties.BillingPeriod.BillingPeriod)
                }</span>
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KMSResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data KMSResourceModel
        var state KMSResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        kmsID := state.Id.ValueString()

        if projectID == "" || kmsID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KMS ID are required to update the KMS",
                )
                return
        }</span>

        // Get current KMS to preserve fields
        <span class="cov0" title="0">getResp, err := r.client.Client.FromSecurity().KMSKeys().Get(ctx, projectID, kmsID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting KMS",
                        fmt.Sprintf("Unable to get KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResp == nil || getResp.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "KMS Not Found",
                        "KMS not found",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResp.Data
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>

        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.KmsRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.KmsPropertiesRequest{
                        BillingPeriod: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Update the KMS using the SDK
        response, err := r.client.Client.FromSecurity().KMSKeys().Update(ctx, projectID, kmsID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating KMS",
                        fmt.Sprintf("Unable to update KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update KMS"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KMSResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data KMSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        kmsID := data.Id.ValueString()

        if projectID == "" || kmsID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KMS ID are required to delete the KMS",
                )
                return
        }</span>

        // Delete the KMS using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromSecurity().KMSKeys().Delete(ctx, projectID, kmsID, nil)
                }</span>,
                ExtractSDKError,
                "KMS",
                kmsID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting KMS",
                        fmt.Sprintf("Unable to delete KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a KMS resource", map[string]interface{}{
                "kms_id": kmsID,
        })</span>
}

func (r *KMSResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;ProjectDataSource{}

func NewProjectDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;ProjectDataSource{}
}</span>

type ProjectDataSource struct {
        client *ArubaCloudClient
}

type ProjectDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Tags        types.List   `tfsdk:"tags"`
}

func (d *ProjectDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_project"
}</span>

func (d *ProjectDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Project data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Project identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Project name",
                                Computed:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Project description",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the project",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *ProjectDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *ProjectDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data ProjectDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response for all attributes
        <span class="cov0" title="0">data.Name = types.StringValue("example-project")
        data.Description = types.StringValue("Example project description")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("tag1"),
                types.StringValue("tag2"),
        })
        tflog.Trace(ctx, "read project data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;ProjectResource{}
var _ resource.ResourceWithImportState = &amp;ProjectResource{}

func NewProjectResource() resource.Resource <span class="cov0" title="0">{
        return &amp;ProjectResource{}
}</span>

type ProjectResource struct {
        client *ArubaCloudClient
}
type ProjectResourceModel struct {
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Tags        types.List   `tfsdk:"tags"`
        Id          types.String `tfsdk:"id"`
}

func (r *ProjectResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_project"
}</span>

func (r *ProjectResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Project resource",
                Attributes: map[string]schema.Attribute{
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Project name",
                                Required:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Project description",
                                Optional:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the project",
                                Optional:            true,
                        },
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Project Identifier",
                                Computed:            true,
                        },
                },
        }
}</span>

func (r *ProjectResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *ProjectResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ProjectResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.ProjectRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
                Properties: sdktypes.ProjectPropertiesRequest{
                        Default: false, // Default to false unless specified
                },
        }

        // Add description if provided
        if !data.Description.IsNull() &amp;&amp; !data.Description.IsUnknown() </span><span class="cov0" title="0">{
                description := data.Description.ValueString()
                createRequest.Properties.Description = &amp;description
        }</span>

        // Create the project using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromProject().Create(ctx, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating project",
                        fmt.Sprintf("Unable to create project: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create project"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)

                // Update description from response if available
                if response.Data.Properties.Description != nil </span><span class="cov0" title="0">{
                        data.Description = types.StringValue(*response.Data.Properties.Description)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(response.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(response.Data.Metadata.Tags))
                        for i, tag := range response.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Project created but no ID returned from API",
                )
                return
        }</span>

        // Write logs using the tflog package
        <span class="cov0" title="0">tflog.Trace(ctx, "created a project resource", map[string]interface{}{
                "project_id":   data.Id.ValueString(),
                "project_name": data.Name.ValueString(),
        })

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ProjectResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get project ID from state
        <span class="cov0" title="0">projectID := data.Id.ValueString()

        // If ID is unknown or null, check if this is a new resource (no state) or existing resource (state exists but ID missing)
        // For new resources (during plan), we can return early
        // For existing resources, we need the ID to read - if it's missing, that's a state corruption issue
        if data.Id.IsUnknown() || data.Id.IsNull() || projectID == "" </span><span class="cov0" title="0">{
                // Check if we have any other state data that indicates this is an existing resource
                // If name is set in state, this is likely an existing resource with missing ID (state corruption)
                if !data.Name.IsUnknown() &amp;&amp; !data.Name.IsNull() &amp;&amp; data.Name.ValueString() != "" </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Project exists in state but ID is missing - this indicates a state corruption issue")
                        resp.Diagnostics.AddError(
                                "Missing Project ID",
                                "Project ID is required to read the project. The resource exists in state but the ID is missing. This indicates a state corruption issue. To fix this, you can:\n"+
                                        "1. Find the project ID using: acloud management project list\n"+
                                        "2. Import the resource: terraform import arubacloud_project.test &lt;project_id&gt;\n"+
                                        "Or manually edit the terraform.tfstate file to add the ID.",
                        )
                        return
                }</span>
                // Otherwise, this is likely a new resource during plan - return early
                <span class="cov0" title="0">tflog.Info(ctx, "Project ID is unknown or null during read, skipping API call (likely new resource).")
                return</span> // Do not error, as this is expected during plan for new resources
        }

        // Get project details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromProject().Get(ctx, projectID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading project",
                        fmt.Sprintf("Unable to read project: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                // If project not found, mark as removed
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read project"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                project := response.Data

                // Update data from API response
                if project.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*project.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if project.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*project.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if project.Properties.Description != nil </span><span class="cov0" title="0">{
                        data.Description = types.StringValue(*project.Properties.Description)
                }</span> else<span class="cov0" title="0"> {
                        data.Description = types.StringNull()
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(project.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(project.Metadata.Tags))
                        for i, tag := range project.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Set empty list if no tags
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Project not found, mark as removed
                resp.State.RemoveResource(ctx)
                return
        }</span>

        // Save updated data into Terraform state
        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ProjectResourceModel
        var state ProjectResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read current state to preserve values
        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get project ID from state (not plan) - ID is immutable and should always be in state
        // If state doesn't have ID, try to get it from plan as fallback (shouldn't happen but be defensive)
        <span class="cov0" title="0">var projectID string
        if !state.Id.IsUnknown() &amp;&amp; !state.Id.IsNull() &amp;&amp; state.Id.ValueString() != "" </span><span class="cov0" title="0">{
                projectID = state.Id.ValueString()
        }</span> else<span class="cov0" title="0"> if !data.Id.IsUnknown() &amp;&amp; !data.Id.IsNull() &amp;&amp; data.Id.ValueString() != "" </span><span class="cov0" title="0">{
                // Fallback to plan if state doesn't have it (shouldn't happen for existing resources)
                tflog.Warn(ctx, "Project ID not found in state, using plan ID as fallback")
                projectID = data.Id.ValueString()
        }</span>

        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Project ID is missing from both state and plan", map[string]interface{}{
                        "state_id_unknown": state.Id.IsUnknown(),
                        "state_id_null":    state.Id.IsNull(),
                        "state_id_value":   state.Id.ValueString(),
                        "plan_id_unknown":  data.Id.IsUnknown(),
                        "plan_id_null":     data.Id.IsNull(),
                        "plan_id_value":    data.Id.ValueString(),
                        "state_name":       state.Name.ValueString(),
                })
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to update the project. The resource exists in state but the ID is missing. This indicates a state corruption issue. To fix this, you can:\n"+
                                "1. Find the project ID using: acloud management project list\n"+
                                "2. Import the resource: terraform import arubacloud_project.test &lt;project_id&gt;\n"+
                                "Or manually edit the terraform.tfstate file to add the ID.",
                )
                return
        }</span>

        // Get current project details to preserve existing values
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromProject().Get(ctx, projectID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current project",
                        fmt.Sprintf("Unable to get current project: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Project Not Found",
                        "Project not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">currentProject := getResponse.Data

        // Extract tags from Terraform list
        var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the update request with current values as defaults
        <span class="cov0" title="0">updateRequest := sdktypes.ProjectRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
                Properties: sdktypes.ProjectPropertiesRequest{
                        Default: currentProject.Properties.Default,
                },
        }

        // Update description if provided
        if !data.Description.IsNull() &amp;&amp; !data.Description.IsUnknown() </span><span class="cov0" title="0">{
                description := data.Description.ValueString()
                updateRequest.Properties.Description = &amp;description
        }</span> else<span class="cov0" title="0"> if currentProject.Properties.Description != nil </span><span class="cov0" title="0">{
                updateRequest.Properties.Description = currentProject.Properties.Description
        }</span>

        // Update the project using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromProject().Update(ctx, projectID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating project",
                        fmt.Sprintf("Unable to update project: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update project"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure ID and Name are set from state (they are immutable)
        <span class="cov0" title="0">data.Id = state.Id
        data.Name = state.Name

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update ID from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                // Update name from response if available (should match state)
                <span class="cov0" title="0">if response.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*response.Data.Metadata.Name)
                }</span>
                // Update description from response if available
                <span class="cov0" title="0">if response.Data.Properties.Description != nil </span><span class="cov0" title="0">{
                        data.Description = types.StringValue(*response.Data.Properties.Description)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(response.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(response.Data.Metadata.Tags))
                        for i, tag := range response.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Set empty list if no tags
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        }

        // Save updated data into Terraform state
        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ProjectResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.Id.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to delete the project",
                )
                return
        }</span>

        // Delete the project using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromProject().Delete(ctx, projectID, nil)
                }</span>,
                ExtractSDKError,
                "Project",
                projectID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting project",
                        fmt.Sprintf("Unable to delete project: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a project resource", map[string]interface{}{
                "project_id": projectID,
        })</span>
}

func (r *ProjectResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/Arubacloud/sdk-go/pkg/aruba"
        "github.com/hashicorp/terraform-plugin-framework/path"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/ephemeral"
        "github.com/hashicorp/terraform-plugin-framework/function"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure ArubaCloudProvider satisfies various provider interfaces.
var _ provider.Provider = &amp;ArubaCloudProvider{}
var _ provider.ProviderWithFunctions = &amp;ArubaCloudProvider{}
var _ provider.ProviderWithEphemeralResources = &amp;ArubaCloudProvider{}

// ArubaCloudProvider defines the provider implementation.
type ArubaCloudProvider struct {
        // version is set to the provider version on release, "dev" when the
        // provider is built and ran locally, and "test" when running acceptance
        // testing.
        version string
}

// ArubaCloudProviderModel describes the provider data model.
type ArubaCloudProviderModel struct {
        ApiKey          types.String `tfsdk:"api_key"`
        ApiSecret       types.String `tfsdk:"api_secret"`
        ResourceTimeout types.String `tfsdk:"resource_timeout"`
}

func (p *ArubaCloudProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = "arubacloud"
        resp.Version = p.version
}</span>

func (p *ArubaCloudProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "api_key": schema.StringAttribute{
                                MarkdownDescription: "API key for ArubaCloud",
                                Required:            true,
                        },
                        "api_secret": schema.StringAttribute{
                                MarkdownDescription: "API secret for ArubaCloud",
                                Required:            true,
                        },
                        "resource_timeout": schema.StringAttribute{
                                MarkdownDescription: "Timeout for waiting for resources to become active after creation (e.g., \"5m\", \"10m\", \"15m\"). This timeout applies to all resources that need to wait for active state. Default: \"10m\"",
                                Optional:            true,
                        },
                },
        }
}</span>

func (p *ArubaCloudProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov0" title="0">{

        // Default values to environment variables, but override with Terraform configuration value if set.
        apiKey := os.Getenv("ARUBACLOUD_API_KEY")
        apiSecret := os.Getenv("ARUBACLOUD_API_SECRET")

        // Retrieve provider data from configuration
        var config ArubaCloudProviderModel
        diags := req.Config.Get(ctx, &amp;config)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if !config.ApiKey.IsNull() </span><span class="cov0" title="0">{
                apiKey = config.ApiKey.ValueString()
        }</span>

        <span class="cov0" title="0">if !config.ApiSecret.IsNull() </span><span class="cov0" title="0">{
                apiSecret = config.ApiSecret.ValueString()
        }</span>

        <span class="cov0" title="0">if apiKey == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("api_key"),
                        "Unknown ArubaCloud API Key",
                        "The provider cannot create the ArubaCloud API client as there is an unknown configuration value for the API key. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the ARUBACLOUD_API_KEY environment variable.",
                )
        }</span>

        <span class="cov0" title="0">if apiSecret == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("api_secret"),
                        "Unknown ArubaCloud API Secret",
                        "The provider cannot create the ArubaCloud API client as there is an unknown configuration value for the API secret. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the ARUBACLOUD_API_SECRET environment variable.",
                )
        }</span>

        <span class="cov0" title="0">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create SDK client with credentials using DefaultOptions
        <span class="cov0" title="0">options := aruba.DefaultOptions(apiKey, apiSecret)
        options = options.WithDefaultLogger()

        sdkClient, err := aruba.NewClient(options)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to create ArubaCloud SDK client",
                        fmt.Sprintf("Unable to create ArubaCloud SDK client: %s", err),
                )
                return
        }</span>

        // Parse timeout configuration with default (10 minutes - enough for most resources including CloudServer)
        <span class="cov0" title="0">resourceTimeout := parseTimeout(config.ResourceTimeout, 10*time.Minute)

        // Create a new ArubaCloud client using the SDK client
        client := &amp;ArubaCloudClient{
                ApiKey:          apiKey,
                ApiSecret:       apiSecret,
                Client:          sdkClient,
                ResourceTimeout: resourceTimeout,
        }

        resp.DataSourceData = client
        resp.ResourceData = client</span>
}

// parseTimeout parses a timeout string (e.g., "5m", "10m") and returns the duration.
// If the string is empty or invalid, returns the default duration.
func parseTimeout(timeoutStr types.String, defaultDuration time.Duration) time.Duration <span class="cov0" title="0">{
        if timeoutStr.IsNull() || timeoutStr.IsUnknown() || timeoutStr.ValueString() == "" </span><span class="cov0" title="0">{
                return defaultDuration
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(timeoutStr.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                // If parsing fails, return default
                return defaultDuration
        }</span>

        <span class="cov0" title="0">return duration</span>
}

// ArubaCloudClient wraps the SDK client with API credentials and timeout configuration.
type ArubaCloudClient struct {
        ApiKey          string
        ApiSecret       string
        Client          aruba.Client
        ResourceTimeout time.Duration
}

func (p *ArubaCloudProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov0" title="0">{

        return []func() resource.Resource{
                NewProjectResource,
                NewCloudServerResource,
                NewKeypairResource,
                NewElasticIPResource,
                NewBlockStorageResource,
                NewSnapshotResource,
                NewVPCResource,
                NewVPNTunnelResource,
                NewVPNRouteResource,
                NewSubnetResource,
                NewSecurityGroupResource,
                NewSecurityRuleResource,
                NewVpcPeeringResource,
                NewVpcPeeringRouteResource,
                NewKaaSResource,
                NewContainerRegistryResource,
                NewBackupResource,
                NewRestoreResource,
                NewDBaaSResource,
                NewDatabaseResource,
                // NewDatabaseGrantResource, // TODO: Temporarily disabled - GrantRole type conversion issue
                NewDatabaseBackupResource,
                NewDBaaSUserResource,
                NewScheduleJobResource,
                NewKMSResource,
                // NewKMIPResource, // TODO: KMIP not available in SDK yet
        }

}</span>

func (p *ArubaCloudProvider) EphemeralResources(ctx context.Context) []func() ephemeral.EphemeralResource <span class="cov0" title="0">{
        return []func() ephemeral.EphemeralResource{}
}</span>

func (p *ArubaCloudProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov0" title="0">{
        return []func() datasource.DataSource{
                NewProjectDataSource,
                NewBlockStorageDataSource,
                NewSnapshotDataSource,
                NewVPCDataSource,
                NewKeypairDataSource,
                NewCloudServerDataSource,
                NewSubnetDataSource,
                NewElasticIPDataSource,
                NewSecurityGroupDataSource,
                NewSecurityRuleDataSource,
                NewVPCPeeringDataSource,
                NewVPCPeeringRouteDataSource,
                NewKaaSDataSource,
                NewContainerRegistryDataSource,
                NewBackupDataSource,
                NewDatabaseDataSource,
                NewDatabaseBackupDataSource,
                NewDatabaseGrantDataSource,
                NewDBaaSDataSource,
                // NewKMIPDataSource, // TODO: KMIP not available in SDK yet
                NewKMSDataSource,
                NewRestoreDataSource,
                NewScheduleJobDataSource,
                NewVPNRouteDataSource,
                NewVPNTunnelDataSource,
        }
}</span>

func (p *ArubaCloudProvider) Functions(ctx context.Context) []func() function.Function <span class="cov0" title="0">{
        return []func() function.Function{}
}</span>

func New(version string) func() provider.Provider <span class="cov8" title="1">{
        return func() provider.Provider </span><span class="cov8" title="1">{
                return &amp;ArubaCloudProvider{
                        version: version,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// ResourceStateChecker is a function that checks the current state of a resource.
// Returns the state string and an error if the check failed.
type ResourceStateChecker func(ctx context.Context) (string, error)

// WaitForResourceActive waits for a resource to reach an active/ready state.
// It polls the resource status until it's not in a transitional state.
func WaitForResourceActive(ctx context.Context, checker ResourceStateChecker, resourceType, resourceID string, timeout time.Duration) error <span class="cov0" title="0">{
        deadline := time.Now().Add(timeout)
        ticker := time.NewTicker(5 * time.Second) // Poll every 5 seconds
        defer ticker.Stop()

        tflog.Info(ctx, fmt.Sprintf("Waiting for %s %s to become active", resourceType, resourceID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("context cancelled while waiting for %s %s", resourceType, resourceID)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if time.Now().After(deadline) </span><span class="cov0" title="0">{
                                return fmt.Errorf("timeout waiting for %s %s to become active (timeout: %v)", resourceType, resourceID, timeout)
                        }</span>

                        <span class="cov0" title="0">state, err := checker(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                tflog.Warn(ctx, fmt.Sprintf("Error checking %s %s status: %v", resourceType, resourceID, err))
                                continue</span>
                        }

                        // Check if resource is in a ready state
                        <span class="cov0" title="0">if isReadyState(state) </span><span class="cov0" title="0">{
                                tflog.Info(ctx, fmt.Sprintf("%s %s is now active (state: %s)", resourceType, resourceID, state))
                                return nil
                        }</span>

                        <span class="cov0" title="0">tflog.Debug(ctx, fmt.Sprintf("%s %s is still in state: %s, waiting...", resourceType, resourceID, state))</span>
                }
        }
}

// isReadyState checks if a resource state indicates it's ready to be used.
// Resources in "InCreation", "Creating", "Updating", or "Deleting" states are not ready.
func isReadyState(state string) bool <span class="cov0" title="0">{
        transitionalStates := []string{
                "InCreation",
                "Creating",
                "Updating",
                "Deleting",
                "Pending",
                "Provisioning",
        }

        for _, ts := range transitionalStates </span><span class="cov0" title="0">{
                if state == ts </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // If not in a transitional state, consider it ready
        // Common ready states: "Active", "NotUsed", "InUse", "Used", "Stopped", "Running", etc.
        <span class="cov0" title="0">return true</span>
}

// IsDependencyError checks if an API error should be retried.
// According to user requirements: retry on any error except 404 (Resource Not Found).
// We also check for dependency-related keywords in the error message for better logging.
func IsDependencyError(statusCode int, errorTitle, errorDetail *string) bool <span class="cov0" title="0">{
        // 404 means resource not found - don't retry, consider it already deleted
        if statusCode == 404 </span><span class="cov0" title="0">{
                return false
        }</span>

        // For any other error (400, 409, 500, etc.), retry as it might be a dependency issue
        // The API might return 400 for dependency errors, but we'll retry on any error
        // to handle cases where dependencies are being deleted by Terraform

        // Build error message from title and detail for logging
        <span class="cov0" title="0">errorMsg := ""
        if errorTitle != nil </span><span class="cov0" title="0">{
                errorMsg = *errorTitle
        }</span>
        <span class="cov0" title="0">if errorDetail != nil </span><span class="cov0" title="0">{
                if errorMsg != "" </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *errorDetail)
                }</span> else<span class="cov0" title="0"> {
                        errorMsg = *errorDetail
                }</span>
        }

        // If error message contains dependency keywords, it's definitely a dependency error
        <span class="cov0" title="0">if errorMsg != "" &amp;&amp; containsDependencyKeywords(errorMsg) </span><span class="cov0" title="0">{
                return true
        }</span>

        // For any non-404 error, retry (might be dependency or transient issue)
        // This handles cases where the API returns errors while dependencies are being cleaned up
        <span class="cov0" title="0">return true</span>
}

// containsDependencyKeywords checks if a string contains keywords that indicate dependency issues.
func containsDependencyKeywords(s string) bool <span class="cov0" title="0">{
        keywords := []string{
                "dependency",
                "dependent",
                "depend",
                "cannot delete",
                "can't delete",
                "still in use",
                "in use",
                "has resources",
                "contains resources",
                "has subnets",
                "has security groups",
                "has securitygroup",
                "must be deleted first",
                "delete first",
                "remove first",
                "still exists",
                "associated",
                "attached",
                "linked",
        }

        lower := strings.ToLower(s)
        for _, keyword := range keywords </span><span class="cov0" title="0">{
                if strings.Contains(lower, keyword) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// DeleteResourceWithRetry is a generic function that attempts to delete a resource with retry logic.
// It retries deletion on any error (API errors, network errors, etc.) except 404 (Resource Not Found).
// This handles cases where resources cannot be deleted due to dependencies, transient issues, or network problems.
//
// All SDK responses follow the same structure:
//   - response.IsError() - method to check if error
//   - response.StatusCode - field with HTTP status code
//   - response.Error.Title - field with error title (pointer to string)
//   - response.Error.Detail - field with error detail (pointer to string)
//
// Parameters:
//   - ctx: Context for cancellation
//   - deleteFunc: Function that performs the delete operation and returns (response, error)
//   - extractErrorFunc: Function that extracts error details from the response
//   - resourceType: Human-readable resource type name (e.g., "VPC", "Subnet")
//   - resourceID: Resource identifier for logging
//   - timeout: Maximum time to wait for successful deletion
//
// The function will:
//   - Retry on any error except 404 (consider 404 as already deleted)
//   - Retry on network errors (EOF, connection reset, timeouts, etc.)
//   - Retry on API errors (400, 409, 500, etc.) that might indicate dependencies or transient issues
//   - Use exponential backoff (5s, 10s, 15s, up to 30s max)
//   - Log retry attempts with error details
//   - Return error only if timeout is reached
func DeleteResourceWithRetry(
        ctx context.Context,
        deleteFunc func() (interface{}, error),
        extractErrorFunc func(interface{}) (statusCode int, errorTitle *string, errorDetail *string, isError bool),
        resourceType, resourceID string,
        timeout time.Duration,
) error <span class="cov0" title="0">{
        deadline := time.Now().Add(timeout)
        retryInterval := 5 * time.Second // Start with 5 second intervals
        maxRetryInterval := 30 * time.Second
        attempt := 0

        tflog.Info(ctx, fmt.Sprintf("Attempting to delete %s %s", resourceType, resourceID))

        for </span><span class="cov0" title="0">{
                attempt++
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("context cancelled while deleting %s %s", resourceType, resourceID)</span>
                default:<span class="cov0" title="0">
                        if time.Now().After(deadline) </span><span class="cov0" title="0">{
                                return fmt.Errorf("timeout waiting to delete %s %s (timeout: %v, attempts: %d)", resourceType, resourceID, timeout, attempt)
                        }</span>

                        // Attempt deletion
                        <span class="cov0" title="0">response, err := deleteFunc()
                        if err != nil </span><span class="cov0" title="0">{
                                // Network or other non-API errors - retry as they might be transient
                                // Examples: EOF, connection reset, timeout, etc.
                                errorMsg := err.Error()
                                tflog.Info(ctx, fmt.Sprintf("%s %s deletion failed with network/connection error: %s. Retrying (attempt %d)...", resourceType, resourceID, errorMsg, attempt))

                                // Wait before retrying (exponential backoff with max limit)
                                waitTime := retryInterval
                                if attempt &gt; 1 </span><span class="cov0" title="0">{
                                        // Exponential backoff: 5s, 10s, 15s, 20s, 25s, 30s (max)
                                        waitTime = time.Duration(5*attempt) * time.Second
                                        if waitTime &gt; maxRetryInterval </span><span class="cov0" title="0">{
                                                waitTime = maxRetryInterval
                                        }</span>
                                }

                                <span class="cov0" title="0">select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return fmt.Errorf("context cancelled while waiting to delete %s %s", resourceType, resourceID)</span>
                                case &lt;-time.After(waitTime):<span class="cov0" title="0">
                                        // Continue to next iteration
                                        continue</span>
                                }
                        }

                        // Extract error details using provided extractor function
                        <span class="cov0" title="0">statusCode, errorTitle, errorDetail, isError := extractErrorFunc(response)

                        // Check if deletion succeeded (no error)
                        if !isError </span><span class="cov0" title="0">{
                                tflog.Info(ctx, fmt.Sprintf("Successfully deleted %s %s", resourceType, resourceID))
                                return nil
                        }</span>

                        // Check if resource was already deleted (404) - don't retry, consider success
                        <span class="cov0" title="0">if statusCode == 404 </span><span class="cov0" title="0">{
                                tflog.Info(ctx, fmt.Sprintf("%s %s already deleted (404)", resourceType, resourceID))
                                return nil
                        }</span>

                        // For any other API error, retry (might be dependency or transient issue)
                        // Build error message for logging
                        <span class="cov0" title="0">errorMsg := ""
                        if errorTitle != nil </span><span class="cov0" title="0">{
                                errorMsg = *errorTitle
                        }</span>
                        <span class="cov0" title="0">if errorDetail != nil </span><span class="cov0" title="0">{
                                if errorMsg != "" </span><span class="cov0" title="0">{
                                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *errorDetail)
                                }</span> else<span class="cov0" title="0"> {
                                        errorMsg = *errorDetail
                                }</span>
                        }
                        <span class="cov0" title="0">if errorMsg == "" </span><span class="cov0" title="0">{
                                errorMsg = fmt.Sprintf("API error (status: %d)", statusCode)
                        }</span>

                        <span class="cov0" title="0">tflog.Info(ctx, fmt.Sprintf("%s %s deletion failed: %s. Retrying (attempt %d)...", resourceType, resourceID, errorMsg, attempt))

                        // Wait before retrying (exponential backoff with max limit)
                        waitTime := retryInterval
                        if attempt &gt; 1 </span><span class="cov0" title="0">{
                                // Exponential backoff: 5s, 10s, 15s, 20s, 25s, 30s (max)
                                waitTime = time.Duration(5*attempt) * time.Second
                                if waitTime &gt; maxRetryInterval </span><span class="cov0" title="0">{
                                        waitTime = maxRetryInterval
                                }</span>
                        }

                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return fmt.Errorf("context cancelled while waiting to delete %s %s", resourceType, resourceID)</span>
                        case &lt;-time.After(waitTime):<span class="cov0" title="0"></span>
                                // Continue to next iteration
                        }
                }
        }
}

// ExtractSDKError extracts error information from SDK responses using reflection.
// All SDK responses follow the same structure: StatusCode (int), Error.Title (*string), Error.Detail (*string)
// This function can be used by all Delete methods to extract error info generically.
func ExtractSDKError(response interface{}) (statusCode int, errorTitle *string, errorDetail *string, isError bool) <span class="cov0" title="0">{
        // First check if response has IsError() method
        type errorResponse interface {
                IsError() bool
        }
        resp, ok := response.(errorResponse)
        if !ok </span><span class="cov0" title="0">{
                return 0, nil, nil, false
        }</span>
        <span class="cov0" title="0">if !resp.IsError() </span><span class="cov0" title="0">{
                return 0, nil, nil, false
        }</span>

        // Use reflection to access StatusCode and Error fields
        <span class="cov0" title="0">v := reflect.ValueOf(response)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        // Access StatusCode field
        <span class="cov0" title="0">statusCodeField := v.FieldByName("StatusCode")
        if !statusCodeField.IsValid() || !statusCodeField.CanInterface() </span><span class="cov0" title="0">{
                return 0, nil, nil, true // It's an error but can't extract details
        }</span>
        <span class="cov0" title="0">statusCode = int(statusCodeField.Int())

        // Access Error field
        errorField := v.FieldByName("Error")
        if !errorField.IsValid() </span><span class="cov0" title="0">{
                return statusCode, nil, nil, true
        }</span>

        // Access Error.Title and Error.Detail
        <span class="cov0" title="0">var title, detail *string
        errorVal := errorField
        if errorVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if errorVal.IsNil() </span><span class="cov0" title="0">{
                        return statusCode, nil, nil, true
                }</span>
                <span class="cov0" title="0">errorVal = errorVal.Elem()</span>
        }

        <span class="cov0" title="0">if errorVal.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                titleField := errorVal.FieldByName("Title")
                if titleField.IsValid() &amp;&amp; titleField.CanInterface() &amp;&amp; !titleField.IsNil() </span><span class="cov0" title="0">{
                        if titlePtr, ok := titleField.Interface().(*string); ok </span><span class="cov0" title="0">{
                                title = titlePtr
                        }</span>
                }

                <span class="cov0" title="0">detailField := errorVal.FieldByName("Detail")
                if detailField.IsValid() &amp;&amp; detailField.CanInterface() &amp;&amp; !detailField.IsNil() </span><span class="cov0" title="0">{
                        if detailPtr, ok := detailField.Interface().(*string); ok </span><span class="cov0" title="0">{
                                detail = detailPtr
                        }</span>
                }
        }

        <span class="cov0" title="0">return statusCode, title, detail, true</span>
}

// RetryDeleteOperation is a helper that handles retry logic for delete operations.
// It should be called from Delete methods when an API error occurs (except 404).
// This function handles the retry loop with exponential backoff.
//
// Parameters:
//   - ctx: Context for cancellation
//   - deleteFunc: Function that performs the delete operation
//   - extractError: Function that extracts error info from response
//   - resourceType: Resource type name for logging
//   - resourceID: Resource ID for logging
//   - timeout: Maximum time to wait
//
// Returns error if timeout is reached, nil on success.
func RetryDeleteOperation(
        ctx context.Context,
        deleteFunc func() (interface{}, error),
        extractError func(interface{}) (statusCode int, errorTitle *string, errorDetail *string, isError bool),
        resourceType, resourceID string,
        timeout time.Duration,
) error <span class="cov0" title="0">{
        return DeleteResourceWithRetry(ctx, deleteFunc, extractError, resourceType, resourceID, timeout)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;RestoreDataSource{}

func NewRestoreDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;RestoreDataSource{}
}</span>

type RestoreDataSource struct {
        client *ArubaCloudClient
}

type RestoreDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
}

func (d *RestoreDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_restore"
}</span>

func (d *RestoreDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Restore data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Restore identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Restore name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Restore location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the restore resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this restore belongs to",
                                Computed:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "Volume ID to restore",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *RestoreDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *RestoreDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data RestoreDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-restore")
        data.Description = types.StringValue("Simulated restore description")
        tflog.Trace(ctx, "read a Restore data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type RestoreResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectID types.String `tfsdk:"project_id"`
        BackupID  types.String `tfsdk:"backup_id"`
        VolumeID  types.String `tfsdk:"volume_id"`
}

type RestoreResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;RestoreResource{}
var _ resource.ResourceWithImportState = &amp;RestoreResource{}

func NewRestoreResource() resource.Resource <span class="cov0" title="0">{
        return &amp;RestoreResource{}
}</span>

func (r *RestoreResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_restore"
}</span>

func (r *RestoreResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Restore resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Restore identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Restore URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Restore name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Restore location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the restore resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this restore belongs to",
                                Required:            true,
                        },
                        "backup_id": schema.StringAttribute{
                                MarkdownDescription: "Backup ID to restore from",
                                Required:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "Volume ID to restore to",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *RestoreResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *RestoreResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data RestoreResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.BackupID.ValueString()
        volumeID := data.VolumeID.ValueString()

        if projectID == "" || backupID == "" || volumeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, Backup ID, and Volume ID are required to create a restore",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Get the backup details to get the full URI
        <span class="cov0" title="0">backupResponse, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting backup details",
                        fmt.Sprintf("Unable to get backup details: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if backupResponse == nil || backupResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Backup Not Found",
                        "Backup not found",
                )
                return
        }</span>

        // backupURI is not used - removed unused variable

        // Get the volume details to get the full URI
        <span class="cov0" title="0">volumeResponse, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting volume details",
                        fmt.Sprintf("Unable to get volume details: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if volumeResponse == nil || volumeResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Volume Not Found",
                        "Volume not found",
                )
                return
        }</span>

        <span class="cov0" title="0">volumeURI := ""
        if volumeResponse.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                volumeURI = *volumeResponse.Data.Metadata.URI
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid Volume Response",
                        "Volume URI not found in response",
                )
                return
        }</span>

        // Build the restore request
        <span class="cov0" title="0">createRequest := sdktypes.RestoreRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.RestorePropertiesRequest{
                        Target: sdktypes.ReferenceResource{
                                URI: volumeURI,
                        },
                },
        }

        // Create the restore using the SDK
        response, err := r.client.Client.FromStorage().Restores().Create(ctx, projectID, backupID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating restore",
                        fmt.Sprintf("Unable to create restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create restore"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Restore created but no data returned from API",
                )
                return
        }</span>

        // Wait for Restore to be active before returning
        // This ensures Terraform doesn't proceed until Restore is ready
        <span class="cov0" title="0">restoreID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Restores().Get(ctx, projectID, backupID, restoreID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Restore to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Restore", restoreID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Restore Not Active",
                        fmt.Sprintf("Restore was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Restore resource", map[string]interface{}{
                "restore_id":   data.Id.ValueString(),
                "restore_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RestoreResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data RestoreResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.BackupID.ValueString()
        restoreID := data.Id.ValueString()

        if projectID == "" || backupID == "" || restoreID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, Backup ID, and Restore ID are required to read the restore",
                )
                return
        }</span>

        // Get restore details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Restores().Get(ctx, projectID, backupID, restoreID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading restore",
                        fmt.Sprintf("Unable to read restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read restore"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                restore := response.Data

                if restore.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*restore.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if restore.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*restore.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if restore.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*restore.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if restore.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(restore.Metadata.LocationResponse.Value)
                }</span>
                // Note: Target field may not be available in RestorePropertiesResult
                // VolumeID is stored from the create request, preserve from state if needed
                // If Target is needed, check SDK for correct field name

                // Update tags
                <span class="cov0" title="0">if len(restore.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(restore.Metadata.Tags))
                        for i, tag := range restore.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RestoreResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data RestoreResourceModel
        var state RestoreResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        backupID := state.BackupID.ValueString()
        restoreID := state.Id.ValueString()

        if projectID == "" || backupID == "" || restoreID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, Backup ID, and Restore ID are required to update the restore",
                )
                return
        }</span>

        // Get current restore details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromStorage().Restores().Get(ctx, projectID, backupID, restoreID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current restore",
                        fmt.Sprintf("Unable to get current restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Restore Not Found",
                        "Restore not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for restore",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated
        <span class="cov0" title="0">updateRequest := sdktypes.RestoreRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.RestorePropertiesRequest{
                        // Properties cannot be updated
                        // Note: Target field may not be available in RestorePropertiesResult
                        // Preserve from state or use original create request values
                },
        }

        // Update the restore using the SDK
        response, err := r.client.Client.FromStorage().Restores().Update(ctx, projectID, backupID, restoreID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating restore",
                        fmt.Sprintf("Unable to update restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update restore"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.BackupID = state.BackupID
        data.Uri = state.Uri           // Preserve URI from state
        data.VolumeID = state.VolumeID // Immutable

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the restore to get the latest state including URI
                getResp, err := r.client.Client.FromStorage().Restores().Get(ctx, projectID, backupID, restoreID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if not in response
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RestoreResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data RestoreResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.BackupID.ValueString()
        restoreID := data.Id.ValueString()

        if projectID == "" || backupID == "" || restoreID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, Backup ID, and Restore ID are required to delete the restore",
                )
                return
        }</span>

        // Delete the restore using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromStorage().Restores().Delete(ctx, projectID, backupID, restoreID, nil)
                }</span>,
                ExtractSDKError,
                "Restore",
                restoreID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting restore",
                        fmt.Sprintf("Unable to delete restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Restore resource", map[string]interface{}{
                "restore_id": restoreID,
        })</span>
}

func (r *RestoreResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;ScheduleJobDataSource{}

func NewScheduleJobDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;ScheduleJobDataSource{}
}</span>

type ScheduleJobDataSource struct {
        client *ArubaCloudClient
}

type ScheduleJobDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Cron        types.String `tfsdk:"cron"`
}

func (d *ScheduleJobDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_schedulejob"
}</span>

func (d *ScheduleJobDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Schedule Job data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job name",
                                Computed:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job description",
                                Computed:            true,
                        },
                        "cron": schema.StringAttribute{
                                MarkdownDescription: "Cron expression for the schedule job",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *ScheduleJobDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *ScheduleJobDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data ScheduleJobDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-schedulejob")
        data.Description = types.StringValue("Simulated schedule job description")
        data.Cron = types.StringValue("0 0 * * *")
        tflog.Trace(ctx, "read a Schedule Job data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type ScheduleJobResourceModel struct {
        Id         types.String `tfsdk:"id"`
        Uri        types.String `tfsdk:"uri"`
        Name       types.String `tfsdk:"name"`
        ProjectID  types.String `tfsdk:"project_id"`
        Tags       types.List   `tfsdk:"tags"`
        Location   types.String `tfsdk:"location"`
        Properties types.Object `tfsdk:"properties"`
}

type ScheduleJobResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;ScheduleJobResource{}
var _ resource.ResourceWithImportState = &amp;ScheduleJobResource{}

func NewScheduleJobResource() resource.Resource <span class="cov0" title="0">{
        return &amp;ScheduleJobResource{}
}</span>

func (r *ScheduleJobResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_schedulejob"
}</span>

func (r *ScheduleJobResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Schedule Job resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job name",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this job belongs to",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the job",
                                Optional:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Location for the job",
                                Required:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "enabled": schema.BoolAttribute{
                                                MarkdownDescription: "Whether the job is enabled.",
                                                Optional:            true,
                                        },
                                        "schedule_job_type": schema.StringAttribute{
                                                MarkdownDescription: "Type of job (OneShot, Recurring)",
                                                Required:            true,
                                        },
                                        "schedule_at": schema.StringAttribute{
                                                MarkdownDescription: "Date and time when the job should run (for OneShot)",
                                                Optional:            true,
                                        },
                                        "execute_until": schema.StringAttribute{
                                                MarkdownDescription: "End date until which the job can run (for Recurring)",
                                                Optional:            true,
                                        },
                                        "cron": schema.StringAttribute{
                                                MarkdownDescription: "CRON expression for recurrence (for Recurring)",
                                                Optional:            true,
                                        },
                                        "steps": schema.ListNestedAttribute{
                                                NestedObject: schema.NestedAttributeObject{
                                                        Attributes: map[string]schema.Attribute{
                                                                "name": schema.StringAttribute{
                                                                        MarkdownDescription: "Descriptive name of the step.",
                                                                        Optional:            true,
                                                                },
                                                                "resource_uri": schema.StringAttribute{
                                                                        MarkdownDescription: "URI of the resource.",
                                                                        Required:            true,
                                                                },
                                                                "action_uri": schema.StringAttribute{
                                                                        MarkdownDescription: "URI of the action to execute.",
                                                                        Required:            true,
                                                                },
                                                                "http_verb": schema.StringAttribute{
                                                                        MarkdownDescription: "HTTP verb to use (GET, POST, etc.)",
                                                                        Required:            true,
                                                                },
                                                                "body": schema.StringAttribute{
                                                                        MarkdownDescription: "Optional HTTP request body.",
                                                                        Optional:            true,
                                                                },
                                                        },
                                                },
                                                Optional: true,
                                        },
                                },
                                Required: true,
                        },
                },
        }
}</span>

func (r *ScheduleJobResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *ScheduleJobResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ScheduleJobResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()

        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to create a schedule job",
                )
                return
        }</span>

        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract properties
        <span class="cov0" title="0">var propertiesObj map[string]attr.Value
        diags := data.Properties.As(ctx, &amp;propertiesObj, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">jobTypeAttr, ok := propertiesObj["schedule_job_type"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "schedule_job_type must be a String")
                return
        }</span>
        <span class="cov0" title="0">jobType := jobTypeAttr.ValueString()

        enabled := true
        if enabledAttr, ok := propertiesObj["enabled"]; ok </span><span class="cov0" title="0">{
                if enabledBool, ok := enabledAttr.(types.Bool); ok &amp;&amp; !enabledBool.IsNull() </span><span class="cov0" title="0">{
                        enabled = enabledBool.ValueBool()
                }</span>
        }

        <span class="cov0" title="0">var scheduleAt *string
        if scheduleAtAttr, ok := propertiesObj["schedule_at"]; ok </span><span class="cov0" title="0">{
                if scheduleAtStr, ok := scheduleAtAttr.(types.String); ok &amp;&amp; !scheduleAtStr.IsNull() </span><span class="cov0" title="0">{
                        scheduleAtVal := scheduleAtStr.ValueString()
                        scheduleAt = &amp;scheduleAtVal
                }</span>
        }

        <span class="cov0" title="0">var cron *string
        if cronAttr, ok := propertiesObj["cron"]; ok </span><span class="cov0" title="0">{
                if cronStr, ok := cronAttr.(types.String); ok &amp;&amp; !cronStr.IsNull() </span><span class="cov0" title="0">{
                        cronVal := cronStr.ValueString()
                        cron = &amp;cronVal
                }</span>
        }

        <span class="cov0" title="0">var executeUntil *string
        if executeUntilAttr, ok := propertiesObj["execute_until"]; ok </span><span class="cov0" title="0">{
                if executeUntilStr, ok := executeUntilAttr.(types.String); ok &amp;&amp; !executeUntilStr.IsNull() </span><span class="cov0" title="0">{
                        executeUntilVal := executeUntilStr.ValueString()
                        executeUntil = &amp;executeUntilVal
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.JobRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.JobPropertiesRequest{
                        Enabled:      enabled,
                        JobType:      sdktypes.TypeJob(jobType),
                        ScheduleAt:   scheduleAt,
                        Cron:         cron,
                        ExecuteUntil: executeUntil,
                },
        }

        // Create the job using the SDK
        response, err := r.client.Client.FromSchedule().Jobs().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating schedule job",
                        fmt.Sprintf("Unable to create schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create schedule job"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Schedule job created but no ID returned from API",
                )
                return
        }</span>

        // Wait for Schedule Job to be active before returning
        // This ensures Terraform doesn't proceed until Job is ready
        <span class="cov0" title="0">jobID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromSchedule().Jobs().Get(ctx, projectID, jobID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Schedule Job to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "ScheduleJob", jobID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Schedule Job Not Active",
                        fmt.Sprintf("Schedule job was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Schedule Job resource", map[string]interface{}{
                "job_id":   data.Id.ValueString(),
                "job_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ScheduleJobResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ScheduleJobResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        jobID := data.Id.ValueString()

        if projectID == "" || jobID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Job ID are required to read the schedule job",
                )
                return
        }</span>

        // Get job details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromSchedule().Jobs().Get(ctx, projectID, jobID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading schedule job",
                        fmt.Sprintf("Unable to read schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read schedule job"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                job := response.Data
                if job.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*job.Metadata.ID)
                        if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                }
                <span class="cov0" title="0">if job.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*job.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if job.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(job.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if job.Metadata.Tags != nil </span><span class="cov0" title="0">{
                        tagValues := make([]attr.Value, len(job.Metadata.Tags))
                        for i, tag := range job.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValue(types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.Tags = types.ListNull(types.StringType)
                }</span>

                // Reconstruct properties object
                <span class="cov0" title="0">propertiesAttrs := map[string]attr.Value{
                        "enabled":           types.BoolValue(job.Properties.Enabled),
                        "schedule_job_type": types.StringValue(string(job.Properties.JobType)),
                        "schedule_at":       types.StringNull(),
                        "execute_until":     types.StringNull(),
                        "cron":              types.StringNull(),
                        "steps":             types.ListNull(types.ObjectType{}),
                }

                if job.Properties.ScheduleAt != nil </span><span class="cov0" title="0">{
                        propertiesAttrs["schedule_at"] = types.StringValue(*job.Properties.ScheduleAt)
                }</span>
                <span class="cov0" title="0">if job.Properties.ExecuteUntil != nil </span><span class="cov0" title="0">{
                        propertiesAttrs["execute_until"] = types.StringValue(*job.Properties.ExecuteUntil)
                }</span>
                <span class="cov0" title="0">if job.Properties.Cron != nil </span><span class="cov0" title="0">{
                        propertiesAttrs["cron"] = types.StringValue(*job.Properties.Cron)
                }</span>

                <span class="cov0" title="0">propertiesObj, diags := types.ObjectValue(
                        map[string]attr.Type{
                                "enabled":           types.BoolType,
                                "schedule_job_type": types.StringType,
                                "schedule_at":       types.StringType,
                                "execute_until":     types.StringType,
                                "cron":              types.StringType,
                                "steps":             types.ListType{ElemType: types.ObjectType{}},
                        },
                        propertiesAttrs,
                )
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Properties = propertiesObj
                }</span>
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ScheduleJobResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ScheduleJobResourceModel
        var state ScheduleJobResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        jobID := state.Id.ValueString()

        if projectID == "" || jobID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Job ID are required to update the schedule job",
                )
                return
        }</span>

        // Get current job to preserve fields
        <span class="cov0" title="0">getResp, err := r.client.Client.FromSchedule().Jobs().Get(ctx, projectID, jobID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting schedule job",
                        fmt.Sprintf("Unable to get schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResp == nil || getResp.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Job Not Found",
                        "Schedule job not found",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResp.Data
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>

        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Extract properties
        <span class="cov0" title="0">var propertiesObj map[string]attr.Value
        diags := data.Properties.As(ctx, &amp;propertiesObj, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">enabled := current.Properties.Enabled
        if enabledAttr, ok := propertiesObj["enabled"]; ok </span><span class="cov0" title="0">{
                if enabledBool, ok := enabledAttr.(types.Bool); ok &amp;&amp; !enabledBool.IsNull() </span><span class="cov0" title="0">{
                        enabled = enabledBool.ValueBool()
                }</span>
        }

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.JobRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.JobPropertiesRequest{
                        Enabled:      enabled,
                        JobType:      current.Properties.JobType,
                        ScheduleAt:   current.Properties.ScheduleAt,
                        ExecuteUntil: current.Properties.ExecuteUntil,
                        Cron:         current.Properties.Cron,
                },
        }

        // Update the job using the SDK
        response, err := r.client.Client.FromSchedule().Jobs().Update(ctx, projectID, jobID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating schedule job",
                        fmt.Sprintf("Unable to update schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update schedule job"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ScheduleJobResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ScheduleJobResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        jobID := data.Id.ValueString()

        if projectID == "" || jobID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Job ID are required to delete the schedule job",
                )
                return
        }</span>

        // Delete the job using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromSchedule().Jobs().Delete(ctx, projectID, jobID, nil)
                }</span>,
                ExtractSDKError,
                "ScheduleJob",
                jobID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting schedule job",
                        fmt.Sprintf("Unable to delete schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Schedule Job resource", map[string]interface{}{
                "job_id": jobID,
        })</span>
}

func (r *ScheduleJobResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;SecurityGroupDataSource{}

func NewSecurityGroupDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;SecurityGroupDataSource{}
}</span>

type SecurityGroupDataSource struct {
        client *ArubaCloudClient
}

type SecurityGroupDataSourceModel struct {
        Id        types.String `tfsdk:"id"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
}

func (d *SecurityGroupDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_securitygroup"
}</span>

func (d *SecurityGroupDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Security Group data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Security Group identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Security Group name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Security Group location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Security Group",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Security Group belongs to",
                                Computed:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this Security Group belongs to",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *SecurityGroupDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *SecurityGroupDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data SecurityGroupDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response for all attributes
        <span class="cov0" title="0">data.Name = types.StringValue("example-securitygroup")
        data.Location = types.StringValue("example-location")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("tag1"),
                types.StringValue("tag2"),
        })
        data.ProjectId = types.StringValue("example-project-id")
        data.VpcId = types.StringValue("example-vpc-id")
        tflog.Trace(ctx, "read a Security Group data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;SecurityGroupResource{}
var _ resource.ResourceWithImportState = &amp;SecurityGroupResource{}

func NewSecurityGroupResource() resource.Resource <span class="cov0" title="0">{
        return &amp;SecurityGroupResource{}
}</span>

type SecurityGroupResource struct {
        client *ArubaCloudClient
}

type SecurityGroupResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
}

func (r *SecurityGroupResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_securitygroup"
}</span>

func (r *SecurityGroupResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Security Group resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Security Group identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Security Group URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Security Group name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Security Group location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Security Group",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Security Group belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this Security Group belongs to",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
        }
}</span>

func (r *SecurityGroupResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *SecurityGroupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SecurityGroupResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to create a security group",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.SecurityGroupRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
        }

        // Create the security group using the SDK
        response, err := r.client.Client.FromNetwork().SecurityGroups().Create(ctx, projectID, vpcID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating security group",
                        fmt.Sprintf("Unable to create security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create security group"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(response.Data.Metadata.LocationResponse.Value)
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Security group created but no data returned from API",
                )
                return
        }</span>

        // Wait for Security Group to be active before returning (SecurityGroup is referenced by CloudServer, SecurityRule)
        // This ensures Terraform doesn't proceed to create dependent resources until SecurityGroup is ready
        <span class="cov0" title="0">sgID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Security Group to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "SecurityGroup", sgID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Security Group Not Active",
                        fmt.Sprintf("Security group was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the Security Group to get the URI and ensure all fields are properly set
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(getResp.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(getResp.Data.Metadata.Tags))
                        for i, tag := range getResp.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Security Group after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Security Group resource", map[string]interface{}{
                "securitygroup_id":   data.Id.ValueString(),
                "securitygroup_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityGroupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SecurityGroupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        sgID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || sgID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Security Group ID are required to read the security group",
                )
                return
        }</span>

        // Get security group details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading security group",
                        fmt.Sprintf("Unable to read security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read security group"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                sg := response.Data

                if sg.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*sg.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if sg.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*sg.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if sg.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*sg.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if sg.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(sg.Metadata.LocationResponse.Value)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(sg.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(sg.Metadata.Tags))
                        for i, tag := range sg.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityGroupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SecurityGroupResourceModel
        var state SecurityGroupResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        sgID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || sgID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Security Group ID are required to update the security group",
                )
                return
        }</span>

        // Get current security group details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current security group",
                        fmt.Sprintf("Unable to get current security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Security Group Not Found",
                        "Security group not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Extract tags from Terraform list
        var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build the update request
        <span class="cov0" title="0">updateRequest := sdktypes.SecurityGroupRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
        }

        // Update the security group using the SDK
        response, err := r.client.Client.FromNetwork().SecurityGroups().Update(ctx, projectID, vpcID, sgID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating security group",
                        fmt.Sprintf("Unable to update security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update security group"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId
        data.Uri = state.Uri // Preserve URI from state

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If no URI in response, re-read the security group to get the latest state
                        getResp, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                                }</span> else<span class="cov0" title="0"> {
                                        data.Uri = state.Uri // Fallback to state if not available
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if re-read fails
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI from state
                data.Uri = state.Uri
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityGroupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SecurityGroupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        sgID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || sgID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Security Group ID are required to delete the security group",
                )
                return
        }</span>

        // Delete the security group using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().SecurityGroups().Delete(ctx, projectID, vpcID, sgID, nil)
                }</span>,
                ExtractSDKError,
                "SecurityGroup",
                sgID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting security group",
                        fmt.Sprintf("Unable to delete security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Security Group resource", map[string]interface{}{
                "securitygroup_id": sgID,
        })</span>
}

func (r *SecurityGroupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;SecurityRuleDataSource{}

func NewSecurityRuleDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;SecurityRuleDataSource{}
}</span>

type SecurityRuleDataSource struct {
        client *ArubaCloudClient
}

type SecurityRuleDataSourceModel struct {
        Id              types.String `tfsdk:"id"`
        Name            types.String `tfsdk:"name"`
        Location        types.String `tfsdk:"location"`
        ProjectId       types.String `tfsdk:"project_id"`
        VpcId           types.String `tfsdk:"vpc_id"`
        SecurityGroupId types.String `tfsdk:"security_group_id"`
        Properties      types.Object `tfsdk:"properties"`
}

func (d *SecurityRuleDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_securityrule"
}</span>

func (d *SecurityRuleDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Security Rule data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Security Rule identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Security Rule name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Security Rule location",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Security Rule belongs to",
                                Computed:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this Security Rule belongs to",
                                Computed:            true,
                        },
                        "security_group_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the Security Group this rule belongs to",
                                Computed:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                MarkdownDescription: "Properties of the security rule",
                                Computed:            true,
                                Attributes: map[string]schema.Attribute{
                                        "direction": schema.StringAttribute{
                                                MarkdownDescription: "Direction of the rule (Ingress/Egress)",
                                                Computed:            true,
                                        },
                                        "protocol": schema.StringAttribute{
                                                MarkdownDescription: "Protocol (ANY, TCP, UDP, ICMP)",
                                                Computed:            true,
                                        },
                                        "port": schema.StringAttribute{
                                                MarkdownDescription: "Port or port range (for TCP/UDP)",
                                                Computed:            true,
                                        },
                                        "target": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Target of the rule (source or destination)",
                                                Computed:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "kind": schema.StringAttribute{
                                                                MarkdownDescription: "Type of the target (Ip/SecurityGroup)",
                                                                Computed:            true,
                                                        },
                                                        "value": schema.StringAttribute{
                                                                MarkdownDescription: "Value of the target (CIDR or SecurityGroup URI)",
                                                                Computed:            true,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func (d *SecurityRuleDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *SecurityRuleDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data SecurityRuleDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response for all attributes
        <span class="cov0" title="0">data.Name = types.StringValue("example-securityrule")
        data.Location = types.StringValue("example-location")
        data.ProjectId = types.StringValue("example-project-id")
        data.VpcId = types.StringValue("example-vpc-id")
        data.SecurityGroupId = types.StringValue("example-security-group-id")

        // Build nested target object
        targetType := map[string]attr.Type{
                "kind":  types.StringType,
                "value": types.StringType,
        }
        targetValue := map[string]attr.Value{
                "kind":  types.StringValue("Ip"),
                "value": types.StringValue("192.168.1.1/32"),
        }
        targetObj, _ := types.ObjectValue(targetType, targetValue)

        // Build properties object
        propertiesType := map[string]attr.Type{
                "direction": types.StringType,
                "protocol":  types.StringType,
                "port":      types.StringType,
                "target":    types.ObjectType{AttrTypes: targetType},
        }
        propertiesValue := map[string]attr.Value{
                "direction": types.StringValue("Ingress"),
                "protocol":  types.StringValue("TCP"),
                "port":      types.StringValue("80"),
                "target":    targetObj,
        }
        propertiesObj, _ := types.ObjectValue(propertiesType, propertiesValue)
        data.Properties = propertiesObj

        tflog.Trace(ctx, "read a Security Rule data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// RuleDirection represents the direction of a security rule.
type RuleDirection string

const (
        RuleDirectionIngress RuleDirection = "Ingress"
        RuleDirectionEgress  RuleDirection = "Egress"
)

type SecurityRuleResource struct {
        client *ArubaCloudClient
}

// EndpointTypeDto represents the type of target endpoint
// ...existing code...
type EndpointTypeDto string

const (
        EndpointTypeIP EndpointTypeDto = "Ip"
)

// RuleTarget represents the target of the rule (source or destination according to the direction).
type RuleTarget struct {
        Kind  EndpointTypeDto `tfsdk:"kind"`
        Value string          `tfsdk:"value"`
}

// SecurityRuleProperties contains the properties of a security rule.
type SecurityRulePropertiesRequest struct {
        Direction RuleDirection `tfsdk:"direction"`
        Protocol  string        `tfsdk:"protocol"`
        Port      string        `tfsdk:"port"`
        Target    *RuleTarget   `tfsdk:"target"`
}

var _ resource.Resource = &amp;SecurityRuleResource{}
var _ resource.ResourceWithImportState = &amp;SecurityRuleResource{}

func NewSecurityRuleResource() resource.Resource <span class="cov0" title="0">{
        return &amp;SecurityRuleResource{}
}</span>

type SecurityRuleResourceModel struct {
        Id              types.String `tfsdk:"id"`
        Uri             types.String `tfsdk:"uri"`
        Name            types.String `tfsdk:"name"`
        Location        types.String `tfsdk:"location"`
        Tags            types.List   `tfsdk:"tags"`
        ProjectId       types.String `tfsdk:"project_id"`
        VpcId           types.String `tfsdk:"vpc_id"`
        SecurityGroupId types.String `tfsdk:"security_group_id"`
        Properties      types.Object `tfsdk:"properties"`
}

func (r *SecurityRuleResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_securityrule"
}</span>

func (r *SecurityRuleResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Security Rule resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Security Rule identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Security Rule URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Security Rule name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Security Rule location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Security Rule belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this Security Rule belongs to",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "security_group_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the Security Group this rule belongs to",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Security Rule",
                                Optional:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                MarkdownDescription: "Properties of the security rule",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "direction": schema.StringAttribute{
                                                MarkdownDescription: "Direction of the rule (Ingress/Egress)",
                                                Required:            true,
                                                // Validators removed for v1.16.1 compatibility
                                        },
                                        "protocol": schema.StringAttribute{
                                                MarkdownDescription: "Protocol (ANY, TCP, UDP, ICMP)",
                                                Required:            true,
                                                // Validators removed for v1.16.1 compatibility
                                        },
                                        "port": schema.StringAttribute{
                                                MarkdownDescription: "Port or port range (for TCP/UDP)",
                                                Optional:            true,
                                        },
                                        "target": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Target of the rule (source or destination)",
                                                Required:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "kind": schema.StringAttribute{
                                                                MarkdownDescription: "Type of the target (Ip/SecurityGroup)",
                                                                Required:            true,
                                                                // Validators removed for v1.16.1 compatibility
                                                        },
                                                        "value": schema.StringAttribute{
                                                                MarkdownDescription: "Value of the target (CIDR or SecurityGroup URI)",
                                                                Required:            true,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func (r *SecurityRuleResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *SecurityRuleResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SecurityRuleResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        securityGroupID := data.SecurityGroupId.ValueString()

        if projectID == "" || vpcID == "" || securityGroupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Security Group ID are required to create a security rule",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract properties from Terraform object
        <span class="cov0" title="0">propertiesObj, diags := data.Properties.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">propertiesAttrs := propertiesObj.Attributes()
        directionAttr, ok := propertiesAttrs["direction"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "direction must be a String")
                return
        }</span>
        <span class="cov0" title="0">direction := directionAttr.ValueString()

        protocolAttr, ok := propertiesAttrs["protocol"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "protocol must be a String")
                return
        }</span>
        <span class="cov0" title="0">protocol := protocolAttr.ValueString()

        port := ""
        if portAttr, ok := propertiesAttrs["port"]; ok &amp;&amp; portAttr != nil </span><span class="cov0" title="0">{
                if portStr, ok := portAttr.(types.String); ok &amp;&amp; !portStr.IsNull() </span><span class="cov0" title="0">{
                        port = portStr.ValueString()
                }</span>
        }

        // Extract target
        <span class="cov0" title="0">targetObjAttr, ok := propertiesAttrs["target"].(types.Object)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "target must be an Object")
                return
        }</span>
        <span class="cov0" title="0">targetObjValue, diags := targetObjAttr.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">targetAttrs := targetObjValue.Attributes()
        targetKindAttr, ok := targetAttrs["kind"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "target.kind must be a String")
                return
        }</span>
        <span class="cov0" title="0">targetKind := targetKindAttr.ValueString()

        targetValueAttr, ok := targetAttrs["value"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "target.value must be a String")
                return
        }</span>
        <span class="cov0" title="0">targetValue := targetValueAttr.ValueString()

        // Build the create request
        createRequest := sdktypes.SecurityRuleRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.SecurityRulePropertiesRequest{
                        Direction: sdktypes.RuleDirection(direction),
                        Protocol:  protocol,
                        Port:      port,
                        Target: &amp;sdktypes.RuleTarget{
                                Kind:  sdktypes.EndpointTypeDto(targetKind),
                                Value: targetValue,
                        },
                },
        }

        // Create the security rule using the SDK
        response, err := r.client.Client.FromNetwork().SecurityGroupRules().Create(ctx, projectID, vpcID, securityGroupID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating security rule",
                        fmt.Sprintf("Unable to create security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create security rule"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Security rule created but no data returned from API",
                )
                return
        }</span>

        // Wait for Security Rule to be active before returning
        // This ensures Terraform doesn't proceed to create dependent resources until Security Rule is ready
        <span class="cov0" title="0">ruleID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().SecurityGroupRules().Get(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Security Rule to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "SecurityRule", ruleID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Security Rule Not Active",
                        fmt.Sprintf("Security rule was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the Security Rule to get the latest state including tags
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().SecurityGroupRules().Get(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                rule := getResp.Data
                // Update tags from re-read response
                if len(rule.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(rule.Metadata.Tags))
                        for i, tag := range rule.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.Tags = types.ListNull(types.StringType)
                }</span>
        }

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Security Rule resource", map[string]interface{}{
                "securityrule_id":   data.Id.ValueString(),
                "securityrule_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityRuleResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SecurityRuleResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        securityGroupID := data.SecurityGroupId.ValueString()
        ruleID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || securityGroupID == "" || ruleID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, Security Group ID, and Rule ID are required to read the security rule",
                )
                return
        }</span>

        // Get security rule details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().SecurityGroupRules().Get(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading security rule",
                        fmt.Sprintf("Unable to read security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read security rule"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                rule := response.Data

                if rule.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*rule.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if rule.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*rule.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if rule.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*rule.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if rule.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(rule.Metadata.LocationResponse.Value)
                }</span>

                // Update properties from response
                <span class="cov0" title="0">propertiesMap := map[string]attr.Value{
                        "direction": types.StringValue(string(rule.Properties.Direction)),
                        "protocol":  types.StringValue(rule.Properties.Protocol),
                        "port":      types.StringValue(rule.Properties.Port),
                }

                // Update target
                if rule.Properties.Target != nil </span><span class="cov0" title="0">{
                        targetMap := map[string]attr.Value{
                                "kind":  types.StringValue(string(rule.Properties.Target.Kind)),
                                "value": types.StringValue(rule.Properties.Target.Value),
                        }
                        targetObj, diags := types.ObjectValue(map[string]attr.Type{
                                "kind":  types.StringType,
                                "value": types.StringType,
                        }, targetMap)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                propertiesMap["target"] = targetObj
                        }</span>
                }

                <span class="cov0" title="0">propertiesObj, diags := types.ObjectValue(map[string]attr.Type{
                        "direction": types.StringType,
                        "protocol":  types.StringType,
                        "port":      types.StringType,
                        "target": types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "kind":  types.StringType,
                                        "value": types.StringType,
                                },
                        },
                }, propertiesMap)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Properties = propertiesObj
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(rule.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(rule.Metadata.Tags))
                        for i, tag := range rule.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        // API has no tags - set to null
                        data.Tags = types.ListNull(types.StringType)
                }</span>

        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityRuleResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SecurityRuleResourceModel
        var state SecurityRuleResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Use IDs from state (they are immutable)
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        securityGroupID := state.SecurityGroupId.ValueString()
        ruleID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || securityGroupID == "" || ruleID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, Security Group ID, and Rule ID are required to update the security rule",
                )
                return
        }</span>

        // Get current security rule details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().SecurityGroupRules().Get(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current security rule",
                        fmt.Sprintf("Unable to get current security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Security Rule Not Found",
                        "Security rule not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if security rule is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update Security Rule",
                        "Cannot update security rule while it is in 'InCreation' state. Please wait until the security rule is fully created.",
                )
                return
        }</span>

        // Check if properties have changed - if so, security rule must be recreated
        // Extract properties from plan using the same method as Create
        <span class="cov0" title="0">var planDirection, planProtocol, planPort, planTargetKind, planTargetValue string
        if !data.Properties.IsNull() &amp;&amp; !data.Properties.IsUnknown() </span><span class="cov0" title="0">{
                propertiesObj, diags := data.Properties.ToObjectValue(ctx)
                if !diags.HasError() </span><span class="cov0" title="0">{
                        propertiesAttrs := propertiesObj.Attributes()
                        if dir, ok := propertiesAttrs["direction"]; ok &amp;&amp; dir != nil </span><span class="cov0" title="0">{
                                if dirStr, ok := dir.(types.String); ok </span><span class="cov0" title="0">{
                                        planDirection = dirStr.ValueString()
                                }</span>
                        }
                        <span class="cov0" title="0">if prot, ok := propertiesAttrs["protocol"]; ok &amp;&amp; prot != nil </span><span class="cov0" title="0">{
                                if protStr, ok := prot.(types.String); ok </span><span class="cov0" title="0">{
                                        planProtocol = protStr.ValueString()
                                }</span>
                        }
                        <span class="cov0" title="0">if portAttr, ok := propertiesAttrs["port"]; ok &amp;&amp; portAttr != nil </span><span class="cov0" title="0">{
                                if portStr, ok := portAttr.(types.String); ok &amp;&amp; !portStr.IsNull() </span><span class="cov0" title="0">{
                                        planPort = portStr.ValueString()
                                }</span>
                        }
                        <span class="cov0" title="0">if targetAttr, ok := propertiesAttrs["target"]; ok &amp;&amp; targetAttr != nil </span><span class="cov0" title="0">{
                                if targetObj, ok := targetAttr.(types.Object); ok </span><span class="cov0" title="0">{
                                        targetObjValue, targetDiags := targetObj.ToObjectValue(ctx)
                                        if !targetDiags.HasError() </span><span class="cov0" title="0">{
                                                targetAttrs := targetObjValue.Attributes()
                                                if kind, ok := targetAttrs["kind"]; ok &amp;&amp; kind != nil </span><span class="cov0" title="0">{
                                                        if kindStr, ok := kind.(types.String); ok </span><span class="cov0" title="0">{
                                                                planTargetKind = kindStr.ValueString()
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">if value, ok := targetAttrs["value"]; ok &amp;&amp; value != nil </span><span class="cov0" title="0">{
                                                        if valueStr, ok := value.(types.String); ok </span><span class="cov0" title="0">{
                                                                planTargetValue = valueStr.ValueString()
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Compare with current properties
        <span class="cov0" title="0">var propertiesChanged bool
        if planDirection != "" &amp;&amp; string(current.Properties.Direction) != planDirection </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>
        <span class="cov0" title="0">if planProtocol != "" &amp;&amp; current.Properties.Protocol != planProtocol </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>
        <span class="cov0" title="0">currentPort := current.Properties.Port
        if planPort != "" &amp;&amp; currentPort != planPort </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>
        <span class="cov0" title="0">if planTargetKind != "" &amp;&amp; string(current.Properties.Target.Kind) != planTargetKind </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>
        <span class="cov0" title="0">if planTargetValue != "" &amp;&amp; current.Properties.Target.Value != planTargetValue </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>

        <span class="cov0" title="0">if propertiesChanged </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update Security Rule Properties",
                        "Security rule properties (direction, protocol, port, target) cannot be updated. To change properties, delete and recreate the security rule.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                // Try to get from VPC
                vpcResp, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
                if err == nil &amp;&amp; vpcResp != nil &amp;&amp; !vpcResp.IsError() &amp;&amp; vpcResp.Data != nil </span><span class="cov0" title="0">{
                        if vpcResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                                regionValue = vpcResp.Data.Metadata.LocationResponse.Value
                        }</span>
                }
        }
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for security rule",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated, properties must remain unchanged
        // Note: Properties must be included in the request but will use current values (they cannot be changed)
        <span class="cov0" title="0">updateRequest := sdktypes.SecurityRuleRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.SecurityRulePropertiesRequest{
                        // Properties cannot be updated - use current values from API response
                        Direction: current.Properties.Direction,
                        Protocol:  current.Properties.Protocol,
                        Port:      current.Properties.Port,
                        Target:    current.Properties.Target,
                },
        }

        // Log the update request for debugging
        tflog.Debug(ctx, "Updating security rule", map[string]interface{}{
                "rule_id":    ruleID,
                "name":       data.Name.ValueString(),
                "tags":       tags,
                "properties": fmt.Sprintf("Direction=%s, Protocol=%s, Port=%s", current.Properties.Direction, current.Properties.Protocol, current.Properties.Port),
        })

        // Update the security rule using the SDK
        response, err := r.client.Client.FromNetwork().SecurityGroupRules().Update(ctx, projectID, vpcID, securityGroupID, ruleID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, fmt.Sprintf("Error calling Update API: %v", err))
                resp.Diagnostics.AddError(
                        "Error updating security rule",
                        fmt.Sprintf("Unable to update security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update security rule"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                // Include status code if available
                <span class="cov0" title="0">if response.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s (HTTP %d)", errorMsg, response.StatusCode)
                }</span>
                <span class="cov0" title="0">tflog.Error(ctx, fmt.Sprintf("API returned error: %+v", response.Error))
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Verify the update was successful
        <span class="cov0" title="0">if response == nil || response.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Security rule updated but no data returned from API",
                )
                return
        }</span>

        // Update the state with the response data
        // At this point, we know response != nil &amp;&amp; response.Data != nil from the check above
        <span class="cov0" title="0">updated := response.Data
        if updated.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*updated.Metadata.ID)
        }</span>
        <span class="cov0" title="0">if updated.Metadata.Name != nil </span><span class="cov0" title="0">{
                data.Name = types.StringValue(*updated.Metadata.Name)
        }</span>
        <span class="cov0" title="0">if updated.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                data.Location = types.StringValue(updated.Metadata.LocationResponse.Value)
        }</span>

        // Update tags from response
        <span class="cov0" title="0">if len(updated.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagValues := make([]types.String, len(updated.Metadata.Tags))
                for i, tag := range updated.Metadata.Tags </span><span class="cov0" title="0">{
                        tagValues[i] = types.StringValue(tag)
                }</span>
                <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Tags = tagsList
                }</span>
        } else<span class="cov0" title="0"> {
                data.Tags = types.ListNull(types.StringType)
        }</span>

        // Properties remain unchanged - they are immutable
        // Keep the existing state values to ensure Terraform state matches what the user configured

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId
        data.SecurityGroupId = state.SecurityGroupId

        // Update ID from response (should match state)
        // At this point, we know response != nil &amp;&amp; response.Data != nil from the check above
        if updated.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*updated.Metadata.ID)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityRuleResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SecurityRuleResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        securityGroupID := data.SecurityGroupId.ValueString()
        ruleID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || securityGroupID == "" || ruleID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, Security Group ID, and Rule ID are required to delete the security rule",
                )
                return
        }</span>

        // Delete the security rule using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().SecurityGroupRules().Delete(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
                }</span>,
                ExtractSDKError,
                "SecurityRule",
                ruleID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting security rule",
                        fmt.Sprintf("Unable to delete security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Security Rule resource", map[string]interface{}{
                "securityrule_id": ruleID,
        })</span>
}

func (r *SecurityRuleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;SnapshotDataSource{}

func NewSnapshotDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;SnapshotDataSource{}
}</span>

type SnapshotDataSource struct {
        client *ArubaCloudClient
}

type SnapshotDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        CreatedAt   types.String `tfsdk:"created_at"`
}

func (d *SnapshotDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_snapshot"
}</span>

func (d *SnapshotDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Snapshot data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Snapshot identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Snapshot name",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Snapshot belongs to",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Snapshot location",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (only 'Hour' allowed)",
                                Computed:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the volume this snapshot is for",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *SnapshotDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *SnapshotDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data SnapshotDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-snapshot")
        data.Description = types.StringValue("Simulated snapshot description")
        data.CreatedAt = types.StringValue("2025-11-25T00:00:00Z")
        tflog.Trace(ctx, "read a Snapshot data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;SnapshotResource{}
var _ resource.ResourceWithImportState = &amp;SnapshotResource{}

func NewSnapshotResource() resource.Resource <span class="cov0" title="0">{
        return &amp;SnapshotResource{}
}</span>

type SnapshotResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        ProjectId     types.String `tfsdk:"project_id"`
        Location      types.String `tfsdk:"location"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        VolumeUri     types.String `tfsdk:"volume_uri"`
        Tags          types.List   `tfsdk:"tags"`
}

type SnapshotResource struct {
        client *ArubaCloudClient
}

func (r *SnapshotResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_snapshot"
}</span>

func (r *SnapshotResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Snapshot resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Snapshot identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Snapshot URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Snapshot name",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Snapshot belongs to",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Snapshot location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (only 'Hour' allowed)",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "volume_uri": schema.StringAttribute{
                                MarkdownDescription: "URI of the volume this snapshot is for. Should be the volume URI (e.g., `/projects/{project_id}/providers/Aruba.Storage/volumes/{volume_id}`). You can reference the `uri` attribute from an `arubacloud_blockstorage` resource.",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the snapshot",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *SnapshotResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *SnapshotResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SnapshotResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a snapshot",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Get volume URI from the plan
        <span class="cov0" title="0">volumeURI := data.VolumeUri.ValueString()
        if volumeURI == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Volume URI",
                        "Volume URI is required to create a snapshot",
                )
                return
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.SnapshotRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.SnapshotPropertiesRequest{
                        Volume: sdktypes.ReferenceResource{
                                URI: volumeURI,
                        },
                },
        }

        // Create the snapshot using the SDK
        response, err := r.client.Client.FromStorage().Snapshots().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating snapshot",
                        fmt.Sprintf("Unable to create snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create snapshot"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span> else<span class="cov0" title="0"> {
                        resp.Diagnostics.AddError(
                                "Invalid API Response",
                                "Snapshot created but ID not returned from API",
                        )
                        return
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Snapshot created but no data returned from API",
                )
                return
        }</span>

        // Wait for Snapshot to be active before returning (Snapshot references Volume)
        // This ensures Terraform doesn't proceed to create dependent resources until Snapshot is ready
        <span class="cov0" title="0">snapshotID := data.Id.ValueString()
        if snapshotID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Snapshot ID",
                        "Snapshot ID is required but was not set",
                )
                return
        }</span>
        <span class="cov0" title="0">checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Snapshots().Get(ctx, projectID, snapshotID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Snapshot to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Snapshot", snapshotID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Snapshot Not Active",
                        fmt.Sprintf("Snapshot was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Read the Snapshot again to ensure ID and other fields are properly set from metadata
        <span class="cov0" title="0">getResp, err := r.client.Client.FromStorage().Snapshots().Get(ctx, projectID, snapshotID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(getResp.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(getResp.Data.Metadata.Tags))
                        for i, tag := range getResp.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Snapshot after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Snapshot resource", map[string]interface{}{
                "snapshot_id":   data.Id.ValueString(),
                "snapshot_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SnapshotResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SnapshotResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        snapshotID := data.Id.ValueString()

        // If ID is unknown or null, check if this is a new resource (no state) or existing resource (state exists but ID missing)
        // For new resources (during plan), we can return early
        // For existing resources, we need the ID to read - if it's missing, that's an error
        if data.Id.IsUnknown() || data.Id.IsNull() || snapshotID == "" </span><span class="cov0" title="0">{
                // Check if we have any other state data that indicates this is an existing resource
                // If name is set in state, this is likely an existing resource with missing ID (error case)
                if !data.Name.IsUnknown() &amp;&amp; !data.Name.IsNull() &amp;&amp; data.Name.ValueString() != "" </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Snapshot exists in state but ID is missing - this indicates a state corruption issue")
                        resp.Diagnostics.AddError(
                                "Missing Snapshot ID",
                                "Snapshot ID is required to read the snapshot. The resource exists in state but the ID is missing. This may indicate a state corruption issue. Try running 'terraform refresh' or 'terraform import arubacloud_snapshot.test &lt;snapshot_id&gt;'.",
                        )
                        return
                }</span>
                // Otherwise, this is likely a new resource during plan - return early
                <span class="cov0" title="0">tflog.Info(ctx, "Snapshot ID is unknown or null during read, skipping API call (likely new resource).")
                return</span> // Do not error, as this is expected during plan for new resources
        }

        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                // Check if ProjectID is unknown (new resource) vs missing (error)
                if data.ProjectId.IsUnknown() || data.ProjectId.IsNull() </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Snapshot Project ID is unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to read the snapshot",
                )
                return</span>
        }

        // Get snapshot details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Snapshots().Get(ctx, projectID, snapshotID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading snapshot",
                        fmt.Sprintf("Unable to read snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read snapshot"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                snapshot := response.Data

                // Preserve immutable fields from state (they're not returned by API)
                projectIdFromState := data.ProjectId
                billingPeriodFromState := data.BillingPeriod
                volumeUriFromState := data.VolumeUri
                tagsFromState := data.Tags
                locationFromState := data.Location

                if snapshot.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*snapshot.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if snapshot.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*snapshot.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if snapshot.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*snapshot.Metadata.Name)
                }</span>
                // Location is immutable - always preserve from state
                // This prevents false changes when the referenced block storage is updated
                <span class="cov0" title="0">if !locationFromState.IsUnknown() &amp;&amp; !locationFromState.IsNull() </span><span class="cov0" title="0">{
                        data.Location = locationFromState
                }</span> else<span class="cov0" title="0"> {
                        // Only use API value if state doesn't have it (new resources during plan)
                        if snapshot.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                                data.Location = types.StringValue(snapshot.Metadata.LocationResponse.Value)
                        }</span>
                }

                // Handle volume_uri: Always preserve from state since it's immutable
                // The volume_uri never changes after snapshot creation, so we should always use the value from state
                // This prevents false changes when the referenced block storage is updated
                <span class="cov0" title="0">if !volumeUriFromState.IsUnknown() &amp;&amp; !volumeUriFromState.IsNull() </span><span class="cov0" title="0">{
                        // Always preserve volume_uri from state (it's immutable)
                        data.VolumeUri = volumeUriFromState
                }</span> else<span class="cov0" title="0"> {
                        // Only use API value if state doesn't have it (shouldn't happen for existing resources)
                        if snapshot.Properties.Volume.URI != nil &amp;&amp; *snapshot.Properties.Volume.URI != "" </span><span class="cov0" title="0">{
                                data.VolumeUri = types.StringValue(*snapshot.Properties.Volume.URI)
                        }</span>
                }

                // Update tags from response
                // If tags are null/unknown in state, preserve null (user didn't specify tags)
                // If tags exist in state or API has tags, update from API
                <span class="cov0" title="0">if len(snapshot.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(snapshot.Metadata.Tags))
                        for i, tag := range snapshot.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        // API has no tags - preserve from state if null/unknown, otherwise set to empty list
                        if tagsFromState.IsNull() || tagsFromState.IsUnknown() </span><span class="cov0" title="0">{
                                data.Tags = tagsFromState // Preserve null/unknown from state
                        }</span> else<span class="cov0" title="0"> {
                                // State has tags (even if empty), update to empty list to match API
                                emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        data.Tags = emptyList
                                }</span>
                        }
                }

                // Restore immutable fields from state (they're not returned by API)
                <span class="cov0" title="0">data.ProjectId = projectIdFromState
                data.BillingPeriod = billingPeriodFromState</span>
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SnapshotResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SnapshotResourceModel
        var state SnapshotResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        snapshotID := state.Id.ValueString()

        if projectID == "" || snapshotID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Snapshot ID are required to update the snapshot",
                )
                return
        }</span>

        // Get current snapshot details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromStorage().Snapshots().Get(ctx, projectID, snapshotID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current snapshot",
                        fmt.Sprintf("Unable to get current snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Snapshot Not Found",
                        "Snapshot not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for snapshot",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Preserve existing tags if not provided
                tags = current.Metadata.Tags
        }</span>

        // Build the update request
        <span class="cov0" title="0">updateRequest := sdktypes.SnapshotRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.SnapshotPropertiesRequest{
                        // Volume cannot be updated - preserve from create request or state
                        // Note: VolumeInfo may need to be converted to ReferenceResource
                        // For now, Volume is read-only in updates
                },
        }

        // Update the snapshot using the SDK
        response, err := r.client.Client.FromStorage().Snapshots().Update(ctx, projectID, snapshotID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating snapshot",
                        fmt.Sprintf("Unable to update snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update snapshot"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VolumeUri = state.VolumeUri // Preserve volume_uri from state (it's immutable)

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = state.Uri
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(response.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(response.Data.Metadata.Tags))
                        for i, tag := range response.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI and tags from state
                data.Uri = state.Uri
                data.Tags = state.Tags
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SnapshotResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SnapshotResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        snapshotID := data.Id.ValueString()

        if projectID == "" || snapshotID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Snapshot ID are required to delete the snapshot",
                )
                return
        }</span>

        // Delete the snapshot using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromStorage().Snapshots().Delete(ctx, projectID, snapshotID, nil)
                }</span>,
                ExtractSDKError,
                "Snapshot",
                snapshotID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting snapshot",
                        fmt.Sprintf("Unable to delete snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Snapshot resource", map[string]interface{}{
                "snapshot_id": snapshotID,
        })</span>
}

func (r *SnapshotResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;SubnetDataSource{}

func NewSubnetDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;SubnetDataSource{}
}</span>

type SubnetDataSource struct {
        client *ArubaCloudClient
}

type SubnetDataSourceModel struct {
        Id        types.String `tfsdk:"id"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
        Type      types.String `tfsdk:"type"`
        Network   types.Object `tfsdk:"network"`
        Dhcp      types.Object `tfsdk:"dhcp"`
        Routes    types.List   `tfsdk:"routes"`
        Dns       types.List   `tfsdk:"dns"`
}

func (d *SubnetDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_subnet"
}</span>

func (d *SubnetDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Subnet data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Subnet identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Subnet name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Subnet location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the subnet",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this subnet belongs to",
                                Computed:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this subnet belongs to",
                                Computed:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Subnet type (Basic or Advanced)",
                                Computed:            true,
                        },
                        "network": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "address": schema.StringAttribute{
                                                MarkdownDescription: "Address of the network in CIDR notation (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)",
                                                Computed:            true,
                                        },
                                },
                                Computed: true,
                        },
                        "dhcp": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "enabled": schema.BoolAttribute{
                                                MarkdownDescription: "Enable DHCP",
                                                Computed:            true,
                                        },
                                        "range": schema.SingleNestedAttribute{
                                                Attributes: map[string]schema.Attribute{
                                                        "start": schema.StringAttribute{
                                                                MarkdownDescription: "Starting IP address",
                                                                Computed:            true,
                                                        },
                                                        "count": schema.Int64Attribute{
                                                                MarkdownDescription: "Number of available IP addresses",
                                                                Computed:            true,
                                                        },
                                                },
                                                Computed: true,
                                        },
                                },
                                Computed: true,
                        },
                        "routes": schema.ListNestedAttribute{
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "address": schema.StringAttribute{
                                                        MarkdownDescription: "IP address of the route",
                                                        Computed:            true,
                                                },
                                                "gateway": schema.StringAttribute{
                                                        MarkdownDescription: "Gateway",
                                                        Computed:            true,
                                                },
                                        },
                                },
                                Computed: true,
                        },
                        "dns": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of DNS IP addresses",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *SubnetDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *SubnetDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data SubnetDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-subnet")
        tflog.Trace(ctx, "read a Subnet data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;SubnetResource{}
var _ resource.ResourceWithImportState = &amp;SubnetResource{}

func NewSubnetResource() resource.Resource <span class="cov0" title="0">{
        return &amp;SubnetResource{}
}</span>

type SubnetResource struct {
        client *ArubaCloudClient
}

type SubnetResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
        Type      types.String `tfsdk:"type"`
        Network   types.Object `tfsdk:"network"`
        Dhcp      types.Object `tfsdk:"dhcp"`
}

type NetworkModel struct {
        Address types.String `tfsdk:"address"`
}

type DhcpModel struct {
        Enabled types.Bool   `tfsdk:"enabled"`
        Range   types.Object `tfsdk:"range"`
        Routes  types.List   `tfsdk:"routes"`
        Dns     types.List   `tfsdk:"dns"`
}

type DhcpRangeModel struct {
        Start types.String `tfsdk:"start"`
        Count types.Int64  `tfsdk:"count"`
}

type RouteModel struct {
        Address types.String `tfsdk:"address"`
        Gateway types.String `tfsdk:"gateway"`
}

func (r *SubnetResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_subnet"
}</span>

func (r *SubnetResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Subnet resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Subnet identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Subnet URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Subnet name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Subnet location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the subnet",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this subnet belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this subnet belongs to",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Subnet type (Basic or Advanced)",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "network": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "address": schema.StringAttribute{
                                                MarkdownDescription: "Address of the network in CIDR notation (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)",
                                                Optional:            true,
                                        },
                                },
                                Optional: true,
                        },
                        "dhcp": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "enabled": schema.BoolAttribute{
                                                MarkdownDescription: "Enable DHCP",
                                                Optional:            true,
                                        },
                                        "range": schema.SingleNestedAttribute{
                                                Attributes: map[string]schema.Attribute{
                                                        "start": schema.StringAttribute{
                                                                MarkdownDescription: "Starting IP address",
                                                                Optional:            true,
                                                        },
                                                        "count": schema.Int64Attribute{
                                                                MarkdownDescription: "Number of available IP addresses",
                                                                Optional:            true,
                                                        },
                                                },
                                                Optional: true,
                                        },
                                        "routes": schema.ListNestedAttribute{
                                                NestedObject: schema.NestedAttributeObject{
                                                        Attributes: map[string]schema.Attribute{
                                                                "address": schema.StringAttribute{
                                                                        MarkdownDescription: "Destination network address in CIDR notation (e.g., 0.0.0.0/0)",
                                                                        Optional:            true,
                                                                },
                                                                "gateway": schema.StringAttribute{
                                                                        MarkdownDescription: "Gateway IP address for the route",
                                                                        Optional:            true,
                                                                },
                                                        },
                                                },
                                                MarkdownDescription: "DHCP routes configuration",
                                                Optional:            true,
                                        },
                                        "dns": schema.ListAttribute{
                                                ElementType:         types.StringType,
                                                MarkdownDescription: "DNS server addresses",
                                                Optional:            true,
                                        },
                                },
                                Optional: true,
                        },
                },
        }
}</span>

func (r *SubnetResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *SubnetResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SubnetResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to create a subnet",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract network CIDR if provided
        <span class="cov0" title="0">var network *sdktypes.SubnetNetwork
        if !data.Network.IsNull() &amp;&amp; !data.Network.IsUnknown() </span><span class="cov0" title="0">{
                networkObj, diags := data.Network.ToObjectValue(ctx)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        attrs := networkObj.Attributes()
                        if addressAttr, ok := attrs["address"]; ok &amp;&amp; addressAttr != nil </span><span class="cov0" title="0">{
                                if addressStr, ok := addressAttr.(types.String); ok &amp;&amp; !addressStr.IsNull() </span><span class="cov0" title="0">{
                                        addressValue := addressStr.ValueString()
                                        if addressValue != "" </span><span class="cov0" title="0">{
                                                network = &amp;sdktypes.SubnetNetwork{
                                                        Address: addressValue,
                                                }
                                        }</span>
                                }
                        }
                }
        }

        // Determine SubnetType: Advanced if CIDR is provided, Basic otherwise
        <span class="cov0" title="0">subnetType := sdktypes.SubnetTypeBasic
        if network != nil &amp;&amp; network.Address != "" </span><span class="cov0" title="0">{
                subnetType = sdktypes.SubnetTypeAdvanced
        }</span> else<span class="cov0" title="0"> if data.Type.ValueString() == "Advanced" </span><span class="cov0" title="0">{
                subnetType = sdktypes.SubnetTypeAdvanced
        }</span>

        // Extract DHCP configuration if provided
        <span class="cov0" title="0">var dhcp *sdktypes.SubnetDHCP
        if !data.Dhcp.IsNull() &amp;&amp; !data.Dhcp.IsUnknown() </span><span class="cov0" title="0">{
                dhcpObj, diags := data.Dhcp.ToObjectValue(ctx)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        attrs := dhcpObj.Attributes()
                        dhcp = &amp;sdktypes.SubnetDHCP{}

                        // Extract enabled
                        if enabledAttr, ok := attrs["enabled"]; ok &amp;&amp; enabledAttr != nil </span><span class="cov0" title="0">{
                                if enabledBool, ok := enabledAttr.(types.Bool); ok &amp;&amp; !enabledBool.IsNull() </span><span class="cov0" title="0">{
                                        dhcp.Enabled = enabledBool.ValueBool()
                                }</span>
                        }

                        // Extract range
                        <span class="cov0" title="0">if rangeAttr, ok := attrs["range"]; ok &amp;&amp; rangeAttr != nil </span><span class="cov0" title="0">{
                                if rangeObj, ok := rangeAttr.(types.Object); ok &amp;&amp; !rangeObj.IsNull() </span><span class="cov0" title="0">{
                                        rangeAttrs := rangeObj.Attributes()
                                        dhcpRange := &amp;sdktypes.SubnetDHCPRange{}
                                        if startAttr, ok := rangeAttrs["start"]; ok &amp;&amp; startAttr != nil </span><span class="cov0" title="0">{
                                                if startStr, ok := startAttr.(types.String); ok &amp;&amp; !startStr.IsNull() </span><span class="cov0" title="0">{
                                                        dhcpRange.Start = startStr.ValueString()
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if countAttr, ok := rangeAttrs["count"]; ok &amp;&amp; countAttr != nil </span><span class="cov0" title="0">{
                                                if countInt, ok := countAttr.(types.Int64); ok &amp;&amp; !countInt.IsNull() </span><span class="cov0" title="0">{
                                                        dhcpRange.Count = int(countInt.ValueInt64())
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if dhcpRange.Start != "" || dhcpRange.Count &gt; 0 </span><span class="cov0" title="0">{
                                                dhcp.Range = dhcpRange
                                        }</span>
                                }
                        }

                        // Extract routes
                        <span class="cov0" title="0">if routesAttr, ok := attrs["routes"]; ok &amp;&amp; routesAttr != nil </span><span class="cov0" title="0">{
                                if routesList, ok := routesAttr.(types.List); ok &amp;&amp; !routesList.IsNull() </span><span class="cov0" title="0">{
                                        var routesData []types.Object
                                        diags := routesList.ElementsAs(ctx, &amp;routesData, false)
                                        resp.Diagnostics.Append(diags...)
                                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                dhcpRoutes := make([]sdktypes.SubnetDHCPRoute, 0, len(routesData))
                                                for _, routeObj := range routesData </span><span class="cov0" title="0">{
                                                        routeAttrs := routeObj.Attributes()
                                                        route := sdktypes.SubnetDHCPRoute{}
                                                        if addrAttr, ok := routeAttrs["address"]; ok &amp;&amp; addrAttr != nil </span><span class="cov0" title="0">{
                                                                if addrStr, ok := addrAttr.(types.String); ok &amp;&amp; !addrStr.IsNull() </span><span class="cov0" title="0">{
                                                                        route.Address = addrStr.ValueString()
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if gwAttr, ok := routeAttrs["gateway"]; ok &amp;&amp; gwAttr != nil </span><span class="cov0" title="0">{
                                                                if gwStr, ok := gwAttr.(types.String); ok &amp;&amp; !gwStr.IsNull() </span><span class="cov0" title="0">{
                                                                        route.Gateway = gwStr.ValueString()
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if route.Address != "" || route.Gateway != "" </span><span class="cov0" title="0">{
                                                                dhcpRoutes = append(dhcpRoutes, route)
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">if len(dhcpRoutes) &gt; 0 </span><span class="cov0" title="0">{
                                                        dhcp.Routes = dhcpRoutes
                                                }</span>
                                        }
                                }
                        }

                        // Extract DNS
                        <span class="cov0" title="0">if dnsAttr, ok := attrs["dns"]; ok &amp;&amp; dnsAttr != nil </span><span class="cov0" title="0">{
                                if dnsList, ok := dnsAttr.(types.List); ok &amp;&amp; !dnsList.IsNull() </span><span class="cov0" title="0">{
                                        var dnsServers []string
                                        diags := dnsList.ElementsAs(ctx, &amp;dnsServers, false)
                                        resp.Diagnostics.Append(diags...)
                                        if !resp.Diagnostics.HasError() &amp;&amp; len(dnsServers) &gt; 0 </span><span class="cov0" title="0">{
                                                dhcp.DNS = dnsServers
                                        }</span>
                                }
                        }
                }
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.SubnetRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.SubnetPropertiesRequest{
                        Type:    subnetType,
                        Network: network,
                        DHCP:    dhcp,
                },
        }

        // Create the subnet using the SDK
        response, err := r.client.Client.FromNetwork().Subnets().Create(ctx, projectID, vpcID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating subnet",
                        fmt.Sprintf("Unable to create subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create subnet"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Subnet created but no data returned from API",
                )
                return
        }</span>

        // Wait for Subnet to be active before returning (Subnet is referenced by CloudServer)
        // This ensures Terraform doesn't proceed to create dependent resources until Subnet is ready
        <span class="cov0" title="0">subnetID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Subnet to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Subnet", subnetID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Subnet Not Active",
                        fmt.Sprintf("Subnet was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the Subnet to get the URI and ensure all fields are properly set
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(getResp.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(getResp.Data.Metadata.Tags))
                        for i, tag := range getResp.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Subnet after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Subnet resource", map[string]interface{}{
                "subnet_id":   data.Id.ValueString(),
                "subnet_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SubnetResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SubnetResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        subnetID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || subnetID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Subnet ID are required to read the subnet",
                )
                return
        }</span>

        // Get subnet details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading subnet",
                        fmt.Sprintf("Unable to read subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read subnet"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                subnet := response.Data

                if subnet.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*subnet.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if subnet.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*subnet.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if subnet.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*subnet.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if subnet.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(subnet.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">data.Type = types.StringValue(string(subnet.Properties.Type))

                // Update network if available
                if subnet.Properties.Network != nil &amp;&amp; subnet.Properties.Network.Address != "" </span><span class="cov0" title="0">{
                        networkModel := NetworkModel{
                                Address: types.StringValue(subnet.Properties.Network.Address),
                        }
                        networkObj, diags := types.ObjectValue(map[string]attr.Type{
                                "address": types.StringType,
                        }, map[string]attr.Value{
                                "address": networkModel.Address,
                        })
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Network = networkObj
                        }</span>
                }

                // Update DHCP if available
                <span class="cov0" title="0">if subnet.Properties.DHCP != nil </span><span class="cov0" title="0">{
                        dhcpAttrs := make(map[string]attr.Value)
                        dhcpAttrs["enabled"] = types.BoolValue(subnet.Properties.DHCP.Enabled)

                        // Handle DHCP range
                        if subnet.Properties.DHCP.Range != nil </span><span class="cov0" title="0">{
                                rangeObj, diags := types.ObjectValue(map[string]attr.Type{
                                        "start": types.StringType,
                                        "count": types.Int64Type,
                                }, map[string]attr.Value{
                                        "start": types.StringValue(subnet.Properties.DHCP.Range.Start),
                                        "count": types.Int64Value(int64(subnet.Properties.DHCP.Range.Count)),
                                })
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        dhcpAttrs["range"] = rangeObj
                                }</span>
                        } else<span class="cov0" title="0"> {
                                dhcpAttrs["range"] = types.ObjectNull(map[string]attr.Type{
                                        "start": types.StringType,
                                        "count": types.Int64Type,
                                })
                        }</span>

                        // Handle DHCP routes
                        <span class="cov0" title="0">if len(subnet.Properties.DHCP.Routes) &gt; 0 </span><span class="cov0" title="0">{
                                routeObjs := make([]attr.Value, 0, len(subnet.Properties.DHCP.Routes))
                                for _, route := range subnet.Properties.DHCP.Routes </span><span class="cov0" title="0">{
                                        routeObj, diags := types.ObjectValue(map[string]attr.Type{
                                                "address": types.StringType,
                                                "gateway": types.StringType,
                                        }, map[string]attr.Value{
                                                "address": types.StringValue(route.Address),
                                                "gateway": types.StringValue(route.Gateway),
                                        })
                                        resp.Diagnostics.Append(diags...)
                                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                routeObjs = append(routeObjs, routeObj)
                                        }</span>
                                }
                                <span class="cov0" title="0">routesList, diags := types.ListValue(types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "address": types.StringType,
                                                "gateway": types.StringType,
                                        },
                                }, routeObjs)
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        dhcpAttrs["routes"] = routesList
                                }</span>
                        } else<span class="cov0" title="0"> {
                                dhcpAttrs["routes"] = types.ListNull(types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "address": types.StringType,
                                                "gateway": types.StringType,
                                        },
                                })
                        }</span>

                        // Handle DNS
                        <span class="cov0" title="0">if len(subnet.Properties.DHCP.DNS) &gt; 0 </span><span class="cov0" title="0">{
                                dnsValues := make([]attr.Value, 0, len(subnet.Properties.DHCP.DNS))
                                for _, dns := range subnet.Properties.DHCP.DNS </span><span class="cov0" title="0">{
                                        dnsValues = append(dnsValues, types.StringValue(dns))
                                }</span>
                                <span class="cov0" title="0">dnsList, diags := types.ListValue(types.StringType, dnsValues)
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        dhcpAttrs["dns"] = dnsList
                                }</span>
                        } else<span class="cov0" title="0"> {
                                dhcpAttrs["dns"] = types.ListNull(types.StringType)
                        }</span>

                        <span class="cov0" title="0">dhcpObj, diags := types.ObjectValue(map[string]attr.Type{
                                "enabled": types.BoolType,
                                "range": types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "start": types.StringType,
                                                "count": types.Int64Type,
                                        },
                                },
                                "routes": types.ListType{
                                        ElemType: types.ObjectType{
                                                AttrTypes: map[string]attr.Type{
                                                        "address": types.StringType,
                                                        "gateway": types.StringType,
                                                },
                                        },
                                },
                                "dns": types.ListType{ElemType: types.StringType},
                        }, dhcpAttrs)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Dhcp = dhcpObj
                        }</span>
                }

                // Update tags from response
                <span class="cov0" title="0">if len(subnet.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(subnet.Metadata.Tags))
                        for i, tag := range subnet.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SubnetResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SubnetResourceModel
        var state SubnetResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        subnetID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || subnetID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Subnet ID are required to update the subnet",
                )
                return
        }</span>

        // Get current subnet details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current subnet",
                        fmt.Sprintf("Unable to get current subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Subnet Not Found",
                        "Subnet not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for subnet",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Preserve network from current state
        <span class="cov0" title="0">network := current.Properties.Network

        // Extract DHCP configuration if provided
        var dhcp *sdktypes.SubnetDHCP
        if !data.Dhcp.IsNull() &amp;&amp; !data.Dhcp.IsUnknown() </span><span class="cov0" title="0">{
                dhcpObj, diags := data.Dhcp.ToObjectValue(ctx)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        attrs := dhcpObj.Attributes()
                        dhcp = &amp;sdktypes.SubnetDHCP{}

                        // Extract enabled
                        if enabledAttr, ok := attrs["enabled"]; ok &amp;&amp; enabledAttr != nil </span><span class="cov0" title="0">{
                                if enabledBool, ok := enabledAttr.(types.Bool); ok &amp;&amp; !enabledBool.IsNull() </span><span class="cov0" title="0">{
                                        dhcp.Enabled = enabledBool.ValueBool()
                                }</span>
                        }

                        // Extract range
                        <span class="cov0" title="0">if rangeAttr, ok := attrs["range"]; ok &amp;&amp; rangeAttr != nil </span><span class="cov0" title="0">{
                                if rangeObj, ok := rangeAttr.(types.Object); ok &amp;&amp; !rangeObj.IsNull() </span><span class="cov0" title="0">{
                                        rangeAttrs := rangeObj.Attributes()
                                        dhcpRange := &amp;sdktypes.SubnetDHCPRange{}
                                        if startAttr, ok := rangeAttrs["start"]; ok &amp;&amp; startAttr != nil </span><span class="cov0" title="0">{
                                                if startStr, ok := startAttr.(types.String); ok &amp;&amp; !startStr.IsNull() </span><span class="cov0" title="0">{
                                                        dhcpRange.Start = startStr.ValueString()
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if countAttr, ok := rangeAttrs["count"]; ok &amp;&amp; countAttr != nil </span><span class="cov0" title="0">{
                                                if countInt, ok := countAttr.(types.Int64); ok &amp;&amp; !countInt.IsNull() </span><span class="cov0" title="0">{
                                                        dhcpRange.Count = int(countInt.ValueInt64())
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if dhcpRange.Start != "" || dhcpRange.Count &gt; 0 </span><span class="cov0" title="0">{
                                                dhcp.Range = dhcpRange
                                        }</span>
                                }
                        }

                        // Extract routes
                        <span class="cov0" title="0">if routesAttr, ok := attrs["routes"]; ok &amp;&amp; routesAttr != nil </span><span class="cov0" title="0">{
                                if routesList, ok := routesAttr.(types.List); ok &amp;&amp; !routesList.IsNull() </span><span class="cov0" title="0">{
                                        var routesData []types.Object
                                        diags := routesList.ElementsAs(ctx, &amp;routesData, false)
                                        resp.Diagnostics.Append(diags...)
                                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                dhcpRoutes := make([]sdktypes.SubnetDHCPRoute, 0, len(routesData))
                                                for _, routeObj := range routesData </span><span class="cov0" title="0">{
                                                        routeAttrs := routeObj.Attributes()
                                                        route := sdktypes.SubnetDHCPRoute{}
                                                        if addrAttr, ok := routeAttrs["address"]; ok &amp;&amp; addrAttr != nil </span><span class="cov0" title="0">{
                                                                if addrStr, ok := addrAttr.(types.String); ok &amp;&amp; !addrStr.IsNull() </span><span class="cov0" title="0">{
                                                                        route.Address = addrStr.ValueString()
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if gwAttr, ok := routeAttrs["gateway"]; ok &amp;&amp; gwAttr != nil </span><span class="cov0" title="0">{
                                                                if gwStr, ok := gwAttr.(types.String); ok &amp;&amp; !gwStr.IsNull() </span><span class="cov0" title="0">{
                                                                        route.Gateway = gwStr.ValueString()
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if route.Address != "" || route.Gateway != "" </span><span class="cov0" title="0">{
                                                                dhcpRoutes = append(dhcpRoutes, route)
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">if len(dhcpRoutes) &gt; 0 </span><span class="cov0" title="0">{
                                                        dhcp.Routes = dhcpRoutes
                                                }</span>
                                        }
                                }
                        }

                        // Extract DNS
                        <span class="cov0" title="0">if dnsAttr, ok := attrs["dns"]; ok &amp;&amp; dnsAttr != nil </span><span class="cov0" title="0">{
                                if dnsList, ok := dnsAttr.(types.List); ok &amp;&amp; !dnsList.IsNull() </span><span class="cov0" title="0">{
                                        var dnsServers []string
                                        diags := dnsList.ElementsAs(ctx, &amp;dnsServers, false)
                                        resp.Diagnostics.Append(diags...)
                                        if !resp.Diagnostics.HasError() &amp;&amp; len(dnsServers) &gt; 0 </span><span class="cov0" title="0">{
                                                dhcp.DNS = dnsServers
                                        }</span>
                                }
                        }
                }
        } else<span class="cov0" title="0"> {
                // Preserve DHCP from current state if not provided in plan
                dhcp = current.Properties.DHCP
        }</span>

        // Build the update request
        <span class="cov0" title="0">updateRequest := sdktypes.SubnetRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.SubnetPropertiesRequest{
                        Type:    current.Properties.Type,
                        Network: network,
                        DHCP:    dhcp,
                },
        }

        // Update the subnet using the SDK
        response, err := r.client.Client.FromNetwork().Subnets().Update(ctx, projectID, vpcID, subnetID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating subnet",
                        fmt.Sprintf("Unable to update subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update subnet"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId
        data.Uri = state.Uri // Preserve URI from state

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If no URI in response, re-read the subnet to get the latest state
                        getResp, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                                }</span> else<span class="cov0" title="0"> {
                                        data.Uri = state.Uri // Fallback to state if not available
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if re-read fails
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI from state
                data.Uri = state.Uri
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SubnetResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SubnetResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        subnetID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || subnetID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Subnet ID are required to delete the subnet",
                )
                return
        }</span>

        // Delete the subnet using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().Subnets().Delete(ctx, projectID, vpcID, subnetID, nil)
                }</span>,
                ExtractSDKError,
                "Subnet",
                subnetID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting subnet",
                        fmt.Sprintf("Unable to delete subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Subnet resource", map[string]interface{}{
                "subnet_id": subnetID,
        })</span>
}

func (r *SubnetResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPCDataSource{}

func NewVPCDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;VPCDataSource{}
}</span>

type VPCDataSource struct {
        client *ArubaCloudClient
}

type VPCDataSourceModel struct {
        Id       types.String `tfsdk:"id"`
        Name     types.String `tfsdk:"name"`
        Location types.String `tfsdk:"location"`
        Tags     types.List   `tfsdk:"tags"`
}

func (d *VPCDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpc"
}</span>

func (d *VPCDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPC location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPC",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPCDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *VPCDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data VPCDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-vpc")
        tflog.Trace(ctx, "read a VPC data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "reflect"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type VPCResource struct {
        client *ArubaCloudClient
}

type VPCResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        ProjectID types.String `tfsdk:"project_id"`
        Tags      types.List   `tfsdk:"tags"`
}

var _ resource.Resource = &amp;VPCResource{}
var _ resource.ResourceWithImportState = &amp;VPCResource{}

func NewVPCResource() resource.Resource <span class="cov0" title="0">{
        return &amp;VPCResource{}
}</span>

func (r *VPCResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPC URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPC location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "Project ID",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPC",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *VPCResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VPCResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VPCResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a VPC",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">setDefault := false
        setPreset := false
        createRequest := sdktypes.VPCRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.VPCPropertiesRequest{
                        Properties: &amp;sdktypes.VPCProperties{
                                Default: &amp;setDefault,
                                Preset:  &amp;setPreset,
                        },
                },
        }

        // Create the VPC using the SDK
        response, err := r.client.Client.FromNetwork().VPCs().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPC",
                        fmt.Sprintf("Unable to create VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create VPC"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPC created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPC to be active before returning (VPC is referenced by Subnets, SecurityGroups, etc.)
        // This ensures Terraform doesn't proceed to create dependent resources until VPC is ready
        <span class="cov0" title="0">vpcID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPC to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VPC", vpcID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Not Active",
                        fmt.Sprintf("VPC was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the VPC to get the URI and ensure all fields are properly set
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(getResp.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(getResp.Data.Metadata.Tags))
                        for i, tag := range getResp.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh VPC after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPC resource", map[string]interface{}{
                "vpc_id":   data.Id.ValueString(),
                "vpc_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPCResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VPCResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        vpcID := data.Id.ValueString()

        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to read the VPC",
                )
                return
        }</span>

        // Get VPC details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPC",
                        fmt.Sprintf("Unable to read VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read VPC"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                vpc := response.Data

                if vpc.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*vpc.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if vpc.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*vpc.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if vpc.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*vpc.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if vpc.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(vpc.Metadata.LocationResponse.Value)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(vpc.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(vpc.Metadata.Tags))
                        for i, tag := range vpc.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPCResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VPCResourceModel
        var state VPCResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        vpcID := state.Id.ValueString()

        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to update the VPC",
                )
                return
        }</span>

        // Get current VPC details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPC",
                        fmt.Sprintf("Unable to get current VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Not Found",
                        "VPC not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for VPC",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build the update request
        <span class="cov0" title="0">setDefault := current.Properties.Default
        // Note: Preset field may not be available in VPCPropertiesResponse
        // Only preserve Default if it exists
        updateRequest := sdktypes.VPCRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.VPCPropertiesRequest{
                        Properties: &amp;sdktypes.VPCProperties{
                                Default: &amp;setDefault,
                                // Preset field not available in response type - omit if not needed
                        },
                },
        }

        // Update the VPC using the SDK
        response, err := r.client.Client.FromNetwork().VPCs().Update(ctx, projectID, vpcID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPC",
                        fmt.Sprintf("Unable to update VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update VPC"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Uri = state.Uri // Preserve URI from state

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If no URI in response, re-read the VPC to get the latest state
                        getResp, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                                }</span> else<span class="cov0" title="0"> {
                                        data.Uri = state.Uri // Fallback to state if not available
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if re-read fails
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI from state
                data.Uri = state.Uri
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPCResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VPCResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        vpcID := data.Id.ValueString()

        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to delete the VPC",
                )
                return
        }</span>

        // Delete the VPC using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        // The response from VPCs().Delete() has StatusCode and Error fields directly accessible
        <span class="cov0" title="0">deleteFunc := func() (interface{}, error) </span><span class="cov0" title="0">{
                return r.client.Client.FromNetwork().VPCs().Delete(ctx, projectID, vpcID, nil)
        }</span>

        // Extract error info - the response type has StatusCode and Error as fields
        // The response from VPCs().Delete() is the same type as in Read/Update methods
        // which access response.StatusCode and response.Error.Title directly
        <span class="cov0" title="0">extractErrorFunc := func(response interface{}) (int, *string, *string, bool) </span><span class="cov0" title="0">{
                // Check if response has IsError() method
                type errorResponse interface {
                        IsError() bool
                }
                resp, ok := response.(errorResponse)
                if !ok </span><span class="cov0" title="0">{
                        return 0, nil, nil, false
                }</span>
                <span class="cov0" title="0">if !resp.IsError() </span><span class="cov0" title="0">{
                        return 0, nil, nil, false
                }</span>

                // The response from deleteFunc is the actual SDK response type
                // which has StatusCode and Error as direct struct fields
                // We can access them by type asserting to the actual response type
                // Since deleteFunc returns the concrete type, we can access fields directly
                // The response type matches what we see in Read/Update: response.StatusCode, response.Error.Title
                // We'll access them using the response directly where we know the type
                // For VPC, the response is the same type as used elsewhere in this file
                // We can access response.StatusCode and response.Error.Title directly
                // by using the response type from the SDK
                <span class="cov0" title="0">return extractVPCDelError(response)</span>
        }

        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                deleteFunc,
                extractErrorFunc,
                "VPC",
                vpcID,
                r.client.ResourceTimeout,
        )

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPC",
                        fmt.Sprintf("Unable to delete VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPC resource", map[string]interface{}{
                "vpc_id": vpcID,
        })</span>
}

// extractVPCDelError extracts error from VPC delete response using reflection.
// The response from VPCs().Delete() has StatusCode and Error as direct struct fields.
// We use reflection to access these fields since we have interface{}.
func extractVPCDelError(response interface{}) (int, *string, *string, bool) <span class="cov0" title="0">{
        // Use reflection to access StatusCode and Error fields
        v := reflect.ValueOf(response)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        // Access StatusCode field
        <span class="cov0" title="0">statusCodeField := v.FieldByName("StatusCode")
        if !statusCodeField.IsValid() || !statusCodeField.CanInterface() </span><span class="cov0" title="0">{
                return 0, nil, nil, true // Return that it's an error, but can't extract details
        }</span>
        <span class="cov0" title="0">statusCode := int(statusCodeField.Int())

        // Access Error field
        errorField := v.FieldByName("Error")
        if !errorField.IsValid() </span><span class="cov0" title="0">{
                return statusCode, nil, nil, true
        }</span>

        // Access Error.Title and Error.Detail
        <span class="cov0" title="0">var errorTitle, errorDetail *string
        if errorField.Kind() == reflect.Struct || (errorField.Kind() == reflect.Ptr &amp;&amp; errorField.Elem().Kind() == reflect.Struct) </span><span class="cov0" title="0">{
                errorVal := errorField
                if errorVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        errorVal = errorVal.Elem()
                }</span>

                <span class="cov0" title="0">titleField := errorVal.FieldByName("Title")
                if titleField.IsValid() &amp;&amp; titleField.CanInterface() &amp;&amp; !titleField.IsNil() </span><span class="cov0" title="0">{
                        if titlePtr, ok := titleField.Interface().(*string); ok </span><span class="cov0" title="0">{
                                errorTitle = titlePtr
                        }</span>
                }

                <span class="cov0" title="0">detailField := errorVal.FieldByName("Detail")
                if detailField.IsValid() &amp;&amp; detailField.CanInterface() &amp;&amp; !detailField.IsNil() </span><span class="cov0" title="0">{
                        if detailPtr, ok := detailField.Interface().(*string); ok </span><span class="cov0" title="0">{
                                errorDetail = detailPtr
                        }</span>
                }
        }

        <span class="cov0" title="0">return statusCode, errorTitle, errorDetail, true</span>
}

func (r *VPCResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

func (r *VPCResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpc"
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPCPeeringDataSource{}

func NewVPCPeeringDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;VPCPeeringDataSource{}
}</span>

type VPCPeeringDataSource struct {
        client *ArubaCloudClient
}

type VPCPeeringDataSourceModel struct {
        Id   types.String `tfsdk:"id"`
        Name types.String `tfsdk:"name"`
}

func (d *VPCPeeringDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpcpeering"
}</span>

func (d *VPCPeeringDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC Peering data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering name",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPCPeeringDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *VPCPeeringDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data VPCPeeringDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-vpcpeering")
        tflog.Trace(ctx, "read a VPC Peering data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;VpcPeeringResource{}
var _ resource.ResourceWithImportState = &amp;VpcPeeringResource{}

func NewVpcPeeringResource() resource.Resource <span class="cov0" title="0">{
        return &amp;VpcPeeringResource{}
}</span>

type VpcPeeringResource struct {
        client *ArubaCloudClient
}

type VpcPeeringResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
        PeerVpc   types.String `tfsdk:"peer_vpc"`
}

func (r *VpcPeeringResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpcpeering"
}</span>

func (r *VpcPeeringResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC Peering resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPC Peering",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPC Peering belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this peering belongs to",
                                Required:            true,
                        },
                        "peer_vpc": schema.StringAttribute{
                                MarkdownDescription: "ID or URI of the peer VPC to connect to",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *VpcPeeringResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VpcPeeringResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VpcPeeringResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()

        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to create a VPC peering",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build peer VPC URI
        <span class="cov0" title="0">peerVPCURI := data.PeerVpc.ValueString()
        if !strings.HasPrefix(peerVPCURI, "/") </span><span class="cov0" title="0">{
                peerVPCURI = fmt.Sprintf("/projects/%s/providers/Aruba.Network/vpcs/%s", projectID, peerVPCURI)
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.VPCPeeringRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.VPCPeeringPropertiesRequest{
                        RemoteVPC: &amp;sdktypes.ReferenceResource{
                                URI: peerVPCURI,
                        },
                },
        }

        // Create the VPC peering using the SDK
        response, err := r.client.Client.FromNetwork().VPCPeerings().Create(ctx, projectID, vpcID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPC peering",
                        fmt.Sprintf("Unable to create VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create VPC peering"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPC peering created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPC Peering to be active before returning (VpcPeering is referenced by VpcPeeringRoute)
        // This ensures Terraform doesn't proceed to create dependent resources until VPC Peering is ready
        <span class="cov0" title="0">peeringID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPCPeerings().Get(ctx, projectID, vpcID, peeringID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPC Peering to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VpcPeering", peeringID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Peering Not Active",
                        fmt.Sprintf("VPC peering was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPC Peering resource", map[string]interface{}{
                "vpcpeering_id":   data.Id.ValueString(),
                "vpcpeering_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VpcPeeringResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Peering ID are required to read the VPC peering",
                )
                return
        }</span>

        // Get VPC peering details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPCPeerings().Get(ctx, projectID, vpcID, peeringID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPC peering",
                        fmt.Sprintf("Unable to read VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read VPC peering"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                peering := response.Data

                if peering.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*peering.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if peering.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*peering.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if peering.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*peering.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if peering.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(peering.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if peering.Properties.RemoteVPC != nil </span><span class="cov0" title="0">{
                        data.PeerVpc = types.StringValue(peering.Properties.RemoteVPC.URI)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(peering.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(peering.Metadata.Tags))
                        for i, tag := range peering.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VpcPeeringResourceModel
        var state VpcPeeringResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        peeringID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Peering ID are required to update the VPC peering",
                )
                return
        }</span>

        // Get current VPC peering details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPCPeerings().Get(ctx, projectID, vpcID, peeringID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPC peering",
                        fmt.Sprintf("Unable to get current VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Peering Not Found",
                        "VPC peering not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if VPC peering is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update VPC Peering",
                        "Cannot update VPC peering while it is in 'InCreation' state. Please wait until the VPC peering is fully created.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for VPC peering",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated, peer VPC must remain unchanged
        <span class="cov0" title="0">updateRequest := sdktypes.VPCPeeringRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.VPCPeeringPropertiesRequest{
                        // Peer VPC cannot be updated - use current value
                        RemoteVPC: current.Properties.RemoteVPC,
                },
        }

        // Update the VPC peering using the SDK
        response, err := r.client.Client.FromNetwork().VPCPeerings().Update(ctx, projectID, vpcID, peeringID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPC peering",
                        fmt.Sprintf("Unable to update VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update VPC peering"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VpcPeeringResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Peering ID are required to delete the VPC peering",
                )
                return
        }</span>

        // Delete the VPC peering using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().VPCPeerings().Delete(ctx, projectID, vpcID, peeringID, nil)
                }</span>,
                ExtractSDKError,
                "VPCPeering",
                peeringID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPC peering",
                        fmt.Sprintf("Unable to delete VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPC Peering resource", map[string]interface{}{
                "vpcpeering_id": peeringID,
        })</span>
}

func (r *VpcPeeringResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPCPeeringRouteDataSource{}

func NewVPCPeeringRouteDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;VPCPeeringRouteDataSource{}
}</span>

type VPCPeeringRouteDataSource struct {
        client *ArubaCloudClient
}

type VPCPeeringRouteDataSourceModel struct {
        Id   types.String `tfsdk:"id"`
        Name types.String `tfsdk:"name"`
}

func (d *VPCPeeringRouteDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpcpeeringroute"
}</span>

func (d *VPCPeeringRouteDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC Peering Route data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route name",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPCPeeringRouteDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *VPCPeeringRouteDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data VPCPeeringRouteDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-vpcpeeringroute")
        tflog.Trace(ctx, "read a VPC Peering Route data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;VpcPeeringRouteResource{}
var _ resource.ResourceWithImportState = &amp;VpcPeeringRouteResource{}

func NewVpcPeeringRouteResource() resource.Resource <span class="cov0" title="0">{
        return &amp;VpcPeeringRouteResource{}
}</span>

type VpcPeeringRouteResource struct {
        client *ArubaCloudClient
}

type VpcPeeringRouteResourceModel struct {
        Id                   types.String `tfsdk:"id"`
        Uri                  types.String `tfsdk:"uri"`
        Name                 types.String `tfsdk:"name"`
        Tags                 types.List   `tfsdk:"tags"`
        ProjectId            types.String `tfsdk:"project_id"`
        VpcId                types.String `tfsdk:"vpc_id"`
        VpcPeeringId         types.String `tfsdk:"vpc_peering_id"`
        LocalNetworkAddress  types.String `tfsdk:"local_network_address"`
        RemoteNetworkAddress types.String `tfsdk:"remote_network_address"`
        BillingPeriod        types.String `tfsdk:"billing_period"`
}

func (r *VpcPeeringRouteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpcpeeringroute"
}</span>

func (r *VpcPeeringRouteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC Peering Route resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route name",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPC Peering Route",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPC Peering Route belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this peering route belongs to",
                                Required:            true,
                        },
                        "vpc_peering_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC Peering this route belongs to",
                                Required:            true,
                        },
                        "local_network_address": schema.StringAttribute{
                                MarkdownDescription: "Local network address in CIDR notation",
                                Required:            true,
                        },
                        "remote_network_address": schema.StringAttribute{
                                MarkdownDescription: "Remote network address in CIDR notation",
                                Required:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *VpcPeeringRouteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VpcPeeringRouteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VpcPeeringRouteResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.VpcPeeringId.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and VPC Peering ID are required to create a VPC peering route",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.VPCPeeringRouteRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
                Properties: sdktypes.VPCPeeringRoutePropertiesRequest{
                        LocalNetworkAddress:  data.LocalNetworkAddress.ValueString(),
                        RemoteNetworkAddress: data.RemoteNetworkAddress.ValueString(),
                        BillingPlan: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Create the VPC peering route using the SDK
        response, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Create(ctx, projectID, vpcID, peeringID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPC peering route",
                        fmt.Sprintf("Unable to create VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create VPC peering route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // VPC Peering Route uses name as ID
                data.Id = types.StringValue(response.Data.Metadata.Name)
                // VPC Peering Route uses RegionalResourceMetadataRequest which doesn't have URI
                data.Uri = types.StringNull()
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPC peering route created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPC Peering Route to be active before returning
        // This ensures Terraform doesn't proceed until VPC Peering Route is ready
        <span class="cov0" title="0">routeID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Get(ctx, projectID, vpcID, peeringID, routeID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPC Peering Route to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VpcPeeringRoute", routeID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Peering Route Not Active",
                        fmt.Sprintf("VPC peering route was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPC Peering Route resource", map[string]interface{}{
                "vpcpeeringroute_id":   data.Id.ValueString(),
                "vpcpeeringroute_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringRouteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VpcPeeringRouteResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.VpcPeeringId.ValueString()
        routeID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, VPC Peering ID, and Route ID are required to read the VPC peering route",
                )
                return
        }</span>

        // Get VPC peering route details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Get(ctx, projectID, vpcID, peeringID, routeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPC peering route",
                        fmt.Sprintf("Unable to read VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read VPC peering route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                route := response.Data

                data.Id = types.StringValue(route.Metadata.Name)
                // VPC Peering Route uses RegionalResourceMetadataRequest which doesn't have URI
                data.Uri = types.StringNull()
                data.Name = types.StringValue(route.Metadata.Name)
                data.LocalNetworkAddress = types.StringValue(route.Properties.LocalNetworkAddress)
                data.RemoteNetworkAddress = types.StringValue(route.Properties.RemoteNetworkAddress)
                if route.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(route.Properties.BillingPlan.BillingPeriod)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(route.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(route.Metadata.Tags))
                        for i, tag := range route.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringRouteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VpcPeeringRouteResourceModel
        var state VpcPeeringRouteResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        peeringID := state.VpcPeeringId.ValueString()
        routeID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, VPC Peering ID, and Route ID are required to update the VPC peering route",
                )
                return
        }</span>

        // Get current VPC peering route details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Get(ctx, projectID, vpcID, peeringID, routeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPC peering route",
                        fmt.Sprintf("Unable to get current VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Peering Route Not Found",
                        "VPC peering route not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if VPC peering route is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update VPC Peering Route",
                        "Cannot update VPC peering route while it is in 'InCreation' state. Please wait until the VPC peering route is fully created.",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.VPCPeeringRouteRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
                Properties: sdktypes.VPCPeeringRoutePropertiesRequest{
                        LocalNetworkAddress:  data.LocalNetworkAddress.ValueString(),
                        RemoteNetworkAddress: data.RemoteNetworkAddress.ValueString(),
                        BillingPlan: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Update the VPC peering route using the SDK
        response, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Update(ctx, projectID, vpcID, peeringID, routeID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPC peering route",
                        fmt.Sprintf("Unable to update VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update VPC peering route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId
        data.VpcPeeringId = state.VpcPeeringId

        // Note: VpcPeeringRoute uses name as ID and response doesn't have Metadata.ID
        // ID is already set from state above

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringRouteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VpcPeeringRouteResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.VpcPeeringId.ValueString()
        routeID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, VPC Peering ID, and Route ID are required to delete the VPC peering route",
                )
                return
        }</span>

        // Delete the VPC peering route using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().VPCPeeringRoutes().Delete(ctx, projectID, vpcID, peeringID, routeID, nil)
                }</span>,
                ExtractSDKError,
                "VPCPeeringRoute",
                routeID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPC peering route",
                        fmt.Sprintf("Unable to delete VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPC Peering Route resource", map[string]interface{}{
                "vpcpeeringroute_id": routeID,
        })</span>
}

func (r *VpcPeeringRouteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPNRouteDataSource{}

func NewVPNRouteDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;VPNRouteDataSource{}
}</span>

type VPNRouteDataSource struct {
        client *ArubaCloudClient
}

type VPNRouteDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Destination types.String `tfsdk:"destination"`
        Gateway     types.String `tfsdk:"gateway"`
}

func (d *VPNRouteDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpnroute"
}</span>

func (d *VPNRouteDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPN Route data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPN Route identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPN Route name",
                                Computed:            true,
                        },
                        "destination": schema.StringAttribute{
                                MarkdownDescription: "Destination network for the VPN route",
                                Computed:            true,
                        },
                        "gateway": schema.StringAttribute{
                                MarkdownDescription: "Gateway for the VPN route",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPNRouteDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *VPNRouteDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data VPNRouteDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-vpnroute")
        data.Destination = types.StringValue("10.0.0.0/24")
        data.Gateway = types.StringValue("10.0.0.1")
        tflog.Trace(ctx, "read a VPN Route data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;VPNRouteResource{}
var _ resource.ResourceWithImportState = &amp;VPNRouteResource{}

func NewVPNRouteResource() resource.Resource <span class="cov0" title="0">{
        return &amp;VPNRouteResource{}
}</span>

type VPNRouteResourceModel struct {
        Id          types.String `tfsdk:"id"`
        Uri         types.String `tfsdk:"uri"`
        Name        types.String `tfsdk:"name"`
        Location    types.String `tfsdk:"location"`
        Tags        types.List   `tfsdk:"tags"`
        ProjectId   types.String `tfsdk:"project_id"`
        VPNTunnelId types.String `tfsdk:"vpn_tunnel_id"`
        Properties  types.Object `tfsdk:"properties"`
}

type VPNRouteResource struct {
        client *ArubaCloudClient
}

func (r *VPNRouteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpnroute"
}</span>

func (r *VPNRouteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPN Route resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPN Route identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPN Route URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPN Route name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPN Route location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPN Route",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPN Route belongs to",
                                Required:            true,
                        },
                        "vpn_tunnel_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPN Tunnel this route belongs to",
                                Required:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                MarkdownDescription: "Properties of the VPN Route",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "cloud_subnet": schema.StringAttribute{
                                                MarkdownDescription: "CIDR of the cloud subnet",
                                                Required:            true,
                                        },
                                        "on_prem_subnet": schema.StringAttribute{
                                                MarkdownDescription: "CIDR of the on-prem subnet",
                                                Required:            true,
                                        },
                                },
                        },
                },
        }
}</span>

func (r *VPNRouteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VPNRouteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VPNRouteResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpnTunnelID := data.VPNTunnelId.ValueString()

        if projectID == "" || vpnTunnelID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPN Tunnel ID are required to create a VPN route",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract properties from Terraform object
        <span class="cov0" title="0">propertiesObj, diags := data.Properties.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">propertiesAttrs := propertiesObj.Attributes()
        cloudSubnetAttr, ok := propertiesAttrs["cloud_subnet"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "cloud_subnet must be a String")
                return
        }</span>
        <span class="cov0" title="0">cloudSubnet := cloudSubnetAttr.ValueString()

        onPremSubnetAttr, ok := propertiesAttrs["on_prem_subnet"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "on_prem_subnet must be a String")
                return
        }</span>
        <span class="cov0" title="0">onPremSubnet := onPremSubnetAttr.ValueString()

        // Build the create request
        createRequest := sdktypes.VPNRouteRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.VPNRoutePropertiesRequest{
                        CloudSubnet:  cloudSubnet,
                        OnPremSubnet: onPremSubnet,
                },
        }

        // Create the VPN route using the SDK
        response, err := r.client.Client.FromNetwork().VPNRoutes().Create(ctx, projectID, vpnTunnelID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPN route",
                        fmt.Sprintf("Unable to create VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create VPN route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPN route created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPN Route to be active before returning (VPNRoute references VPNTunnel)
        // This ensures Terraform doesn't proceed to create dependent resources until VPN Route is ready
        <span class="cov0" title="0">routeID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPNRoutes().Get(ctx, projectID, vpnTunnelID, routeID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPN Route to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VPNRoute", routeID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPN Route Not Active",
                        fmt.Sprintf("VPN route was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPN Route resource", map[string]interface{}{
                "vpnroute_id":   data.Id.ValueString(),
                "vpnroute_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNRouteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VPNRouteResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpnTunnelID := data.VPNTunnelId.ValueString()
        routeID := data.Id.ValueString()

        if projectID == "" || vpnTunnelID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPN Tunnel ID, and Route ID are required to read the VPN route",
                )
                return
        }</span>

        // Get VPN route details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPNRoutes().Get(ctx, projectID, vpnTunnelID, routeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPN route",
                        fmt.Sprintf("Unable to read VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read VPN route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                route := response.Data

                if route.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*route.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if route.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*route.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if route.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*route.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if route.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(route.Metadata.LocationResponse.Value)
                }</span>

                // Update properties from response
                <span class="cov0" title="0">propertiesMap := map[string]attr.Value{
                        "cloud_subnet":   types.StringValue(route.Properties.CloudSubnet),
                        "on_prem_subnet": types.StringValue(route.Properties.OnPremSubnet),
                }

                propertiesObj, diags := types.ObjectValue(map[string]attr.Type{
                        "cloud_subnet":   types.StringType,
                        "on_prem_subnet": types.StringType,
                }, propertiesMap)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Properties = propertiesObj
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(route.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(route.Metadata.Tags))
                        for i, tag := range route.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNRouteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VPNRouteResourceModel
        var state VPNRouteResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpnTunnelID := state.VPNTunnelId.ValueString()
        routeID := state.Id.ValueString()

        if projectID == "" || vpnTunnelID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPN Tunnel ID, and Route ID are required to update the VPN route",
                )
                return
        }</span>

        // Get current VPN route details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPNRoutes().Get(ctx, projectID, vpnTunnelID, routeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPN route",
                        fmt.Sprintf("Unable to get current VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPN Route Not Found",
                        "VPN route not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if VPN route is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update VPN Route",
                        "Cannot update VPN route while it is in 'InCreation' state. Please wait until the VPN route is fully created.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for VPN route",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Extract properties
        <span class="cov0" title="0">propertiesObj, diags := data.Properties.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">propertiesAttrs := propertiesObj.Attributes()
        cloudSubnetAttr, ok := propertiesAttrs["cloud_subnet"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "cloud_subnet must be a String")
                return
        }</span>
        <span class="cov0" title="0">cloudSubnet := cloudSubnetAttr.ValueString()

        onPremSubnetAttr, ok := propertiesAttrs["on_prem_subnet"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "on_prem_subnet must be a String")
                return
        }</span>
        <span class="cov0" title="0">onPremSubnet := onPremSubnetAttr.ValueString()

        // Build update request
        updateRequest := sdktypes.VPNRouteRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.VPNRoutePropertiesRequest{
                        CloudSubnet:  cloudSubnet,
                        OnPremSubnet: onPremSubnet,
                },
        }

        // Update the VPN route using the SDK
        response, err := r.client.Client.FromNetwork().VPNRoutes().Update(ctx, projectID, vpnTunnelID, routeID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPN route",
                        fmt.Sprintf("Unable to update VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update VPN route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VPNTunnelId = state.VPNTunnelId

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNRouteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VPNRouteResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpnTunnelID := data.VPNTunnelId.ValueString()
        routeID := data.Id.ValueString()

        if projectID == "" || vpnTunnelID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPN Tunnel ID, and Route ID are required to delete the VPN route",
                )
                return
        }</span>

        // Delete the VPN route using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().VPNRoutes().Delete(ctx, projectID, vpnTunnelID, routeID, nil)
                }</span>,
                ExtractSDKError,
                "VPNRoute",
                routeID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPN route",
                        fmt.Sprintf("Unable to delete VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPN Route resource", map[string]interface{}{
                "vpnroute_id": routeID,
        })</span>
}

func (r *VPNRouteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPNTunnelDataSource{}

func NewVPNTunnelDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;VPNTunnelDataSource{}
}</span>

type VPNTunnelDataSource struct {
        client *ArubaCloudClient
}

type VPNTunnelDataSourceModel struct {
        Id         types.String `tfsdk:"id"`
        Name       types.String `tfsdk:"name"`
        RemotePeer types.String `tfsdk:"remote_peer"`
        Status     types.String `tfsdk:"status"`
}

func (d *VPNTunnelDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpntunnel"
}</span>

func (d *VPNTunnelDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPN Tunnel data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel name",
                                Computed:            true,
                        },
                        "remote_peer": schema.StringAttribute{
                                MarkdownDescription: "Remote peer address for the VPN tunnel",
                                Computed:            true,
                        },
                        "status": schema.StringAttribute{
                                MarkdownDescription: "Status of the VPN tunnel",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPNTunnelDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">d.client = client</span>
}

func (d *VPNTunnelDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data VPNTunnelDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Name = types.StringValue("example-vpntunnel")
        data.RemotePeer = types.StringValue("203.0.113.1")
        data.Status = types.StringValue("active")
        tflog.Trace(ctx, "read a VPN Tunnel data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;VPNTunnelResource{}
var _ resource.ResourceWithImportState = &amp;VPNTunnelResource{}

func NewVPNTunnelResource() resource.Resource <span class="cov0" title="0">{
        return &amp;VPNTunnelResource{}
}</span>

type VPNTunnelResourceModel struct {
        Id         types.String `tfsdk:"id"`
        Uri        types.String `tfsdk:"uri"`
        Name       types.String `tfsdk:"name"`
        Location   types.String `tfsdk:"location"`
        Tags       types.List   `tfsdk:"tags"`
        ProjectId  types.String `tfsdk:"project_id"`
        Properties types.Object `tfsdk:"properties"`
}

type VPNTunnelResource struct {
        client *ArubaCloudClient
}

func (r *VPNTunnelResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_vpntunnel"
}</span>

func (r *VPNTunnelResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPN Tunnel resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPN Tunnel",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPN Tunnel belongs to",
                                Required:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                MarkdownDescription: "Properties of the VPN Tunnel",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "vpn_type": schema.StringAttribute{
                                                MarkdownDescription: "Type of VPN tunnel (Site-To-Site)",
                                                Optional:            true,
                                        },
                                        "vpn_client_protocol": schema.StringAttribute{
                                                MarkdownDescription: "Protocol of the VPN tunnel (ikev2)",
                                                Optional:            true,
                                        },
                                        "billing_period": schema.StringAttribute{
                                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                                Optional:            true,
                                        },
                                        "ip_configurations": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Network configuration of the VPN tunnel",
                                                Optional:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "vpc": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "VPC reference",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "id": schema.StringAttribute{
                                                                                MarkdownDescription: "VPC id",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "subnet": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "Subnet reference",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "id": schema.StringAttribute{
                                                                                MarkdownDescription: "Subnet id",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "public_ip": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "Public IP reference",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "id": schema.StringAttribute{
                                                                                MarkdownDescription: "Public IP id",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                        "vpn_client_settings": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Client settings of the VPN tunnel",
                                                Optional:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "ike": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "IKE settings",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "lifetime": schema.Int64Attribute{
                                                                                MarkdownDescription: "IKE lifetime",
                                                                                Optional:            true,
                                                                        },
                                                                        "encryption": schema.StringAttribute{
                                                                                MarkdownDescription: "IKE encryption algorithm",
                                                                                Optional:            true,
                                                                        },
                                                                        "hash": schema.StringAttribute{
                                                                                MarkdownDescription: "IKE hash algorithm",
                                                                                Optional:            true,
                                                                        },
                                                                        "dh_group": schema.StringAttribute{
                                                                                MarkdownDescription: "IKE DH group",
                                                                                Optional:            true,
                                                                        },
                                                                        "dpd_action": schema.StringAttribute{
                                                                                MarkdownDescription: "IKE DPD action",
                                                                                Optional:            true,
                                                                        },
                                                                        "dpd_interval": schema.Int64Attribute{
                                                                                MarkdownDescription: "IKE DPD interval",
                                                                                Optional:            true,
                                                                        },
                                                                        "dpd_timeout": schema.Int64Attribute{
                                                                                MarkdownDescription: "IKE DPD timeout",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "esp": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "ESP settings",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "lifetime": schema.Int64Attribute{
                                                                                MarkdownDescription: "ESP lifetime",
                                                                                Optional:            true,
                                                                        },
                                                                        "encryption": schema.StringAttribute{
                                                                                MarkdownDescription: "ESP encryption algorithm",
                                                                                Optional:            true,
                                                                        },
                                                                        "hash": schema.StringAttribute{
                                                                                MarkdownDescription: "ESP hash algorithm",
                                                                                Optional:            true,
                                                                        },
                                                                        "pfs": schema.StringAttribute{
                                                                                MarkdownDescription: "ESP PFS",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "psk": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "PSK settings",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "cloud_site": schema.StringAttribute{
                                                                                MarkdownDescription: "PSK cloud site",
                                                                                Optional:            true,
                                                                        },
                                                                        "on_prem_site": schema.StringAttribute{
                                                                                MarkdownDescription: "PSK on-prem site",
                                                                                Optional:            true,
                                                                        },
                                                                        "secret": schema.StringAttribute{
                                                                                MarkdownDescription: "PSK secret",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "peer_client_public_ip": schema.StringAttribute{
                                                                MarkdownDescription: "Peer client public IP address",
                                                                Optional:            true,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func (r *VPNTunnelResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VPNTunnelResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VPNTunnelResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a VPN tunnel",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract properties from Terraform object
        <span class="cov0" title="0">propertiesObj, diags := data.Properties.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">propertiesAttrs := propertiesObj.Attributes()

        // Extract VPN type and protocol
        vpnType := "Site-To-Site"
        if vpnTypeAttr, ok := propertiesAttrs["vpn_type"]; ok &amp;&amp; vpnTypeAttr != nil </span><span class="cov0" title="0">{
                if vpnTypeStr, ok := vpnTypeAttr.(types.String); ok &amp;&amp; !vpnTypeStr.IsNull() </span><span class="cov0" title="0">{
                        vpnType = vpnTypeStr.ValueString()
                }</span>
        }

        <span class="cov0" title="0">protocol := "ikev2"
        if protocolAttr, ok := propertiesAttrs["vpn_client_protocol"]; ok &amp;&amp; protocolAttr != nil </span><span class="cov0" title="0">{
                if protocolStr, ok := protocolAttr.(types.String); ok &amp;&amp; !protocolStr.IsNull() </span><span class="cov0" title="0">{
                        protocol = protocolStr.ValueString()
                }</span>
        }

        <span class="cov0" title="0">billingPeriod := "Hour"
        if billingAttr, ok := propertiesAttrs["billing_period"]; ok &amp;&amp; billingAttr != nil </span><span class="cov0" title="0">{
                if billingStr, ok := billingAttr.(types.String); ok &amp;&amp; !billingStr.IsNull() </span><span class="cov0" title="0">{
                        billingPeriod = billingStr.ValueString()
                }</span>
        }

        // Extract IP configurations
        <span class="cov0" title="0">var ipConfig *sdktypes.IPConfigurations
        if ipConfigAttr, ok := propertiesAttrs["ip_configurations"]; ok &amp;&amp; ipConfigAttr != nil </span><span class="cov0" title="0">{
                if ipConfigObj, ok := ipConfigAttr.(types.Object); ok &amp;&amp; !ipConfigObj.IsNull() </span><span class="cov0" title="0">{
                        ipConfigObjValue, diags := ipConfigObj.ToObjectValue(ctx)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                ipConfigAttrs := ipConfigObjValue.Attributes()
                                ipConfig = &amp;sdktypes.IPConfigurations{}

                                // Extract VPC
                                if vpcAttr, ok := ipConfigAttrs["vpc"]; ok &amp;&amp; vpcAttr != nil </span><span class="cov0" title="0">{
                                        if vpcObj, ok := vpcAttr.(types.Object); ok &amp;&amp; !vpcObj.IsNull() </span><span class="cov0" title="0">{
                                                vpcObjValue, diags := vpcObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        vpcAttrs := vpcObjValue.Attributes()
                                                        if vpcIDAttr, ok := vpcAttrs["id"]; ok &amp;&amp; vpcIDAttr != nil </span><span class="cov0" title="0">{
                                                                if vpcIDStr, ok := vpcIDAttr.(types.String); ok &amp;&amp; !vpcIDStr.IsNull() </span><span class="cov0" title="0">{
                                                                        vpcID := vpcIDStr.ValueString()
                                                                        if !strings.HasPrefix(vpcID, "/") </span><span class="cov0" title="0">{
                                                                                vpcID = fmt.Sprintf("/projects/%s/providers/Aruba.Network/vpcs/%s", projectID, vpcID)
                                                                        }</span>
                                                                        <span class="cov0" title="0">ipConfig.VPC = &amp;sdktypes.ReferenceResource{URI: vpcID}</span>
                                                                }
                                                        }
                                                }
                                        }
                                }

                                // Extract Subnet
                                <span class="cov0" title="0">if subnetAttr, ok := ipConfigAttrs["subnet"]; ok &amp;&amp; subnetAttr != nil </span><span class="cov0" title="0">{
                                        if subnetObj, ok := subnetAttr.(types.Object); ok &amp;&amp; !subnetObj.IsNull() </span><span class="cov0" title="0">{
                                                subnetObjValue, diags := subnetObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        subnetAttrs := subnetObjValue.Attributes()
                                                        if subnetIDAttr, ok := subnetAttrs["id"]; ok &amp;&amp; subnetIDAttr != nil </span><span class="cov0" title="0">{
                                                                if subnetIDStr, ok := subnetIDAttr.(types.String); ok &amp;&amp; !subnetIDStr.IsNull() </span><span class="cov0" title="0">{
                                                                        subnetID := subnetIDStr.ValueString()
                                                                        if !strings.HasPrefix(subnetID, "/") </span><span class="cov0" title="0">{
                                                                                // Need VPC ID for subnet URI - try to get from VPC if available
                                                                                if ipConfig.VPC != nil </span><span class="cov0" title="0">{
                                                                                        // Extract VPC ID from URI
                                                                                        vpcURI := ipConfig.VPC.URI
                                                                                        parts := strings.Split(vpcURI, "/")
                                                                                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                                                                                vpcID := parts[len(parts)-1]
                                                                                                subnetID = fmt.Sprintf("/projects/%s/providers/Aruba.Network/vpcs/%s/subnets/%s", projectID, vpcID, subnetID)
                                                                                        }</span>
                                                                                }
                                                                        }
                                                                        // Subnet field expects SubnetInfo, which has CIDR and Name fields
                                                                        // Extract subnet name from URI or use the ID as name
                                                                        <span class="cov0" title="0">subnetName := subnetID
                                                                        if strings.Contains(subnetID, "/") </span><span class="cov0" title="0">{
                                                                                parts := strings.Split(subnetID, "/")
                                                                                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                                                                        subnetName = parts[len(parts)-1]
                                                                                }</span>
                                                                        }
                                                                        <span class="cov0" title="0">ipConfig.Subnet = &amp;sdktypes.SubnetInfo{
                                                                                Name: subnetName,
                                                                                // CIDR can be empty if not provided
                                                                        }</span>
                                                                }
                                                        }
                                                }
                                        }
                                }

                                // Extract Public IP
                                <span class="cov0" title="0">if publicIPAttr, ok := ipConfigAttrs["public_ip"]; ok &amp;&amp; publicIPAttr != nil </span><span class="cov0" title="0">{
                                        if publicIPObj, ok := publicIPAttr.(types.Object); ok &amp;&amp; !publicIPObj.IsNull() </span><span class="cov0" title="0">{
                                                publicIPObjValue, diags := publicIPObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        publicIPAttrs := publicIPObjValue.Attributes()
                                                        if publicIPIDAttr, ok := publicIPAttrs["id"]; ok &amp;&amp; publicIPIDAttr != nil </span><span class="cov0" title="0">{
                                                                if publicIPIDStr, ok := publicIPIDAttr.(types.String); ok &amp;&amp; !publicIPIDStr.IsNull() </span><span class="cov0" title="0">{
                                                                        publicIPID := publicIPIDStr.ValueString()
                                                                        if !strings.HasPrefix(publicIPID, "/") </span><span class="cov0" title="0">{
                                                                                publicIPID = fmt.Sprintf("/projects/%s/providers/Aruba.Network/elasticips/%s", projectID, publicIPID)
                                                                        }</span>
                                                                        <span class="cov0" title="0">ipConfig.PublicIP = &amp;sdktypes.ReferenceResource{URI: publicIPID}</span>
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        // Extract VPN client settings
        <span class="cov0" title="0">var vpnClientSettings *sdktypes.VPNClientSettings
        if vpnClientAttr, ok := propertiesAttrs["vpn_client_settings"]; ok &amp;&amp; vpnClientAttr != nil </span><span class="cov0" title="0">{
                if vpnClientObj, ok := vpnClientAttr.(types.Object); ok &amp;&amp; !vpnClientObj.IsNull() </span><span class="cov0" title="0">{
                        vpnClientObjValue, diags := vpnClientObj.ToObjectValue(ctx)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                vpnClientAttrs := vpnClientObjValue.Attributes()
                                vpnClientSettings = &amp;sdktypes.VPNClientSettings{}

                                // Extract IKE settings
                                if ikeAttr, ok := vpnClientAttrs["ike"]; ok &amp;&amp; ikeAttr != nil </span><span class="cov0" title="0">{
                                        if ikeObj, ok := ikeAttr.(types.Object); ok &amp;&amp; !ikeObj.IsNull() </span><span class="cov0" title="0">{
                                                ikeObjValue, diags := ikeObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        ikeAttrs := ikeObjValue.Attributes()
                                                        ikeSettings := &amp;sdktypes.IKESettings{}

                                                        if lifetimeAttr, ok := ikeAttrs["lifetime"]; ok &amp;&amp; lifetimeAttr != nil </span><span class="cov0" title="0">{
                                                                if lifetimeInt, ok := lifetimeAttr.(types.Int64); ok &amp;&amp; !lifetimeInt.IsNull() </span><span class="cov0" title="0">{
                                                                        lifetime := int32(lifetimeInt.ValueInt64())
                                                                        // Lifetime field expects int32, not *int32
                                                                        ikeSettings.Lifetime = lifetime
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if encryptionAttr, ok := ikeAttrs["encryption"]; ok &amp;&amp; encryptionAttr != nil </span><span class="cov0" title="0">{
                                                                if encryptionStr, ok := encryptionAttr.(types.String); ok &amp;&amp; !encryptionStr.IsNull() </span><span class="cov0" title="0">{
                                                                        encryption := encryptionStr.ValueString()
                                                                        ikeSettings.Encryption = &amp;encryption
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if hashAttr, ok := ikeAttrs["hash"]; ok &amp;&amp; hashAttr != nil </span><span class="cov0" title="0">{
                                                                if hashStr, ok := hashAttr.(types.String); ok &amp;&amp; !hashStr.IsNull() </span><span class="cov0" title="0">{
                                                                        hash := hashStr.ValueString()
                                                                        ikeSettings.Hash = &amp;hash
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dhGroupAttr, ok := ikeAttrs["dh_group"]; ok &amp;&amp; dhGroupAttr != nil </span><span class="cov0" title="0">{
                                                                if dhGroupStr, ok := dhGroupAttr.(types.String); ok &amp;&amp; !dhGroupStr.IsNull() </span><span class="cov0" title="0">{
                                                                        dhGroup := dhGroupStr.ValueString()
                                                                        ikeSettings.DHGroup = &amp;dhGroup
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dpdActionAttr, ok := ikeAttrs["dpd_action"]; ok &amp;&amp; dpdActionAttr != nil </span><span class="cov0" title="0">{
                                                                if dpdActionStr, ok := dpdActionAttr.(types.String); ok &amp;&amp; !dpdActionStr.IsNull() </span><span class="cov0" title="0">{
                                                                        dpdAction := dpdActionStr.ValueString()
                                                                        ikeSettings.DPDAction = &amp;dpdAction
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dpdIntervalAttr, ok := ikeAttrs["dpd_interval"]; ok &amp;&amp; dpdIntervalAttr != nil </span><span class="cov0" title="0">{
                                                                if dpdIntervalInt, ok := dpdIntervalAttr.(types.Int64); ok &amp;&amp; !dpdIntervalInt.IsNull() </span><span class="cov0" title="0">{
                                                                        dpdInterval := int32(dpdIntervalInt.ValueInt64())
                                                                        // DPDInterval field expects int32, not *int32
                                                                        ikeSettings.DPDInterval = dpdInterval
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dpdTimeoutAttr, ok := ikeAttrs["dpd_timeout"]; ok &amp;&amp; dpdTimeoutAttr != nil </span><span class="cov0" title="0">{
                                                                if dpdTimeoutInt, ok := dpdTimeoutAttr.(types.Int64); ok &amp;&amp; !dpdTimeoutInt.IsNull() </span><span class="cov0" title="0">{
                                                                        dpdTimeout := int32(dpdTimeoutInt.ValueInt64())
                                                                        // DPDTimeout field expects int32, not *int32
                                                                        ikeSettings.DPDTimeout = dpdTimeout
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">vpnClientSettings.IKE = ikeSettings</span>
                                                }
                                        }
                                }

                                // Extract ESP settings
                                <span class="cov0" title="0">if espAttr, ok := vpnClientAttrs["esp"]; ok &amp;&amp; espAttr != nil </span><span class="cov0" title="0">{
                                        if espObj, ok := espAttr.(types.Object); ok &amp;&amp; !espObj.IsNull() </span><span class="cov0" title="0">{
                                                espObjValue, diags := espObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        espAttrs := espObjValue.Attributes()
                                                        espSettings := &amp;sdktypes.ESPSettings{}

                                                        if lifetimeAttr, ok := espAttrs["lifetime"]; ok &amp;&amp; lifetimeAttr != nil </span><span class="cov0" title="0">{
                                                                if lifetimeInt, ok := lifetimeAttr.(types.Int64); ok &amp;&amp; !lifetimeInt.IsNull() </span><span class="cov0" title="0">{
                                                                        lifetime := int32(lifetimeInt.ValueInt64())
                                                                        // Lifetime field expects int32, not *int32
                                                                        espSettings.Lifetime = lifetime
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if encryptionAttr, ok := espAttrs["encryption"]; ok &amp;&amp; encryptionAttr != nil </span><span class="cov0" title="0">{
                                                                if encryptionStr, ok := encryptionAttr.(types.String); ok &amp;&amp; !encryptionStr.IsNull() </span><span class="cov0" title="0">{
                                                                        encryption := encryptionStr.ValueString()
                                                                        espSettings.Encryption = &amp;encryption
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if hashAttr, ok := espAttrs["hash"]; ok &amp;&amp; hashAttr != nil </span><span class="cov0" title="0">{
                                                                if hashStr, ok := hashAttr.(types.String); ok &amp;&amp; !hashStr.IsNull() </span><span class="cov0" title="0">{
                                                                        hash := hashStr.ValueString()
                                                                        espSettings.Hash = &amp;hash
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if pfsAttr, ok := espAttrs["pfs"]; ok &amp;&amp; pfsAttr != nil </span><span class="cov0" title="0">{
                                                                if pfsStr, ok := pfsAttr.(types.String); ok &amp;&amp; !pfsStr.IsNull() </span><span class="cov0" title="0">{
                                                                        pfs := pfsStr.ValueString()
                                                                        espSettings.PFS = &amp;pfs
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">vpnClientSettings.ESP = espSettings</span>
                                                }
                                        }
                                }

                                // Extract PSK settings
                                <span class="cov0" title="0">if pskAttr, ok := vpnClientAttrs["psk"]; ok &amp;&amp; pskAttr != nil </span><span class="cov0" title="0">{
                                        if pskObj, ok := pskAttr.(types.Object); ok &amp;&amp; !pskObj.IsNull() </span><span class="cov0" title="0">{
                                                pskObjValue, diags := pskObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        pskAttrs := pskObjValue.Attributes()
                                                        pskSettings := &amp;sdktypes.PSKSettings{}

                                                        if cloudSiteAttr, ok := pskAttrs["cloud_site"]; ok &amp;&amp; cloudSiteAttr != nil </span><span class="cov0" title="0">{
                                                                if cloudSiteStr, ok := cloudSiteAttr.(types.String); ok &amp;&amp; !cloudSiteStr.IsNull() </span><span class="cov0" title="0">{
                                                                        cloudSite := cloudSiteStr.ValueString()
                                                                        pskSettings.CloudSite = &amp;cloudSite
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if onPremSiteAttr, ok := pskAttrs["on_prem_site"]; ok &amp;&amp; onPremSiteAttr != nil </span><span class="cov0" title="0">{
                                                                if onPremSiteStr, ok := onPremSiteAttr.(types.String); ok &amp;&amp; !onPremSiteStr.IsNull() </span><span class="cov0" title="0">{
                                                                        onPremSite := onPremSiteStr.ValueString()
                                                                        pskSettings.OnPremSite = &amp;onPremSite
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if secretAttr, ok := pskAttrs["secret"]; ok &amp;&amp; secretAttr != nil </span><span class="cov0" title="0">{
                                                                if secretStr, ok := secretAttr.(types.String); ok &amp;&amp; !secretStr.IsNull() </span><span class="cov0" title="0">{
                                                                        secret := secretStr.ValueString()
                                                                        pskSettings.Secret = &amp;secret
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">vpnClientSettings.PSK = pskSettings</span>
                                                }
                                        }
                                }

                                // Extract peer client public IP
                                <span class="cov0" title="0">if peerIPAttr, ok := vpnClientAttrs["peer_client_public_ip"]; ok &amp;&amp; peerIPAttr != nil </span><span class="cov0" title="0">{
                                        if peerIPStr, ok := peerIPAttr.(types.String); ok &amp;&amp; !peerIPStr.IsNull() </span><span class="cov0" title="0">{
                                                peerIP := peerIPStr.ValueString()
                                                vpnClientSettings.PeerClientPublicIP = &amp;peerIP
                                        }</span>
                                }
                        }
                }
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.VPNTunnelRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.VPNTunnelPropertiesRequest{
                        VPNType:           &amp;vpnType,
                        VPNClientProtocol: &amp;protocol,
                        IPConfigurations:  ipConfig,
                        VPNClientSettings: vpnClientSettings,
                        BillingPlan: &amp;sdktypes.BillingPeriodResource{
                                BillingPeriod: billingPeriod,
                        },
                },
        }

        // Create the VPN tunnel using the SDK
        response, err := r.client.Client.FromNetwork().VPNTunnels().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPN tunnel",
                        fmt.Sprintf("Unable to create VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create VPN tunnel"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPN tunnel created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPN Tunnel to be active before returning
        // This ensures Terraform doesn't proceed to create dependent resources until VPN Tunnel is ready
        <span class="cov0" title="0">tunnelID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPNTunnels().Get(ctx, projectID, tunnelID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPN Tunnel to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VPNTunnel", tunnelID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPN Tunnel Not Active",
                        fmt.Sprintf("VPN tunnel was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPN Tunnel resource", map[string]interface{}{
                "vpntunnel_id":   data.Id.ValueString(),
                "vpntunnel_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNTunnelResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VPNTunnelResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        tunnelID := data.Id.ValueString()

        if projectID == "" || tunnelID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Tunnel ID are required to read the VPN tunnel",
                )
                return
        }</span>

        // Get VPN tunnel details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPNTunnels().Get(ctx, projectID, tunnelID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPN tunnel",
                        fmt.Sprintf("Unable to read VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read VPN tunnel"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                tunnel := response.Data

                if tunnel.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*tunnel.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if tunnel.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*tunnel.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if tunnel.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*tunnel.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if tunnel.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(tunnel.Metadata.LocationResponse.Value)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(tunnel.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(tunnel.Metadata.Tags))
                        for i, tag := range tunnel.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }

                // Note: Properties are complex nested structures - for now, we preserve the existing state
                // A full implementation would reconstruct the properties object from the API response
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNTunnelResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VPNTunnelResourceModel
        var state VPNTunnelResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        tunnelID := state.Id.ValueString()

        if projectID == "" || tunnelID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Tunnel ID are required to update the VPN tunnel",
                )
                return
        }</span>

        // Get current VPN tunnel details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPNTunnels().Get(ctx, projectID, tunnelID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPN tunnel",
                        fmt.Sprintf("Unable to get current VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPN Tunnel Not Found",
                        "VPN tunnel not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if VPN tunnel is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update VPN Tunnel",
                        "Cannot update VPN tunnel while it is in 'InCreation' state. Please wait until the VPN tunnel is fully created.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for VPN tunnel",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated, properties must remain unchanged
        <span class="cov0" title="0">updateRequest := sdktypes.VPNTunnelRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.VPNTunnelPropertiesRequest{
                        // Properties cannot be updated - use current values
                        VPNType:           current.Properties.VPNType,
                        VPNClientProtocol: current.Properties.VPNClientProtocol,
                        IPConfigurations:  current.Properties.IPConfigurations,
                        VPNClientSettings: current.Properties.VPNClientSettings,
                        BillingPlan:       current.Properties.BillingPlan,
                },
        }

        // Update the VPN tunnel using the SDK
        response, err := r.client.Client.FromNetwork().VPNTunnels().Update(ctx, projectID, tunnelID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPN tunnel",
                        fmt.Sprintf("Unable to update VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update VPN tunnel"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNTunnelResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VPNTunnelResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        tunnelID := data.Id.ValueString()

        if projectID == "" || tunnelID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Tunnel ID are required to delete the VPN tunnel",
                )
                return
        }</span>

        // Delete the VPN tunnel using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().VPNTunnels().Delete(ctx, projectID, tunnelID, nil)
                }</span>,
                ExtractSDKError,
                "VPNTunnel",
                tunnelID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPN tunnel",
                        fmt.Sprintf("Unable to delete VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPN Tunnel resource", map[string]interface{}{
                "vpntunnel_id": tunnelID,
        })</span>
}

func (r *VPNTunnelResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright (c) HashiCorp, Inc.

package main

import (
        "context"
        "flag"
        "log"

        "terraform-provider-arubacloud/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/providerserver"
)

var (
        // these will be set by the goreleaser configuration
        // to appropriate values for the compiled binary.
        version string = "dev"

        // goreleaser can pass other information to the main package, such as the specific commit
        // https://goreleaser.com/cookbooks/using-main.version/
)

func main() <span class="cov0" title="0">{
        var debug bool

        flag.BoolVar(&amp;debug, "debug", false, "set to true to run the provider with support for debuggers like delve")
        flag.Parse()

        opts := providerserver.ServeOpts{
                Address: "registry.terraform.io/hashicorp/arubacloud",
                Debug:   debug,
        }

        err := providerserver.Serve(context.Background(), provider.New(version), opts)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
