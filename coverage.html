
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">terraform-provider-arubacloud/internal/provider/backup_data_source.go (82.4%)</option>
				
				<option value="file1">terraform-provider-arubacloud/internal/provider/backup_resource.go (1.4%)</option>
				
				<option value="file2">terraform-provider-arubacloud/internal/provider/blockstorage_data_source.go (88.9%)</option>
				
				<option value="file3">terraform-provider-arubacloud/internal/provider/blockstorage_resource.go (1.0%)</option>
				
				<option value="file4">terraform-provider-arubacloud/internal/provider/cloudserver_data_source.go (90.0%)</option>
				
				<option value="file5">terraform-provider-arubacloud/internal/provider/cloudserver_resource.go (1.0%)</option>
				
				<option value="file6">terraform-provider-arubacloud/internal/provider/containerregistry_data_source.go (89.7%)</option>
				
				<option value="file7">terraform-provider-arubacloud/internal/provider/containerregistry_resource.go (0.9%)</option>
				
				<option value="file8">terraform-provider-arubacloud/internal/provider/database_data_source.go (84.2%)</option>
				
				<option value="file9">terraform-provider-arubacloud/internal/provider/database_resource.go (2.4%)</option>
				
				<option value="file10">terraform-provider-arubacloud/internal/provider/databasebackup_data_source.go (82.4%)</option>
				
				<option value="file11">terraform-provider-arubacloud/internal/provider/databasebackup_resource.go (2.2%)</option>
				
				<option value="file12">terraform-provider-arubacloud/internal/provider/databasegrant_data_source.go (84.2%)</option>
				
				<option value="file13">terraform-provider-arubacloud/internal/provider/databasegrant_resource.go (2.5%)</option>
				
				<option value="file14">terraform-provider-arubacloud/internal/provider/dbaas_data_source.go (90.9%)</option>
				
				<option value="file15">terraform-provider-arubacloud/internal/provider/dbaas_resource.go (0.7%)</option>
				
				<option value="file16">terraform-provider-arubacloud/internal/provider/dbaasuser_data_source.go (83.3%)</option>
				
				<option value="file17">terraform-provider-arubacloud/internal/provider/dbaasuser_resource.go (2.2%)</option>
				
				<option value="file18">terraform-provider-arubacloud/internal/provider/elasticip_data_source.go (86.4%)</option>
				
				<option value="file19">terraform-provider-arubacloud/internal/provider/elasticip_resource.go (1.2%)</option>
				
				<option value="file20">terraform-provider-arubacloud/internal/provider/error_helper.go (0.0%)</option>
				
				<option value="file21">terraform-provider-arubacloud/internal/provider/kaas_data_source.go (91.4%)</option>
				
				<option value="file22">terraform-provider-arubacloud/internal/provider/kaas_resource.go (0.6%)</option>
				
				<option value="file23">terraform-provider-arubacloud/internal/provider/keypair_data_source.go (85.7%)</option>
				
				<option value="file24">terraform-provider-arubacloud/internal/provider/keypair_resource.go (1.7%)</option>
				
				<option value="file25">terraform-provider-arubacloud/internal/provider/kms_data_source.go (84.2%)</option>
				
				<option value="file26">terraform-provider-arubacloud/internal/provider/kms_resource.go (1.6%)</option>
				
				<option value="file27">terraform-provider-arubacloud/internal/provider/project_data_source.go (84.2%)</option>
				
				<option value="file28">terraform-provider-arubacloud/internal/provider/project_resource.go (47.1%)</option>
				
				<option value="file29">terraform-provider-arubacloud/internal/provider/provider.go (71.4%)</option>
				
				<option value="file30">terraform-provider-arubacloud/internal/provider/resource_wait.go (16.7%)</option>
				
				<option value="file31">terraform-provider-arubacloud/internal/provider/restore_data_source.go (85.7%)</option>
				
				<option value="file32">terraform-provider-arubacloud/internal/provider/restore_resource.go (1.5%)</option>
				
				<option value="file33">terraform-provider-arubacloud/internal/provider/schedulejob_data_source.go (84.2%)</option>
				
				<option value="file34">terraform-provider-arubacloud/internal/provider/schedulejob_resource.go (0.9%)</option>
				
				<option value="file35">terraform-provider-arubacloud/internal/provider/securitygroup_data_source.go (85.7%)</option>
				
				<option value="file36">terraform-provider-arubacloud/internal/provider/securitygroup_resource.go (1.5%)</option>
				
				<option value="file37">terraform-provider-arubacloud/internal/provider/securityrule_data_source.go (89.3%)</option>
				
				<option value="file38">terraform-provider-arubacloud/internal/provider/securityrule_resource.go (0.7%)</option>
				
				<option value="file39">terraform-provider-arubacloud/internal/provider/snapshot_data_source.go (85.7%)</option>
				
				<option value="file40">terraform-provider-arubacloud/internal/provider/snapshot_resource.go (1.2%)</option>
				
				<option value="file41">terraform-provider-arubacloud/internal/provider/subnet_data_source.go (90.6%)</option>
				
				<option value="file42">terraform-provider-arubacloud/internal/provider/subnet_resource.go (0.7%)</option>
				
				<option value="file43">terraform-provider-arubacloud/internal/provider/vpc_data_source.go (85.0%)</option>
				
				<option value="file44">terraform-provider-arubacloud/internal/provider/vpc_resource.go (1.3%)</option>
				
				<option value="file45">terraform-provider-arubacloud/internal/provider/vpcpeering_data_source.go (82.4%)</option>
				
				<option value="file46">terraform-provider-arubacloud/internal/provider/vpcpeering_resource.go (1.7%)</option>
				
				<option value="file47">terraform-provider-arubacloud/internal/provider/vpcpeeringroute_data_source.go (82.4%)</option>
				
				<option value="file48">terraform-provider-arubacloud/internal/provider/vpcpeeringroute_resource.go (1.7%)</option>
				
				<option value="file49">terraform-provider-arubacloud/internal/provider/vpnroute_data_source.go (84.2%)</option>
				
				<option value="file50">terraform-provider-arubacloud/internal/provider/vpnroute_resource.go (1.4%)</option>
				
				<option value="file51">terraform-provider-arubacloud/internal/provider/vpntunnel_data_source.go (84.2%)</option>
				
				<option value="file52">terraform-provider-arubacloud/internal/provider/vpntunnel_resource.go (0.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;BackupDataSource{}

func NewBackupDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;BackupDataSource{}
}</span>

type BackupDataSource struct {
        client *ArubaCloudClient
}

type BackupDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        Type          types.String `tfsdk:"type"`
        VolumeID      types.String `tfsdk:"volume_id"`
        RetentionDays types.Int64  `tfsdk:"retention_days"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

func (d *BackupDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_backup"
}</span>

func (d *BackupDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Backup data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Backup identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Backup name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Backup location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the backup resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this backup belongs to",
                                Computed:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Type of backup (Full, Incremental)",
                                Computed:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "Volume ID for the backup",
                                Computed:            true,
                        },
                        "retention_days": schema.Int64Attribute{
                                MarkdownDescription: "Retention days for the backup",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *BackupDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *BackupDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data BackupDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-backup")
        tflog.Trace(ctx, "read a Backup data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type BackupResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        Type          types.String `tfsdk:"type"`
        VolumeID      types.String `tfsdk:"volume_id"`
        RetentionDays types.Int64  `tfsdk:"retention_days"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

type BackupResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;BackupResource{}
var _ resource.ResourceWithImportState = &amp;BackupResource{}

func NewBackupResource() resource.Resource <span class="cov8" title="1">{
        return &amp;BackupResource{}
}</span>

func (r *BackupResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_backup"
}</span>

func (r *BackupResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Backup resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Backup identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Backup URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Backup name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Backup location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the backup resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this backup belongs to",
                                Required:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Type of backup (Full, Incremental)",
                                Required:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "Volume ID for the backup",
                                Required:            true,
                        },
                        "retention_days": schema.Int64Attribute{
                                MarkdownDescription: "Retention days for the backup",
                                Optional:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *BackupResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *BackupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data BackupResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        volumeID := data.VolumeID.ValueString()

        if projectID == "" || volumeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Volume ID are required to create a backup",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Get the volume details to get the full URI
        <span class="cov0" title="0">volumeResponse, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting volume details",
                        fmt.Sprintf("Unable to get volume details: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if volumeResponse == nil || volumeResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Volume Not Found",
                        "Volume not found",
                )
                return
        }</span>

        <span class="cov0" title="0">volumeURI := ""
        if volumeResponse.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                volumeURI = *volumeResponse.Data.Metadata.URI
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid Volume Response",
                        "Volume URI not found in response",
                )
                return
        }</span>

        // Build the backup create request
        <span class="cov0" title="0">createRequest := sdktypes.StorageBackupRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.StorageBackupPropertiesRequest{
                        StorageBackupType: sdktypes.StorageBackupType(data.Type.ValueString()),
                        Origin: sdktypes.ReferenceResource{
                                URI: volumeURI,
                        },
                },
        }

        // Add optional fields
        if !data.RetentionDays.IsNull() &amp;&amp; !data.RetentionDays.IsUnknown() </span><span class="cov0" title="0">{
                retentionDays := int(data.RetentionDays.ValueInt64())
                createRequest.Properties.RetentionDays = &amp;retentionDays
        }</span>

        <span class="cov0" title="0">if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                billingPeriod := data.BillingPeriod.ValueString()
                createRequest.Properties.BillingPeriod = &amp;billingPeriod
        }</span>

        // Create the backup using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Backups().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating backup",
                        fmt.Sprintf("Unable to create backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create backup", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Backup created but no data returned from API",
                )
                return
        }</span>

        // Wait for Backup to be active before returning
        // This ensures Terraform doesn't proceed until Backup is ready
        <span class="cov0" title="0">backupID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Backup to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Backup", backupID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Backup Not Active",
                        fmt.Sprintf("Backup was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Backup resource", map[string]interface{}{
                "backup_id":   data.Id.ValueString(),
                "backup_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BackupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data BackupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to read the backup",
                )
                return
        }</span>

        // Get backup details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading backup",
                        fmt.Sprintf("Unable to read backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "backup_id":  backupID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read backup", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                backup := response.Data

                if backup.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*backup.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*backup.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if backup.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*backup.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(backup.Metadata.LocationResponse.Value)
                }</span>
                // Note: StorageBackupType field may not be available in the response
                // If type is needed, it should be stored from the create request
                <span class="cov0" title="0">if backup.Properties.Origin.URI != "" </span><span class="cov0" title="0">{
                        // Extract Volume ID from URI
                        parts := strings.Split(backup.Properties.Origin.URI, "/")
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                data.VolumeID = types.StringValue(parts[len(parts)-1])
                        }</span>
                }
                <span class="cov0" title="0">if backup.Properties.RetentionDays != nil </span><span class="cov0" title="0">{
                        data.RetentionDays = types.Int64Value(int64(*backup.Properties.RetentionDays))
                }</span>
                <span class="cov0" title="0">if backup.Properties.BillingPeriod != nil </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(*backup.Properties.BillingPeriod)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(backup.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(backup.Metadata.Tags))
                        for i, tag := range backup.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BackupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data BackupResourceModel
        var state BackupResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        backupID := state.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to update the backup",
                )
                return
        }</span>

        // Get current backup details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current backup",
                        fmt.Sprintf("Unable to get current backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Backup Not Found",
                        "Backup not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for backup",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated
        <span class="cov0" title="0">updateRequest := sdktypes.StorageBackupRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.StorageBackupPropertiesRequest{
                        // Properties cannot be updated - use current values
                        // Note: StorageBackupType may not be available in result type
                        // If needed, preserve from state or use default
                        Origin:        current.Properties.Origin,
                        RetentionDays: current.Properties.RetentionDays,
                        BillingPeriod: current.Properties.BillingPeriod,
                },
        }

        // Update the backup using the SDK
        response, err := r.client.Client.FromStorage().Backups().Update(ctx, projectID, backupID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating backup",
                        fmt.Sprintf("Unable to update backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "backup_id":  backupID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update backup", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Uri = state.Uri                     // Preserve URI from state
        data.VolumeID = state.VolumeID           // Immutable
        data.Type = state.Type                   // Immutable
        data.RetentionDays = state.RetentionDays // Immutable
        data.BillingPeriod = state.BillingPeriod // Immutable

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the backup to get the latest state including URI
                getResp, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if not in response
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BackupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data BackupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to delete the backup",
                )
                return
        }</span>

        // Delete the backup using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromStorage().Backups().Delete(ctx, projectID, backupID, nil)
                }</span>,
                ExtractSDKError,
                "Backup",
                backupID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting backup",
                        fmt.Sprintf("Unable to delete backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Backup resource", map[string]interface{}{
                "backup_id": backupID,
        })</span>
}

func (r *BackupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;BlockStorageDataSource{}

func NewBlockStorageDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;BlockStorageDataSource{}
}</span>

type BlockStorageDataSource struct {
        client *ArubaCloudClient
}

type BlockStorageDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Name          types.String `tfsdk:"name"`
        ProjectId     types.String `tfsdk:"project_id"`
        Location      types.String `tfsdk:"location"`
        SizeGB        types.Int64  `tfsdk:"size_gb"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Zone          types.String `tfsdk:"zone"`
        Type          types.String `tfsdk:"type"`
        Tags          types.List   `tfsdk:"tags"`
        SnapshotId    types.String `tfsdk:"snapshot_id"`
        Bootable      types.Bool   `tfsdk:"bootable"`
        Image         types.String `tfsdk:"image"`
}

type BlockStoragePropertiesModel struct {
        SizeGB        types.Int64  `tfsdk:"size_gb"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Zone          types.String `tfsdk:"zone"`
        Type          types.String `tfsdk:"type"`
        SnapshotId    types.String `tfsdk:"snapshot_id"`
        Bootable      types.Bool   `tfsdk:"bootable"`
        Image         types.String `tfsdk:"image"`
}

func (d *BlockStorageDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_blockstorage"
}</span>

func (d *BlockStorageDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Block Storage data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Block Storage identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Block Storage name",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Block Storage belongs to",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Location of the block storage",
                                Computed:            true,
                        },
                        "size_gb": schema.Int64Attribute{
                                MarkdownDescription: "Size of the block storage in GB",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period of the block storage",
                                Computed:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone of the block storage",
                                Computed:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Type of block storage (Standard, Performance)",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the block storage",
                                Computed:            true,
                        },
                        "snapshot_id": schema.StringAttribute{
                                MarkdownDescription: "Snapshot ID for the block storage",
                                Computed:            true,
                        },
                        "bootable": schema.BoolAttribute{
                                MarkdownDescription: "Whether the block storage is bootable",
                                Computed:            true,
                        },
                        "image": schema.StringAttribute{
                                MarkdownDescription: "Image for the block storage",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *BlockStorageDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *BlockStorageDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data BlockStorageDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Name = types.StringValue("example-blockstorage")
        data.ProjectId = types.StringValue("68398923fb2cb026400d4d31")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.SizeGB = types.Int64Value(50)
        data.BillingPeriod = types.StringValue("Hour")
        data.Zone = types.StringValue("ITBG-1")
        data.Type = types.StringValue("Standard")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("storage"),
                types.StringValue("data"),
                types.StringValue("test"),
        })
        data.SnapshotId = types.StringNull()
        data.Bootable = types.BoolValue(false)
        data.Image = types.StringNull()

        tflog.Trace(ctx, "read a Block Storage data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;BlockStorageResource{}
var _ resource.ResourceWithImportState = &amp;BlockStorageResource{}

func NewBlockStorageResource() resource.Resource <span class="cov8" title="1">{
        return &amp;BlockStorageResource{}
}</span>

type BlockStorageResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        ProjectID     types.String `tfsdk:"project_id"`
        Location      types.String `tfsdk:"location"`
        SizeGB        types.Int64  `tfsdk:"size_gb"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Zone          types.String `tfsdk:"zone"`
        Type          types.String `tfsdk:"type"`
        Bootable      types.Bool   `tfsdk:"bootable"`
        Image         types.String `tfsdk:"image"`
        Tags          types.List   `tfsdk:"tags"`
}

type BlockStorageResource struct {
        client *ArubaCloudClient
}

func (r *BlockStorageResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_blockstorage"
}</span>

func (r *BlockStorageResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Block Storage resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Block Storage identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Block Storage URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Block Storage name",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Block Storage belongs to",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Block Storage location/region",
                                Required:            true,
                        },
                        "size_gb": schema.Int64Attribute{
                                MarkdownDescription: "Size of the block storage in GB",
                                Required:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Required:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone where blockstorage will be created. If not specified, the block storage will be regional (available across all zones in the location). If specified, the block storage will be zonal (tied to a specific zone).",
                                Optional:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Type of block storage (Standard, Performance)",
                                Required:            true,
                        },
                        "bootable": schema.BoolAttribute{
                                MarkdownDescription: "Whether the block storage is bootable. Must be set to true along with image to create a bootable disk.",
                                Optional:            true,
                        },
                        "image": schema.StringAttribute{
                                MarkdownDescription: "Image ID for bootable block storage. Required when bootable is true. See [available images](https://api.arubacloud.com/docs/metadata/#cloud-server-bootvolume) for a list of supported image IDs.",
                                Optional:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the block storage",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *BlockStorageResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *BlockStorageResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data BlockStorageResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create block storage",
                )
                return
        }</span>

        // Validate bootable and image
        <span class="cov0" title="0">if !data.Bootable.IsNull() &amp;&amp; !data.Bootable.IsUnknown() &amp;&amp; data.Bootable.ValueBool() </span><span class="cov0" title="0">{
                if data.Image.IsNull() || data.Image.IsUnknown() || data.Image.ValueString() == "" </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Missing Image",
                                "Image is required when bootable is set to true",
                        )
                        return
                }</span>
        }

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.BlockStorageRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.BlockStoragePropertiesRequest{
                        SizeGB:        int(data.SizeGB.ValueInt64()),
                        BillingPeriod: data.BillingPeriod.ValueString(),
                        Type:          sdktypes.BlockStorageType(data.Type.ValueString()),
                },
        }

        // Add zone if provided
        if !data.Zone.IsNull() &amp;&amp; !data.Zone.IsUnknown() </span><span class="cov0" title="0">{
                zone := data.Zone.ValueString()
                createRequest.Properties.Zone = &amp;zone
        }</span>

        // Add bootable and image if provided
        <span class="cov0" title="0">if !data.Bootable.IsNull() &amp;&amp; !data.Bootable.IsUnknown() </span><span class="cov0" title="0">{
                bootable := data.Bootable.ValueBool()
                createRequest.Properties.Bootable = &amp;bootable
        }</span>
        <span class="cov0" title="0">if !data.Image.IsNull() &amp;&amp; !data.Image.IsUnknown() </span><span class="cov0" title="0">{
                image := data.Image.ValueString()
                createRequest.Properties.Image = &amp;image
        }</span>

        // Create the block storage using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Volumes().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating block storage",
                        fmt.Sprintf("Unable to create block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create block storage", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(response.Data.Properties.Zone)
                }</span> else<span class="cov0" title="0"> {
                        data.Zone = types.StringNull()
                }</span>
                // Populate bootable and image from API response
                // Only set if API provides a value, otherwise preserve null from plan
                <span class="cov0" title="0">if response.Data.Properties.Bootable != nil </span><span class="cov0" title="0">{
                        data.Bootable = types.BoolValue(*response.Data.Properties.Bootable)
                }</span> else<span class="cov0" title="0"> {
                        // Keep as null if API doesn't provide a value (preserves plan state)
                        data.Bootable = types.BoolNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Properties.Image != nil </span><span class="cov0" title="0">{
                        data.Image = types.StringValue(*response.Data.Properties.Image)
                }</span> else<span class="cov0" title="0"> {
                        data.Image = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Block storage created but no data returned from API",
                )
                return
        }</span>

        // Wait for Block Storage to be active before returning (Volume is referenced by Snapshot, CloudServer)
        // This ensures Terraform doesn't proceed to create dependent resources until BlockStorage is ready
        <span class="cov0" title="0">volumeID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Block Storage to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "BlockStorage", volumeID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Block Storage Not Active",
                        fmt.Sprintf("Block storage was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Read the Block Storage again to ensure URI and other fields are properly set from metadata
        <span class="cov0" title="0">getResp, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(getResp.Data.Properties.Zone)
                }</span> else<span class="cov0" title="0"> {
                        data.Zone = types.StringNull()
                }</span>
                // Update bootable and image from re-read
                <span class="cov0" title="0">if getResp.Data.Properties.Bootable != nil </span><span class="cov0" title="0">{
                        data.Bootable = types.BoolValue(*getResp.Data.Properties.Bootable)
                }</span> else<span class="cov0" title="0"> {
                        data.Bootable = types.BoolNull()
                }</span>
                <span class="cov0" title="0">if getResp.Data.Properties.Image != nil </span><span class="cov0" title="0">{
                        data.Image = types.StringValue(*getResp.Data.Properties.Image)
                }</span> else<span class="cov0" title="0"> {
                        data.Image = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Block Storage after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Block Storage resource", map[string]interface{}{
                "blockstorage_id":   data.Id.ValueString(),
                "blockstorage_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BlockStorageResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data BlockStorageResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        volumeID := data.Id.ValueString()

        // If ID is unknown or null, check if this is a new resource (no state) or existing resource (state exists but ID missing)
        // For new resources (during plan), we can return early
        // For existing resources, we need the ID to read - if it's missing, that's an error
        if data.Id.IsUnknown() || data.Id.IsNull() || volumeID == "" </span><span class="cov0" title="0">{
                // Check if we have any other state data that indicates this is an existing resource
                // If name is set in state, this is likely an existing resource with missing ID (error case)
                if !data.Name.IsUnknown() &amp;&amp; !data.Name.IsNull() &amp;&amp; data.Name.ValueString() != "" </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Block Storage exists in state but ID is missing - this indicates a state corruption issue")
                        resp.Diagnostics.AddError(
                                "Missing Block Storage ID",
                                "Block Storage ID is required to read the block storage. The resource exists in state but the ID is missing. This may indicate a state corruption issue. Try running 'terraform refresh' or 'terraform import arubacloud_blockstorage.test &lt;volume_id&gt;'.",
                        )
                        return
                }</span>
                // Otherwise, this is likely a new resource during plan - return early
                <span class="cov0" title="0">tflog.Info(ctx, "Block Storage ID is unknown or null during read, skipping API call (likely new resource).")
                return</span> // Do not error, as this is expected during plan for new resources
        }

        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                // Check if ProjectID is unknown (new resource) vs missing (error)
                if data.ProjectID.IsUnknown() || data.ProjectID.IsNull() </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Block Storage Project ID is unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to read the block storage",
                )
                return</span>
        }

        // Get block storage details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading block storage",
                        fmt.Sprintf("Unable to read block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "volume_id":  volumeID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read block storage", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                volume := response.Data

                if volume.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*volume.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if volume.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*volume.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If API doesn't return URI, try to preserve from state, or construct it from ID
                        if !data.Uri.IsNull() &amp;&amp; !data.Uri.IsUnknown() </span>{<span class="cov0" title="0">
                                // Preserve URI from state if available
                                // (data.Uri already has the state value, so no change needed)
                        }</span> else<span class="cov0" title="0"> if volume.Metadata.ID != nil </span><span class="cov0" title="0">{
                                // Construct URI from ID if we have it
                                uri := fmt.Sprintf("/projects/%s/providers/Aruba.Storage/volumes/%s", projectID, *volume.Metadata.ID)
                                data.Uri = types.StringValue(uri)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                }
                <span class="cov0" title="0">if volume.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*volume.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if volume.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(volume.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">data.SizeGB = types.Int64Value(int64(volume.Properties.SizeGB))
                data.Type = types.StringValue(string(volume.Properties.Type))
                // Zone: if empty, it's regional storage; if set, it's zonal storage
                if volume.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(volume.Properties.Zone)
                }</span> else<span class="cov0" title="0"> {
                        // Regional storage - zone is null/empty
                        data.Zone = types.StringNull()
                }</span>

                // Populate bootable and image from API response
                // Only set if API provides a value, otherwise preserve null from plan
                <span class="cov0" title="0">if volume.Properties.Bootable != nil </span><span class="cov0" title="0">{
                        data.Bootable = types.BoolValue(*volume.Properties.Bootable)
                }</span> else<span class="cov0" title="0"> {
                        // Keep as null if API doesn't provide a value (preserves plan state)
                        data.Bootable = types.BoolNull()
                }</span>
                <span class="cov0" title="0">if volume.Properties.Image != nil </span><span class="cov0" title="0">{
                        data.Image = types.StringValue(*volume.Properties.Image)
                }</span> else<span class="cov0" title="0"> {
                        data.Image = types.StringNull()
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(volume.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(volume.Metadata.Tags))
                        for i, tag := range volume.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BlockStorageResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data BlockStorageResourceModel
        var state BlockStorageResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        volumeID := state.Id.ValueString()

        if projectID == "" || volumeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Volume ID are required to update the block storage",
                )
                return
        }</span>

        // Get current block storage details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current block storage",
                        fmt.Sprintf("Unable to get current block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Block Storage Not Found",
                        "Block storage not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if the volume status allows updates
        if current.Status.State != nil </span><span class="cov0" title="0">{
                status := *current.Status.State
                if status != "Used" &amp;&amp; status != "NotUsed" </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Cannot Update",
                                fmt.Sprintf("Cannot update block storage with status '%s'. Block storage can only be updated when status is 'Used' or 'NotUsed'", status),
                        )
                        return
                }</span>
        }

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for block storage",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Handle zone
        <span class="cov0" title="0">var zone *string
        if current.Properties.Zone != "" </span><span class="cov0" title="0">{
                zone = &amp;current.Properties.Zone
        }</span>

        // Build the update request
        // Use size from plan (data) if provided, otherwise preserve current size
        <span class="cov0" title="0">sizeGB := current.Properties.SizeGB
        if !data.SizeGB.IsNull() &amp;&amp; !data.SizeGB.IsUnknown() </span><span class="cov0" title="0">{
                sizeGB = int(data.SizeGB.ValueInt64())
        }</span>

        // Use billing period from plan (data) if provided, otherwise preserve current
        <span class="cov0" title="0">billingPeriod := current.Properties.BillingPeriod
        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                billingPeriod = data.BillingPeriod.ValueString()
        }</span>

        <span class="cov0" title="0">updateRequest := sdktypes.BlockStorageRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.BlockStoragePropertiesRequest{
                        SizeGB:        sizeGB,
                        BillingPeriod: billingPeriod,
                        Zone:          zone,
                        Type:          current.Properties.Type,
                },
        }

        // Update the block storage using the SDK
        response, err := r.client.Client.FromStorage().Volumes().Update(ctx, projectID, volumeID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating block storage",
                        fmt.Sprintf("Unable to update block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "volume_id":  volumeID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update block storage", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Wait for Block Storage update to complete before returning
        // This ensures Terraform doesn't proceed until the update is fully applied
        <span class="cov0" title="0">checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Block Storage to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "BlockStorage", volumeID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Block Storage Update Not Complete",
                        fmt.Sprintf("Block storage update was initiated but did not complete within the timeout period: %s", err),
                )
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Uri = state.Uri   // Preserve URI from state
        data.Zone = state.Zone // Preserve zone from state (immutable)

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = state.Uri // Fallback to state if not in response
                }</span>
                // Update zone from response (empty = regional, set = zonal)
                <span class="cov0" title="0">if response.Data.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(response.Data.Properties.Zone)
                }</span> else<span class="cov0" title="0"> {
                        data.Zone = types.StringNull() // Regional storage
                }</span>
                // Update size from response
                <span class="cov0" title="0">data.SizeGB = types.Int64Value(int64(response.Data.Properties.SizeGB))
                // Update billing period from response if available
                if response.Data.Properties.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(response.Data.Properties.BillingPeriod)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the resource to get the latest state after update
                getResp, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        // Update from the re-read response
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri
                        }</span>
                        <span class="cov0" title="0">if getResp.Data.Properties.Zone != "" </span><span class="cov0" title="0">{
                                data.Zone = types.StringValue(getResp.Data.Properties.Zone)
                        }</span> else<span class="cov0" title="0"> {
                                data.Zone = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">data.SizeGB = types.Int64Value(int64(getResp.Data.Properties.SizeGB))
                        if getResp.Data.Properties.BillingPeriod != "" </span><span class="cov0" title="0">{
                                data.BillingPeriod = types.StringValue(getResp.Data.Properties.BillingPeriod)
                        }</span> else<span class="cov0" title="0"> {
                                data.BillingPeriod = state.BillingPeriod
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                        data.Zone = state.Zone
                        data.SizeGB = state.SizeGB
                        data.BillingPeriod = state.BillingPeriod
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *BlockStorageResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data BlockStorageResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        volumeID := data.Id.ValueString()

        if projectID == "" || volumeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Volume ID are required to delete the block storage",
                )
                return
        }</span>

        // Delete the block storage using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromStorage().Volumes().Delete(ctx, projectID, volumeID, nil)
                }</span>,
                ExtractSDKError,
                "BlockStorage",
                volumeID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting block storage",
                        fmt.Sprintf("Unable to delete block storage: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Block Storage resource", map[string]interface{}{
                "volume_id": volumeID,
        })</span>
}

func (r *BlockStorageResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type CloudServerDataSourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        ProjectID types.String `tfsdk:"project_id"`
        Zone      types.String `tfsdk:"zone"`
        Tags      types.List   `tfsdk:"tags"`
        // Network fields (flattened from Network object)
        VpcUriRef            types.String `tfsdk:"vpc_uri_ref"`
        ElasticIpUriRef      types.String `tfsdk:"elastic_ip_uri_ref"`
        SubnetUriRefs        types.List   `tfsdk:"subnet_uri_refs"`
        SecurityGroupUriRefs types.List   `tfsdk:"securitygroup_uri_refs"`
        // Settings fields (flattened from Settings object)
        FlavorName    types.String `tfsdk:"flavor_name"`
        KeyPairUriRef types.String `tfsdk:"key_pair_uri_ref"`
        UserData      types.String `tfsdk:"user_data"`
        // Storage fields (flattened from Storage object)
        BootVolumeUriRef types.String `tfsdk:"boot_volume_uri_ref"`
}

type CloudServerDataSource struct {
        client *ArubaCloudClient
}

var _ datasource.DataSource = &amp;CloudServerDataSource{}

func NewCloudServerDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;CloudServerDataSource{}
}</span>

func (d *CloudServerDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_cloudserver"
}</span>

func (d *CloudServerDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "CloudServer data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "CloudServer identifier",
                                Required:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "CloudServer URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "CloudServer name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "CloudServer location",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "Project ID",
                                Computed:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Cloud Server",
                                Computed:            true,
                        },
                        "vpc_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "VPC URI reference",
                                Computed:            true,
                        },
                        "elastic_ip_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP URI reference",
                                Computed:            true,
                        },
                        "subnet_uri_refs": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of subnet URI references",
                                Computed:            true,
                        },
                        "securitygroup_uri_refs": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of security group URI references",
                                Computed:            true,
                        },
                        "flavor_name": schema.StringAttribute{
                                MarkdownDescription: "Flavor name (e.g., CSO4A8 for 4 CPU, 8GB RAM)",
                                Computed:            true,
                        },
                        "key_pair_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Key Pair URI reference",
                                Computed:            true,
                        },
                        "user_data": schema.StringAttribute{
                                MarkdownDescription: "Cloud-Init user data",
                                Computed:            true,
                        },
                        "boot_volume_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Boot volume URI reference",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *CloudServerDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected DataSource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *CloudServerDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data CloudServerDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Uri = types.StringValue("/v2/cloudservers/68398923fb2cb026400d4d31")
        data.Name = types.StringValue("example-cloudserver")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.ProjectID = types.StringValue("68398923fb2cb026400d4d31")
        data.Zone = types.StringValue("ITBG-1")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("compute"),
                types.StringValue("production"),
        })
        // Network fields
        data.VpcUriRef = types.StringValue("/v2/vpcs/vpc-68398923fb2cb026400d4d32")
        data.ElasticIpUriRef = types.StringValue("/v2/elasticips/eip-68398923fb2cb026400d4d33")
        data.SubnetUriRefs = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("/v2/subnets/subnet-68398923fb2cb026400d4d35"),
                types.StringValue("/v2/subnets/subnet-68398923fb2cb026400d4d36"),
        })
        data.SecurityGroupUriRefs = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("/v2/securitygroups/sg-68398923fb2cb026400d4d37"),
                types.StringValue("/v2/securitygroups/sg-68398923fb2cb026400d4d38"),
        })
        // Settings fields
        data.FlavorName = types.StringValue("CSO4A8")
        data.KeyPairUriRef = types.StringValue("/v2/keypairs/keypair-example")
        data.UserData = types.StringValue("#cloud-config\npackages:\n  - nginx")
        // Storage fields
        data.BootVolumeUriRef = types.StringValue("/v2/blockstorages/vol-68398923fb2cb026400d4d34")

        tflog.Trace(ctx, "read a CloudServer data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type CloudServerResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        ProjectID types.String `tfsdk:"project_id"`
        Zone      types.String `tfsdk:"zone"`
        Tags      types.List   `tfsdk:"tags"`
        Network   types.Object `tfsdk:"network"`
        Settings  types.Object `tfsdk:"settings"`
        Storage   types.Object `tfsdk:"storage"`
}

type CloudServerNetworkModel struct {
        VpcUriRef            types.String `tfsdk:"vpc_uri_ref"`
        ElasticIpUriRef      types.String `tfsdk:"elastic_ip_uri_ref"`
        SubnetUriRefs        types.List   `tfsdk:"subnet_uri_refs"`
        SecurityGroupUriRefs types.List   `tfsdk:"securitygroup_uri_refs"`
}

type CloudServerSettingsModel struct {
        FlavorName    types.String `tfsdk:"flavor_name"`
        KeyPairUriRef types.String `tfsdk:"key_pair_uri_ref"`
        UserData      types.String `tfsdk:"user_data"`
}

type CloudServerStorageModel struct {
        BootVolumeUriRef types.String `tfsdk:"boot_volume_uri_ref"`
}

type CloudServerResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;CloudServerResource{}
var _ resource.ResourceWithImportState = &amp;CloudServerResource{}

func NewCloudServerResource() resource.Resource <span class="cov8" title="1">{
        return &amp;CloudServerResource{}
}</span>

func (r *CloudServerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_cloudserver"
}</span>

func (r *CloudServerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "CloudServer resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "CloudServer identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "CloudServer URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "CloudServer name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "CloudServer location",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "Project ID",
                                Required:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Cloud Server",
                                Optional:            true,
                        },
                        "network": schema.SingleNestedAttribute{
                                MarkdownDescription: "Network configuration for the cloud server",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "vpc_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "VPC URI reference (e.g., arubacloud_vpc.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "elastic_ip_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "Elastic IP URI reference (e.g., arubacloud_elasticip.example.uri)",
                                                Optional:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "subnet_uri_refs": schema.ListAttribute{
                                                ElementType:         types.StringType,
                                                MarkdownDescription: "List of subnet URI references (e.g., [arubacloud_subnet.example.uri])",
                                                Required:            true,
                                        },
                                        "securitygroup_uri_refs": schema.ListAttribute{
                                                ElementType:         types.StringType,
                                                MarkdownDescription: "List of security group URI references (e.g., [arubacloud_securitygroup.example.uri])",
                                                Required:            true,
                                        },
                                },
                        },
                        "settings": schema.SingleNestedAttribute{
                                MarkdownDescription: "Cloud server settings",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "flavor_name": schema.StringAttribute{
                                                MarkdownDescription: "Flavor name (e.g., CSO4A8 for 4 CPU, 8GB RAM). See https://api.arubacloud.com/docs/metadata/#cloudserver-flavors",
                                                Required:            true,
                                        },
                                        "key_pair_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "Key Pair URI reference (e.g., arubacloud_keypair.example.uri)",
                                                Optional:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "user_data": schema.StringAttribute{
                                                MarkdownDescription: "Cloud-Init user data (raw YAML content)",
                                                Optional:            true,
                                                Sensitive:           true,
                                        },
                                },
                        },
                        "storage": schema.SingleNestedAttribute{
                                MarkdownDescription: "Storage configuration for the cloud server",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "boot_volume_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "Boot volume URI reference (e.g., arubacloud_blockstorage.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func (r *CloudServerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *CloudServerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data CloudServerResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a cloud server",
                )
                return
        }</span>

        // Extract network model
        <span class="cov0" title="0">var networkModel CloudServerNetworkModel
        diags := data.Network.As(ctx, &amp;networkModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract settings model
        <span class="cov0" title="0">var settingsModel CloudServerSettingsModel
        diags = data.Settings.As(ctx, &amp;settingsModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract storage model
        <span class="cov0" title="0">var storageModel CloudServerStorageModel
        diags = data.Storage.As(ctx, &amp;storageModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract subnets from network model
        <span class="cov0" title="0">var subnetRefs []sdktypes.ReferenceResource
        if !networkModel.SubnetUriRefs.IsNull() &amp;&amp; !networkModel.SubnetUriRefs.IsUnknown() </span><span class="cov0" title="0">{
                var subnetURIs []string
                diags := networkModel.SubnetUriRefs.ElementsAs(ctx, &amp;subnetURIs, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for _, subnetURI := range subnetURIs </span><span class="cov0" title="0">{
                        subnetRefs = append(subnetRefs, sdktypes.ReferenceResource{
                                URI: subnetURI,
                        })
                }</span>
        }

        // Extract security groups from network model
        <span class="cov0" title="0">var securityGroupRefs []sdktypes.ReferenceResource
        if !networkModel.SecurityGroupUriRefs.IsNull() &amp;&amp; !networkModel.SecurityGroupUriRefs.IsUnknown() </span><span class="cov0" title="0">{
                var sgURIs []string
                diags := networkModel.SecurityGroupUriRefs.ElementsAs(ctx, &amp;sgURIs, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for _, sgURI := range sgURIs </span><span class="cov0" title="0">{
                        securityGroupRefs = append(securityGroupRefs, sdktypes.ReferenceResource{
                                URI: sgURI,
                        })
                }</span>
        }

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">flavorName := settingsModel.FlavorName.ValueString()
        zone := data.Zone.ValueString()
        createRequest := sdktypes.CloudServerRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.CloudServerPropertiesRequest{
                        FlavorName: &amp;flavorName,
                        Zone:       zone,
                        BootVolume: sdktypes.ReferenceResource{
                                URI: storageModel.BootVolumeUriRef.ValueString(),
                        },
                        VPC: sdktypes.ReferenceResource{
                                URI: networkModel.VpcUriRef.ValueString(),
                        },
                        Subnets:        subnetRefs,
                        SecurityGroups: securityGroupRefs,
                },
        }

        // Add keypair if provided
        if !settingsModel.KeyPairUriRef.IsNull() &amp;&amp; !settingsModel.KeyPairUriRef.IsUnknown() </span><span class="cov0" title="0">{
                createRequest.Properties.KeyPair = sdktypes.ReferenceResource{
                        URI: settingsModel.KeyPairUriRef.ValueString(),
                }
        }</span>

        // Add elastic IP if provided
        <span class="cov0" title="0">if !networkModel.ElasticIpUriRef.IsNull() &amp;&amp; !networkModel.ElasticIpUriRef.IsUnknown() </span><span class="cov0" title="0">{
                createRequest.Properties.ElastcIP = sdktypes.ReferenceResource{
                        URI: networkModel.ElasticIpUriRef.ValueString(),
                }
        }</span>

        // Add user data if provided
        <span class="cov0" title="0">if !settingsModel.UserData.IsNull() &amp;&amp; !settingsModel.UserData.IsUnknown() </span><span class="cov0" title="0">{
                userDataRaw := settingsModel.UserData.ValueString()
                createRequest.Properties.UserData = &amp;userDataRaw
        }</span>

        // Create the cloud server using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromCompute().CloudServers().Create(ctx, projectID, createRequest, nil)

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating cloud server",
                        fmt.Sprintf("Unable to create cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create cloud server", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Extract ID and URI from the Create response (SDK v0.1.13+ has ResourceMetadataResponse with ID and URI)
        <span class="cov0" title="0">if response == nil || response.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Cloud server create response is missing data",
                )
                return
        }</span>

        // Get the server ID from the response
        <span class="cov0" title="0">var serverID string
        if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                serverID = *response.Data.Metadata.ID
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Cloud server create response is missing ID in metadata",
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.StringValue(serverID)

        // Set URI if available
        if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                data.Uri = types.StringValue(*response.Data.Metadata.URI)
        }</span> else<span class="cov0" title="0"> {
                data.Uri = types.StringNull()
        }</span>

        // Wait for Cloud Server to be active before returning
        // This ensures Terraform doesn't proceed until CloudServer is fully ready
        <span class="cov0" title="0">checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromCompute().CloudServers().Get(ctx, projectID, serverID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Check if response indicates an error state
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.IsError() </span><span class="cov0" title="0">{
                        if getResp.Error != nil </span><span class="cov0" title="0">{
                                errMsg := "Unknown error"
                                if getResp.Error.Title != nil </span><span class="cov0" title="0">{
                                        errMsg = *getResp.Error.Title
                                }</span>
                                <span class="cov0" title="0">if getResp.Error.Detail != nil </span><span class="cov0" title="0">{
                                        errMsg = fmt.Sprintf("%s: %s", errMsg, *getResp.Error.Detail)
                                }</span>
                                <span class="cov0" title="0">return "", fmt.Errorf("cloud server in error state: %s", errMsg)</span>
                        }
                        <span class="cov0" title="0">return "", fmt.Errorf("cloud server API returned error response")</span>
                }
                // If we can successfully get the resource, check its status
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                                state := *getResp.Data.Status.State
                                return state, nil
                        }</span>
                }
                // If Status.State is nil, assume it's still creating
                <span class="cov0" title="0">return "InCreation", nil</span>
        }

        // Wait for Cloud Server to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "CloudServer", serverID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cloud Server Not Active",
                        fmt.Sprintf("Cloud server was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the Cloud Server to ensure all fields are properly set
        <span class="cov0" title="0">getResp, err := r.client.Client.FromCompute().CloudServers().Get(ctx, projectID, serverID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Update with values from Get response
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Cloud Server after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a CloudServer resource", map[string]interface{}{
                "cloudserver_id":   data.Id.ValueString(),
                "cloudserver_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CloudServerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data CloudServerResourceModel
        var originalState CloudServerResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;originalState)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := originalState.ProjectID.ValueString()
        serverID := originalState.Id.ValueString()

        if projectID == "" || serverID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Server ID are required to read the cloud server",
                )
                return
        }</span>

        // Get cloud server details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromCompute().CloudServers().Get(ctx, projectID, serverID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading cloud server",
                        fmt.Sprintf("Unable to read cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                // If cloud server not found, mark as removed
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "server_id":  serverID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read cloud server", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response == nil || response.Data == nil </span><span class="cov0" title="0">{
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">server := response.Data

        // Extract original nested models to preserve fields not returned by API
        var originalNetworkModel CloudServerNetworkModel
        diags := originalState.Network.As(ctx, &amp;originalNetworkModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var originalSettingsModel CloudServerSettingsModel
        diags = originalState.Settings.As(ctx, &amp;originalSettingsModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var originalStorageModel CloudServerStorageModel
        diags = originalState.Storage.As(ctx, &amp;originalStorageModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Update basic fields from API response
        <span class="cov0" title="0">if server.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*server.Metadata.ID)
        }</span>

        <span class="cov0" title="0">if server.Metadata.URI != nil </span><span class="cov0" title="0">{
                data.Uri = types.StringValue(*server.Metadata.URI)
        }</span> else<span class="cov0" title="0"> {
                data.Uri = types.StringNull()
        }</span>

        <span class="cov0" title="0">if server.Metadata.Name != nil </span><span class="cov0" title="0">{
                data.Name = types.StringValue(*server.Metadata.Name)
        }</span>

        <span class="cov0" title="0">if server.Metadata.LocationResponse != nil &amp;&amp; server.Metadata.LocationResponse.Value != "" </span><span class="cov0" title="0">{
                data.Location = types.StringValue(server.Metadata.LocationResponse.Value)
        }</span>

        <span class="cov0" title="0">data.ProjectID = originalState.ProjectID
        data.Zone = originalState.Zone

        // Update tags from response
        if len(server.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagValues := make([]types.String, len(server.Metadata.Tags))
                for i, tag := range server.Metadata.Tags </span><span class="cov0" title="0">{
                        tagValues[i] = types.StringValue(tag)
                }</span>
                <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Tags = tagsList
                }</span>
        } else<span class="cov0" title="0"> {
                emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Tags = emptyList
                }</span>
        }

        // Build network object (preserve fields not returned by API)
        <span class="cov0" title="0">networkAttrs := map[string]attr.Value{
                "vpc_uri_ref":            originalNetworkModel.VpcUriRef,
                "elastic_ip_uri_ref":     originalNetworkModel.ElasticIpUriRef,
                "subnet_uri_refs":        originalNetworkModel.SubnetUriRefs,
                "securitygroup_uri_refs": originalNetworkModel.SecurityGroupUriRefs,
        }
        networkObj, diags := types.ObjectValue(
                map[string]attr.Type{
                        "vpc_uri_ref":            types.StringType,
                        "elastic_ip_uri_ref":     types.StringType,
                        "subnet_uri_refs":        types.ListType{ElemType: types.StringType},
                        "securitygroup_uri_refs": types.ListType{ElemType: types.StringType},
                },
                networkAttrs,
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Network = networkObj

        // Build settings object
        settingsAttrs := map[string]attr.Value{
                "flavor_name":      types.StringValue(server.Properties.Flavor.Name),
                "key_pair_uri_ref": originalSettingsModel.KeyPairUriRef,
                "user_data":        originalSettingsModel.UserData,
        }
        settingsObj, diags := types.ObjectValue(
                map[string]attr.Type{
                        "flavor_name":      types.StringType,
                        "key_pair_uri_ref": types.StringType,
                        "user_data":        types.StringType,
                },
                settingsAttrs,
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Settings = settingsObj

        // Build storage object (preserve from state)
        storageAttrs := map[string]attr.Value{
                "boot_volume_uri_ref": originalStorageModel.BootVolumeUriRef,
        }
        storageObj, diags := types.ObjectValue(
                map[string]attr.Type{
                        "boot_volume_uri_ref": types.StringType,
                },
                storageAttrs,
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Storage = storageObj

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CloudServerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data CloudServerResourceModel
        var state CloudServerResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read current state to preserve values
        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract nested models from plan to preserve for inconsistent result check
        <span class="cov0" title="0">var planNetworkModel CloudServerNetworkModel
        diags := data.Network.As(ctx, &amp;planNetworkModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var planSettingsModel CloudServerSettingsModel
        diags = data.Settings.As(ctx, &amp;planSettingsModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var planStorageModel CloudServerStorageModel
        diags = data.Storage.As(ctx, &amp;planStorageModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        serverID := state.Id.ValueString()

        if projectID == "" || serverID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Server ID are required to update the cloud server",
                )
                return
        }</span>

        // Get current cloud server details to preserve existing values
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromCompute().CloudServers().Get(ctx, projectID, serverID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current cloud server",
                        fmt.Sprintf("Unable to get current cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cloud Server Not Found",
                        "Cloud server not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Extract tags from Terraform list
        var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Preserve existing tags if not provided
                tags = current.Metadata.Tags
        }</span>

        // Build the update request, preserving existing values
        <span class="cov0" title="0">flavorName := current.Properties.Flavor.Name
        updateRequest := sdktypes.CloudServerRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: current.Metadata.LocationResponse.Value,
                        },
                },
                Properties: sdktypes.CloudServerPropertiesRequest{
                        FlavorName: &amp;flavorName,
                        BootVolume: current.Properties.BootVolume,
                },
        }

        // Preserve keypair if it exists
        if current.Properties.KeyPair.URI != "" </span><span class="cov0" title="0">{
                updateRequest.Properties.KeyPair = current.Properties.KeyPair
        }</span>

        // Update the cloud server using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromCompute().CloudServers().Update(ctx, projectID, serverID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating cloud server",
                        fmt.Sprintf("Unable to update cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "server_id":  serverID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update cloud server", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Update state with response data if available
        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.Name != nil &amp;&amp; *response.Data.Metadata.Name != "" </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*response.Data.Metadata.Name)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(response.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(response.Data.Metadata.Tags))
                        for i, tag := range response.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        }

        // Ensure immutable fields are set from state/plan before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Zone = state.Zone

        // Rebuild nested objects from plan to avoid inconsistent result
        // Network object (preserve from plan)
        networkAttrs := map[string]attr.Value{
                "vpc_uri_ref":            planNetworkModel.VpcUriRef,
                "elastic_ip_uri_ref":     planNetworkModel.ElasticIpUriRef,
                "subnet_uri_refs":        planNetworkModel.SubnetUriRefs,
                "securitygroup_uri_refs": planNetworkModel.SecurityGroupUriRefs,
        }
        networkObj, diags := types.ObjectValue(
                map[string]attr.Type{
                        "vpc_uri_ref":            types.StringType,
                        "elastic_ip_uri_ref":     types.StringType,
                        "subnet_uri_refs":        types.ListType{ElemType: types.StringType},
                        "securitygroup_uri_refs": types.ListType{ElemType: types.StringType},
                },
                networkAttrs,
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Network = networkObj

        // Settings object (preserve from plan)
        settingsAttrs := map[string]attr.Value{
                "flavor_name":      planSettingsModel.FlavorName,
                "key_pair_uri_ref": planSettingsModel.KeyPairUriRef,
                "user_data":        planSettingsModel.UserData,
        }
        settingsObj, diags := types.ObjectValue(
                map[string]attr.Type{
                        "flavor_name":      types.StringType,
                        "key_pair_uri_ref": types.StringType,
                        "user_data":        types.StringType,
                },
                settingsAttrs,
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Settings = settingsObj

        // Storage object (preserve from plan)
        storageAttrs := map[string]attr.Value{
                "boot_volume_uri_ref": planStorageModel.BootVolumeUriRef,
        }
        storageObj, diags := types.ObjectValue(
                map[string]attr.Type{
                        "boot_volume_uri_ref": types.StringType,
                },
                storageAttrs,
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">data.Storage = storageObj

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *CloudServerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data CloudServerResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        serverID := data.Id.ValueString()

        if projectID == "" || serverID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Server ID are required to delete the cloud server",
                )
                return
        }</span>

        // Delete the cloud server using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromCompute().CloudServers().Delete(ctx, projectID, serverID, nil)
                }</span>,
                ExtractSDKError,
                "CloudServer",
                serverID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting cloud server",
                        fmt.Sprintf("Unable to delete cloud server: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a CloudServer resource", map[string]interface{}{
                "cloudserver_id": serverID,
        })</span>
}

func (r *CloudServerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;ContainerRegistryDataSource{}

func NewContainerRegistryDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;ContainerRegistryDataSource{}
}</span>

type ContainerRegistryDataSource struct {
        client *ArubaCloudClient
}

type ContainerRegistryDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        // Network fields (flattened)
        PublicIpUriRef      types.String `tfsdk:"public_ip_uri_ref"`
        VpcUriRef           types.String `tfsdk:"vpc_uri_ref"`
        SubnetUriRef        types.String `tfsdk:"subnet_uri_ref"`
        SecurityGroupUriRef types.String `tfsdk:"security_group_uri_ref"`
        // Storage fields (flattened)
        BlockStorageUriRef types.String `tfsdk:"block_storage_uri_ref"`
        // Settings fields (flattened)
        AdminUser             types.String `tfsdk:"admin_user"`
        ConcurrentUsersFlavor types.String `tfsdk:"concurrent_users_flavor"`
}

func (d *ContainerRegistryDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_containerregistry"
}</span>

func (d *ContainerRegistryDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Container Registry data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Container Registry identifier",
                                Required:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Container Registry URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Container Registry name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Container Registry location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Container Registry resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Container Registry belongs to",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Computed:            true,
                        },
                        "public_ip_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Public IP URI reference",
                                Computed:            true,
                        },
                        "vpc_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "VPC URI reference",
                                Computed:            true,
                        },
                        "subnet_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Subnet URI reference",
                                Computed:            true,
                        },
                        "security_group_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Security Group URI reference",
                                Computed:            true,
                        },
                        "block_storage_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Block Storage URI reference",
                                Computed:            true,
                        },
                        "admin_user": schema.StringAttribute{
                                MarkdownDescription: "Administrator username",
                                Computed:            true,
                        },
                        "concurrent_users_flavor": schema.StringAttribute{
                                MarkdownDescription: "Concurrent users flavor size (Small, Medium, HighPerf)",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *ContainerRegistryDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *ContainerRegistryDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data ContainerRegistryDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Populate all fields with example data
        <span class="cov8" title="1">data.Uri = types.StringValue("/v2/containerregistries/cr-68398923fb2cb026400d4d31")
        data.Name = types.StringValue("example-containerregistry")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("registry"),
                types.StringValue("docker"),
        })
        data.ProjectID = types.StringValue("68398923fb2cb026400d4d31")
        data.BillingPeriod = types.StringValue("Hour")
        // Network fields
        data.PublicIpUriRef = types.StringValue("/v2/elasticips/eip-68398923fb2cb026400d4d32")
        data.VpcUriRef = types.StringValue("/v2/vpcs/vpc-68398923fb2cb026400d4d33")
        data.SubnetUriRef = types.StringValue("/v2/subnets/subnet-68398923fb2cb026400d4d34")
        data.SecurityGroupUriRef = types.StringValue("/v2/securitygroups/sg-68398923fb2cb026400d4d35")
        // Storage fields
        data.BlockStorageUriRef = types.StringValue("/v2/blockstorages/bs-68398923fb2cb026400d4d36")
        // Settings fields
        data.AdminUser = types.StringValue("admin")
        data.ConcurrentUsersFlavor = types.StringValue("Medium")
        tflog.Trace(ctx, "read a Container Registry data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type ContainerRegistryResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Network       types.Object `tfsdk:"network"`
        Storage       types.Object `tfsdk:"storage"`
        Settings      types.Object `tfsdk:"settings"`
}

type ContainerRegistryNetworkModel struct {
        PublicIpUriRef      types.String `tfsdk:"public_ip_uri_ref"`
        VpcUriRef           types.String `tfsdk:"vpc_uri_ref"`
        SubnetUriRef        types.String `tfsdk:"subnet_uri_ref"`
        SecurityGroupUriRef types.String `tfsdk:"security_group_uri_ref"`
}

type ContainerRegistryStorageModel struct {
        BlockStorageUriRef types.String `tfsdk:"block_storage_uri_ref"`
}

type ContainerRegistrySettingsModel struct {
        AdminUser             types.String `tfsdk:"admin_user"`
        ConcurrentUsersFlavor types.String `tfsdk:"concurrent_users_flavor"`
}

type ContainerRegistryResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;ContainerRegistryResource{}
var _ resource.ResourceWithImportState = &amp;ContainerRegistryResource{}

func NewContainerRegistryResource() resource.Resource <span class="cov8" title="1">{
        return &amp;ContainerRegistryResource{}
}</span>

func (r *ContainerRegistryResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_containerregistry"
}</span>

func (r *ContainerRegistryResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Container Registry resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Container Registry identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Container Registry URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Container Registry name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Container Registry location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Container Registry resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Container Registry belongs to",
                                Required:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Optional:            true,
                        },
                        "network": schema.SingleNestedAttribute{
                                MarkdownDescription: "Network configuration for the container registry",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "public_ip_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "Public IP URI reference (e.g., arubacloud_elasticip.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "vpc_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "VPC URI reference (e.g., arubacloud_vpc.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "subnet_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "Subnet URI reference (e.g., arubacloud_subnet.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "security_group_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "Security Group URI reference (e.g., arubacloud_securitygroup.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                },
                        },
                        "storage": schema.SingleNestedAttribute{
                                MarkdownDescription: "Storage configuration for the container registry",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "block_storage_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "Block Storage URI reference (e.g., arubacloud_blockstorage.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                },
                        },
                        "settings": schema.SingleNestedAttribute{
                                MarkdownDescription: "Container registry settings",
                                Optional:            true,
                                Attributes: map[string]schema.Attribute{
                                        "admin_user": schema.StringAttribute{
                                                MarkdownDescription: "Administrator username",
                                                Optional:            true,
                                        },
                                        "concurrent_users_flavor": schema.StringAttribute{
                                                MarkdownDescription: "Concurrent users flavor size. Must be one of: Small, Medium, HighPerf",
                                                Optional:            true,
                                        },
                                },
                        },
                },
        }
}</span>

func (r *ContainerRegistryResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *ContainerRegistryResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ContainerRegistryResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a container registry",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract network configuration
        <span class="cov0" title="0">var networkModel ContainerRegistryNetworkModel
        diags := data.Network.As(ctx, &amp;networkModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract storage configuration
        <span class="cov0" title="0">var storageModel ContainerRegistryStorageModel
        diags = data.Storage.As(ctx, &amp;storageModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.ContainerRegistryRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.ContainerRegistryPropertiesRequest{
                        PublicIp: sdktypes.ReferenceResource{
                                URI: networkModel.PublicIpUriRef.ValueString(),
                        },
                        VPC: sdktypes.ReferenceResource{
                                URI: networkModel.VpcUriRef.ValueString(),
                        },
                        Subnet: sdktypes.ReferenceResource{
                                URI: networkModel.SubnetUriRef.ValueString(),
                        },
                        SecurityGroup: sdktypes.ReferenceResource{
                                URI: networkModel.SecurityGroupUriRef.ValueString(),
                        },
                        BlockStorage: sdktypes.ReferenceResource{
                                URI: storageModel.BlockStorageUriRef.ValueString(),
                        },
                },
        }

        // Add optional fields
        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                createRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: data.BillingPeriod.ValueString(),
                }
        }</span>

        // Extract settings if provided
        <span class="cov0" title="0">if !data.Settings.IsNull() &amp;&amp; !data.Settings.IsUnknown() </span><span class="cov0" title="0">{
                var settingsModel ContainerRegistrySettingsModel
                diags = data.Settings.As(ctx, &amp;settingsModel, basetypes.ObjectAsOptions{})
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if !settingsModel.AdminUser.IsNull() &amp;&amp; !settingsModel.AdminUser.IsUnknown() </span><span class="cov0" title="0">{
                        createRequest.Properties.AdminUser = &amp;sdktypes.UserCredential{
                                Username: settingsModel.AdminUser.ValueString(),
                        }
                }</span>

                <span class="cov0" title="0">if !settingsModel.ConcurrentUsersFlavor.IsNull() &amp;&amp; !settingsModel.ConcurrentUsersFlavor.IsUnknown() </span><span class="cov0" title="0">{
                        concurrentUsersFlavor := settingsModel.ConcurrentUsersFlavor.ValueString()
                        createRequest.Properties.ConcurrentUsers = &amp;concurrentUsersFlavor
                }</span>
        }

        // Create the container registry using the SDK
        <span class="cov0" title="0">containerClient := r.client.Client.FromContainer()
        if containerClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Client Not Available",
                        "Container client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">registryClient := containerClient.ContainerRegistry()
        if registryClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Client Not Available",
                        "Container Registry client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">response, err := registryClient.Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating container registry",
                        fmt.Sprintf("Unable to create container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create container registry", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Container registry created but no data returned from API",
                )
                return
        }</span>

        // Wait for Container Registry to be active before returning
        // This ensures Terraform doesn't proceed until Container Registry is ready
        <span class="cov0" title="0">registryID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := registryClient.Get(ctx, projectID, registryID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Container Registry to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "ContainerRegistry", registryID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Not Active",
                        fmt.Sprintf("Container registry was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Container Registry resource", map[string]interface{}{
                "containerregistry_id":   data.Id.ValueString(),
                "containerregistry_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ContainerRegistryResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ContainerRegistryResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        registryID := data.Id.ValueString()

        if projectID == "" || registryID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Registry ID are required to read the container registry",
                )
                return
        }</span>

        <span class="cov0" title="0">containerClient := r.client.Client.FromContainer()
        if containerClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Client Not Available",
                        "Container client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">registryClient := containerClient.ContainerRegistry()
        if registryClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Client Not Available",
                        "Container Registry client is not available",
                )
                return
        }</span>

        // Get container registry details using the SDK
        <span class="cov0" title="0">response, err := registryClient.Get(ctx, projectID, registryID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading container registry",
                        fmt.Sprintf("Unable to read container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id":  projectID,
                        "registry_id": registryID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read container registry", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                registry := response.Data

                if registry.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*registry.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if registry.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*registry.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if registry.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*registry.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if registry.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(registry.Metadata.LocationResponse.Value)
                }</span>

                // Build network object
                <span class="cov0" title="0">networkAttrs := map[string]attr.Value{
                        "public_ip_uri_ref":      types.StringValue(registry.Properties.PublicIp.URI),
                        "vpc_uri_ref":            types.StringValue(registry.Properties.VPC.URI),
                        "subnet_uri_ref":         types.StringValue(registry.Properties.Subnet.URI),
                        "security_group_uri_ref": types.StringValue(registry.Properties.SecurityGroup.URI),
                }
                networkObj, diags := types.ObjectValue(
                        map[string]attr.Type{
                                "public_ip_uri_ref":      types.StringType,
                                "vpc_uri_ref":            types.StringType,
                                "subnet_uri_ref":         types.StringType,
                                "security_group_uri_ref": types.StringType,
                        },
                        networkAttrs,
                )
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Network = networkObj
                }</span>

                // Build storage object
                <span class="cov0" title="0">storageAttrs := map[string]attr.Value{
                        "block_storage_uri_ref": types.StringValue(registry.Properties.BlockStorage.URI),
                }
                storageObj, diags := types.ObjectValue(
                        map[string]attr.Type{
                                "block_storage_uri_ref": types.StringType,
                        },
                        storageAttrs,
                )
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Storage = storageObj
                }</span>

                // Build settings object if there are any settings
                <span class="cov0" title="0">var settingsAdminUser types.String
                var settingsConcurrentUsersFlavor types.String

                if registry.Properties.AdminUser.Username != "" </span><span class="cov0" title="0">{
                        settingsAdminUser = types.StringValue(registry.Properties.AdminUser.Username)
                }</span> else<span class="cov0" title="0"> {
                        settingsAdminUser = types.StringNull()
                }</span>

                <span class="cov0" title="0">if registry.Properties.ConcurrentUsers != nil &amp;&amp; *registry.Properties.ConcurrentUsers != "" </span><span class="cov0" title="0">{
                        settingsConcurrentUsersFlavor = types.StringValue(*registry.Properties.ConcurrentUsers)
                }</span> else<span class="cov0" title="0"> {
                        settingsConcurrentUsersFlavor = types.StringNull()
                }</span>

                <span class="cov0" title="0">settingsAttrs := map[string]attr.Value{
                        "admin_user":              settingsAdminUser,
                        "concurrent_users_flavor": settingsConcurrentUsersFlavor,
                }
                settingsObj, diags := types.ObjectValue(
                        map[string]attr.Type{
                                "admin_user":              types.StringType,
                                "concurrent_users_flavor": types.StringType,
                        },
                        settingsAttrs,
                )
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Settings = settingsObj
                }</span>

                <span class="cov0" title="0">if registry.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(registry.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        data.BillingPeriod = types.StringNull()
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(registry.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(registry.Metadata.Tags))
                        for i, tag := range registry.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ContainerRegistryResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ContainerRegistryResourceModel
        var state ContainerRegistryResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        registryID := state.Id.ValueString()

        if projectID == "" || registryID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Registry ID are required to update the container registry",
                )
                return
        }</span>

        <span class="cov0" title="0">containerClient := r.client.Client.FromContainer()
        if containerClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Client Not Available",
                        "Container client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">registryClient := containerClient.ContainerRegistry()
        if registryClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Client Not Available",
                        "Container Registry client is not available",
                )
                return
        }</span>

        // Get current container registry details
        <span class="cov0" title="0">getResponse, err := registryClient.Get(ctx, projectID, registryID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current container registry",
                        fmt.Sprintf("Unable to get current container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Not Found",
                        "Container registry not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for container registry",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Extract network configuration from plan
        <span class="cov0" title="0">var networkModel ContainerRegistryNetworkModel
        var diags diag.Diagnostics
        diags = data.Network.As(ctx, &amp;networkModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract storage configuration from plan
        <span class="cov0" title="0">var storageModel ContainerRegistryStorageModel
        diags = data.Storage.As(ctx, &amp;storageModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Build update request - use ContainerRegistryRequest for updates (same as create)
        <span class="cov0" title="0">updateRequest := sdktypes.ContainerRegistryRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.ContainerRegistryPropertiesRequest{
                        // Use network configuration from plan
                        PublicIp: sdktypes.ReferenceResource{
                                URI: networkModel.PublicIpUriRef.ValueString(),
                        },
                        VPC: sdktypes.ReferenceResource{
                                URI: networkModel.VpcUriRef.ValueString(),
                        },
                        Subnet: sdktypes.ReferenceResource{
                                URI: networkModel.SubnetUriRef.ValueString(),
                        },
                        SecurityGroup: sdktypes.ReferenceResource{
                                URI: networkModel.SecurityGroupUriRef.ValueString(),
                        },
                        BlockStorage: sdktypes.ReferenceResource{
                                URI: storageModel.BlockStorageUriRef.ValueString(),
                        },
                },
        }

        // Update billing period if provided, otherwise preserve current
        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: data.BillingPeriod.ValueString(),
                }
        }</span> else<span class="cov0" title="0"> if current.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: current.Properties.BillingPlan.BillingPeriod,
                }
        }</span>

        // Extract and update settings if provided
        <span class="cov0" title="0">if !data.Settings.IsNull() &amp;&amp; !data.Settings.IsUnknown() </span><span class="cov0" title="0">{
                var settingsModel ContainerRegistrySettingsModel
                diags = data.Settings.As(ctx, &amp;settingsModel, basetypes.ObjectAsOptions{})
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if !settingsModel.AdminUser.IsNull() &amp;&amp; !settingsModel.AdminUser.IsUnknown() </span><span class="cov0" title="0">{
                        updateRequest.Properties.AdminUser = &amp;sdktypes.UserCredential{
                                Username: settingsModel.AdminUser.ValueString(),
                        }
                }</span> else<span class="cov0" title="0"> if current.Properties.AdminUser.Username != "" </span><span class="cov0" title="0">{
                        updateRequest.Properties.AdminUser = &amp;sdktypes.UserCredential{
                                Username: current.Properties.AdminUser.Username,
                        }
                }</span>

                <span class="cov0" title="0">if !settingsModel.ConcurrentUsersFlavor.IsNull() &amp;&amp; !settingsModel.ConcurrentUsersFlavor.IsUnknown() </span><span class="cov0" title="0">{
                        concurrentUsersFlavor := settingsModel.ConcurrentUsersFlavor.ValueString()
                        updateRequest.Properties.ConcurrentUsers = &amp;concurrentUsersFlavor
                }</span> else<span class="cov0" title="0"> if current.Properties.ConcurrentUsers != nil </span><span class="cov0" title="0">{
                        updateRequest.Properties.ConcurrentUsers = current.Properties.ConcurrentUsers
                }</span>
        } else<span class="cov0" title="0"> {
                // Preserve current settings if not in plan
                if current.Properties.AdminUser.Username != "" </span><span class="cov0" title="0">{
                        updateRequest.Properties.AdminUser = &amp;sdktypes.UserCredential{
                                Username: current.Properties.AdminUser.Username,
                        }
                }</span>
                <span class="cov0" title="0">if current.Properties.ConcurrentUsers != nil </span><span class="cov0" title="0">{
                        updateRequest.Properties.ConcurrentUsers = current.Properties.ConcurrentUsers
                }</span>
        }

        // Update the container registry using the SDK
        <span class="cov0" title="0">response, err := registryClient.Update(ctx, projectID, registryID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating container registry",
                        fmt.Sprintf("Unable to update container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id":  projectID,
                        "registry_id": registryID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update container registry", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.Uri = state.Uri // Preserve URI from state
        data.ProjectID = state.ProjectID
        data.Network = state.Network
        data.Storage = state.Storage
        data.Settings = state.Settings

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the container registry to get the latest state including URI
                getResp, err := registryClient.Get(ctx, projectID, registryID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if not in response
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                }</span>
        }

        // Re-read to get the latest state and update all fields
        <span class="cov0" title="0">getResp, err := registryClient.Get(ctx, projectID, registryID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                registry := getResp.Data
                // Update URI if available
                if registry.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*registry.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = state.Uri // Fallback to state if not available
                }</span>

                // Build network object from response
                <span class="cov0" title="0">networkAttrs := map[string]attr.Value{
                        "public_ip_uri_ref":      types.StringValue(registry.Properties.PublicIp.URI),
                        "vpc_uri_ref":            types.StringValue(registry.Properties.VPC.URI),
                        "subnet_uri_ref":         types.StringValue(registry.Properties.Subnet.URI),
                        "security_group_uri_ref": types.StringValue(registry.Properties.SecurityGroup.URI),
                }
                networkObj, diagsNetwork := types.ObjectValue(
                        map[string]attr.Type{
                                "public_ip_uri_ref":      types.StringType,
                                "vpc_uri_ref":            types.StringType,
                                "subnet_uri_ref":         types.StringType,
                                "security_group_uri_ref": types.StringType,
                        },
                        networkAttrs,
                )
                resp.Diagnostics.Append(diagsNetwork...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Network = networkObj
                }</span>

                // Build storage object from response
                <span class="cov0" title="0">storageAttrs := map[string]attr.Value{
                        "block_storage_uri_ref": types.StringValue(registry.Properties.BlockStorage.URI),
                }
                storageObj, diagsStorage := types.ObjectValue(
                        map[string]attr.Type{
                                "block_storage_uri_ref": types.StringType,
                        },
                        storageAttrs,
                )
                resp.Diagnostics.Append(diagsStorage...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Storage = storageObj
                }</span>

                // Build settings object from response
                <span class="cov0" title="0">var settingsAdminUser types.String
                var settingsConcurrentUsersFlavor types.String

                if registry.Properties.AdminUser != nil &amp;&amp; registry.Properties.AdminUser.Username != "" </span><span class="cov0" title="0">{
                        settingsAdminUser = types.StringValue(registry.Properties.AdminUser.Username)
                }</span> else<span class="cov0" title="0"> {
                        settingsAdminUser = types.StringNull()
                }</span>

                <span class="cov0" title="0">if registry.Properties.ConcurrentUsers != nil &amp;&amp; *registry.Properties.ConcurrentUsers != "" </span><span class="cov0" title="0">{
                        settingsConcurrentUsersFlavor = types.StringValue(*registry.Properties.ConcurrentUsers)
                }</span> else<span class="cov0" title="0"> {
                        settingsConcurrentUsersFlavor = types.StringNull()
                }</span>

                <span class="cov0" title="0">settingsAttrs := map[string]attr.Value{
                        "admin_user":              settingsAdminUser,
                        "concurrent_users_flavor": settingsConcurrentUsersFlavor,
                }
                settingsObj, diagsSettings := types.ObjectValue(
                        map[string]attr.Type{
                                "admin_user":              types.StringType,
                                "concurrent_users_flavor": types.StringType,
                        },
                        settingsAttrs,
                )
                resp.Diagnostics.Append(diagsSettings...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Settings = settingsObj
                }</span>

                // Update other fields from re-read to ensure consistency
                <span class="cov0" title="0">if registry.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*registry.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if registry.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(registry.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if registry.Properties.BillingPlan != nil &amp;&amp; registry.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(registry.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        data.BillingPeriod = types.StringNull()
                }</span>

                // Update tags from re-read
                <span class="cov0" title="0">if len(registry.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(registry.Metadata.Tags))
                        for i, tag := range registry.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diagsTags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diagsTags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diagsTags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diagsTags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If re-read fails, preserve immutable fields from state
                data.Uri = state.Uri
                data.Network = state.Network
                data.Storage = state.Storage
                data.Settings = state.Settings
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ContainerRegistryResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ContainerRegistryResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        registryID := data.Id.ValueString()

        if projectID == "" || registryID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Registry ID are required to delete the container registry",
                )
                return
        }</span>

        <span class="cov0" title="0">containerClient := r.client.Client.FromContainer()
        if containerClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Client Not Available",
                        "Container client is not available",
                )
                return
        }</span>

        <span class="cov0" title="0">registryClient := containerClient.ContainerRegistry()
        if registryClient == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Container Registry Client Not Available",
                        "Container Registry client is not available",
                )
                return
        }</span>

        // Delete the container registry using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return registryClient.Delete(ctx, projectID, registryID, nil)
                }</span>,
                ExtractSDKError,
                "ContainerRegistry",
                registryID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting container registry",
                        fmt.Sprintf("Unable to delete container registry: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Container Registry resource", map[string]interface{}{
                "containerregistry_id": registryID,
        })</span>
}

func (r *ContainerRegistryResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;DatabaseDataSource{}

func NewDatabaseDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;DatabaseDataSource{}
}</span>

type DatabaseDataSource struct {
        client *ArubaCloudClient
}

type DatabaseDataSourceModel struct {
        Id        types.String `tfsdk:"id"`
        ProjectID types.String `tfsdk:"project_id"`
        DBaaSID   types.String `tfsdk:"dbaas_id"`
        Name      types.String `tfsdk:"name"`
}

func (d *DatabaseDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_database"
}</span>

func (d *DatabaseDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database identifier",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this database belongs to",
                                Computed:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this database belongs to",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Database name",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *DatabaseDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *DatabaseDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data DatabaseDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Name = types.StringValue("example-database")
        data.ProjectID = types.StringValue("68398923fb2cb026400d4d31")
        data.DBaaSID = types.StringValue("68ff8d8fc1445aeb83f79438")

        tflog.Trace(ctx, "read a Database data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DatabaseResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        ProjectID types.String `tfsdk:"project_id"`
        DBaaSID   types.String `tfsdk:"dbaas_id"`
        Name      types.String `tfsdk:"name"`
}

type DatabaseResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DatabaseResource{}
var _ resource.ResourceWithImportState = &amp;DatabaseResource{}

func NewDatabaseResource() resource.Resource <span class="cov8" title="1">{
        return &amp;DatabaseResource{}
}</span>

func (r *DatabaseResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_database"
}</span>

func (r *DatabaseResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database identifier (same as name)",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Database URI",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this database belongs to",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this database belongs to",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Database name",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *DatabaseResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DatabaseResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DatabaseResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to create a database",
                )
                return
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.DatabaseRequest{
                Name: data.Name.ValueString(),
        }

        // Create the database using the SDK
        response, err := r.client.Client.FromDatabase().Databases().Create(ctx, projectID, dbaasID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating database",
                        fmt.Sprintf("Unable to create database: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create database", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Database uses name as ID
                data.Id = types.StringValue(response.Data.Name)
                // Database response doesn't have Metadata.URI
                data.Uri = types.StringNull()
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Database created but no data returned from API",
                )
                return
        }</span>

        // Wait for Database to be active before returning
        // This ensures Terraform doesn't proceed until Database is ready
        <span class="cov0" title="0">databaseName := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromDatabase().Databases().Get(ctx, projectID, dbaasID, databaseName, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Databases don't have a status field, so if we can get it, it's ready
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        return "Active", nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Database to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Database", databaseName, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Database Not Active",
                        fmt.Sprintf("Database was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Database resource", map[string]interface{}{
                "database_id":   data.Id.ValueString(),
                "database_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Id.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Database Name are required to read the database",
                )
                return
        }</span>

        // Get database details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().Databases().Get(ctx, projectID, dbaasID, databaseName, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading database",
                        fmt.Sprintf("Unable to read database: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id":    projectID,
                        "dbaas_id":      dbaasID,
                        "database_name": databaseName,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read database", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                db := response.Data
                data.Id = types.StringValue(db.Name)
                data.Name = types.StringValue(db.Name)
                // Database response doesn't have Metadata.URI
                data.Uri = types.StringNull()
        }</span> else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DatabaseResourceModel
        var state DatabaseResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        dbaasID := state.DBaaSID.ValueString()
        oldDatabaseName := state.Id.ValueString()

        if projectID == "" || dbaasID == "" || oldDatabaseName == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Database Name are required to update the database",
                )
                return
        }</span>

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.DatabaseRequest{
                Name: data.Name.ValueString(),
        }

        // Update the database using the SDK
        response, err := r.client.Client.FromDatabase().Databases().Update(ctx, projectID, dbaasID, oldDatabaseName, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating database",
                        fmt.Sprintf("Unable to update database: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id":    projectID,
                        "dbaas_id":      dbaasID,
                        "database_name": oldDatabaseName,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update database", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update ID to new name
                data.Id = types.StringValue(response.Data.Name)
                // Database response doesn't have Metadata.URI
                data.Uri = types.StringNull()
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.DBaaSID = state.DBaaSID

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update ID from response (database name can change, so use response)
                data.Id = types.StringValue(response.Data.Name)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DatabaseResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Id.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Database Name are required to delete the database",
                )
                return
        }</span>

        // Delete the database using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().Databases().Delete(ctx, projectID, dbaasID, databaseName, nil)
                }</span>,
                ExtractSDKError,
                "Database",
                databaseName,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting database",
                        fmt.Sprintf("Unable to delete database: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Database resource", map[string]interface{}{
                "database_id": databaseName,
        })</span>
}

func (r *DatabaseResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;DatabaseBackupDataSource{}

func NewDatabaseBackupDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;DatabaseBackupDataSource{}
}</span>

type DatabaseBackupDataSource struct {
        client *ArubaCloudClient
}

type DatabaseBackupDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        Zone          types.String `tfsdk:"zone"`
        DBaaSID       types.String `tfsdk:"dbaas_id"`
        Database      types.String `tfsdk:"database"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

func (d *DatabaseBackupDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_databasebackup"
}</span>

func (d *DatabaseBackupDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database Backup data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database Backup identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Database Backup name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Database Backup location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Database Backup resource",
                                Computed:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone for the Database Backup",
                                Computed:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this backup belongs to",
                                Computed:            true,
                        },
                        "database": schema.StringAttribute{
                                MarkdownDescription: "Database to backup (ID or name)",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *DatabaseBackupDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *DatabaseBackupDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data DatabaseBackupDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-databasebackup")
        tflog.Trace(ctx, "read a Database Backup data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DatabaseBackupResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        ProjectID     types.String `tfsdk:"project_id"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        Zone          types.String `tfsdk:"zone"`
        DBaaSID       types.String `tfsdk:"dbaas_id"`
        Database      types.String `tfsdk:"database"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

type DatabaseBackupResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DatabaseBackupResource{}
var _ resource.ResourceWithImportState = &amp;DatabaseBackupResource{}

func NewDatabaseBackupResource() resource.Resource <span class="cov8" title="1">{
        return &amp;DatabaseBackupResource{}
}</span>

func (r *DatabaseBackupResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_databasebackup"
}</span>

func (r *DatabaseBackupResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database Backup resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database Backup identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Database Backup URI",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this backup belongs to",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Database Backup name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Database Backup location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Database Backup resource",
                                Optional:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone for the Database Backup",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this backup belongs to",
                                Required:            true,
                        },
                        "database": schema.StringAttribute{
                                MarkdownDescription: "Database name to backup",
                                Required:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *DatabaseBackupResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DatabaseBackupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DatabaseBackupResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Database.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Database name are required to create a database backup",
                )
                return
        }</span>

        // Get DBaaS instance to get its URI
        <span class="cov0" title="0">dbaasResp, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting DBaaS instance",
                        fmt.Sprintf("Unable to get DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if dbaasResp == nil || dbaasResp.Data == nil || dbaasResp.Data.Metadata.URI == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "DBaaS Instance Not Found",
                        "DBaaS instance not found or missing URI",
                )
                return
        }</span>

        <span class="cov0" title="0">dbaasURI := *dbaasResp.Data.Metadata.URI
        // Construct database URI
        databaseURI := fmt.Sprintf("%s/databases/%s", dbaasURI, databaseName)

        var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.BackupRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.BackupPropertiesRequest{
                        Zone: data.Zone.ValueString(),
                        DBaaS: sdktypes.ReferenceResource{
                                URI: dbaasURI,
                        },
                        Database: sdktypes.ReferenceResource{
                                URI: databaseURI,
                        },
                        BillingPlan: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Create the backup using the SDK
        response, err := r.client.Client.FromDatabase().Backups().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating database backup",
                        fmt.Sprintf("Unable to create database backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create database backup", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Database backup created but no ID returned from API",
                )
                return
        }</span>

        // Wait for Database Backup to be active before returning
        // This ensures Terraform doesn't proceed until Backup is ready
        <span class="cov0" title="0">backupID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromDatabase().Backups().Get(ctx, projectID, backupID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Database Backup to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "DatabaseBackup", backupID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Database Backup Not Active",
                        fmt.Sprintf("Database backup was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Database Backup resource", map[string]interface{}{
                "backup_id":   data.Id.ValueString(),
                "backup_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseBackupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseBackupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to read the database backup",
                )
                return
        }</span>

        // Get backup details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().Backups().Get(ctx, projectID, backupID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading database backup",
                        fmt.Sprintf("Unable to read database backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "backup_id":  backupID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read database backup", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                backup := response.Data
                if backup.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*backup.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*backup.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if backup.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*backup.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(backup.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if backup.Metadata.Tags != nil </span><span class="cov0" title="0">{
                        tagValues := make([]attr.Value, len(backup.Metadata.Tags))
                        for i, tag := range backup.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValue(types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.Tags = types.ListNull(types.StringType)
                }</span>
                <span class="cov0" title="0">if backup.Properties.Zone != "" </span><span class="cov0" title="0">{
                        data.Zone = types.StringValue(backup.Properties.Zone)
                }</span>
                <span class="cov0" title="0">if backup.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(backup.Properties.BillingPlan.BillingPeriod)
                }</span>
                // Extract DBaaS ID and Database name from URIs if needed
                // Note: These may need to be stored separately or extracted from URIs
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseBackupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DatabaseBackupResourceModel
        var state DatabaseBackupResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Database backups typically don't support updates
        // If they do, implement update logic here
        <span class="cov0" title="0">resp.Diagnostics.AddWarning(
                "Update Not Supported",
                "Database backups do not support updates. Changes will be ignored.",
        )

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseBackupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DatabaseBackupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.Id.ValueString()

        if projectID == "" || backupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Backup ID are required to delete the database backup",
                )
                return
        }</span>

        // Delete the backup using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().Backups().Delete(ctx, projectID, backupID, nil)
                }</span>,
                ExtractSDKError,
                "DatabaseBackup",
                backupID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting database backup",
                        fmt.Sprintf("Unable to delete database backup: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Database Backup resource", map[string]interface{}{
                "backup_id": backupID,
        })</span>
}

func (r *DatabaseBackupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;DatabaseGrantDataSource{}

func NewDatabaseGrantDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;DatabaseGrantDataSource{}
}</span>

type DatabaseGrantDataSource struct {
        client *ArubaCloudClient
}

type DatabaseGrantDataSourceModel struct {
        Id       types.String `tfsdk:"id"`
        Database types.String `tfsdk:"database"`
        UserID   types.String `tfsdk:"user_id"`
        Role     types.String `tfsdk:"role"`
}

func (d *DatabaseGrantDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_databasegrant"
}</span>

func (d *DatabaseGrantDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database Grant data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database Grant identifier",
                                Required:            true,
                        },
                        "database": schema.StringAttribute{
                                MarkdownDescription: "Database name or ID",
                                Computed:            true,
                        },
                        "user_id": schema.StringAttribute{
                                MarkdownDescription: "User ID to grant access",
                                Computed:            true,
                        },
                        "role": schema.StringAttribute{
                                MarkdownDescription: "Role to grant (e.g., read, write, admin)",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *DatabaseGrantDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *DatabaseGrantDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data DatabaseGrantDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response for all attributes
        <span class="cov8" title="1">data.Database = types.StringValue("example-database")
        data.UserID = types.StringValue("example-user-id")
        data.Role = types.StringValue("read")
        tflog.Trace(ctx, "read a Database Grant data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DatabaseGrantResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        ProjectID types.String `tfsdk:"project_id"`
        DBaaSID   types.String `tfsdk:"dbaas_id"`
        Database  types.String `tfsdk:"database"`
        UserID    types.String `tfsdk:"user_id"`
        Role      types.String `tfsdk:"role"`
}

type DatabaseGrantResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DatabaseGrantResource{}
var _ resource.ResourceWithImportState = &amp;DatabaseGrantResource{}

func NewDatabaseGrantResource() resource.Resource <span class="cov8" title="1">{
        return &amp;DatabaseGrantResource{}
}</span>

func (r *DatabaseGrantResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_databasegrant"
}</span>

func (r *DatabaseGrantResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Database Grant resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Database Grant identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Database Grant URI",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this grant belongs to",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this grant belongs to",
                                Required:            true,
                        },
                        "database": schema.StringAttribute{
                                MarkdownDescription: "Database name",
                                Required:            true,
                        },
                        "user_id": schema.StringAttribute{
                                MarkdownDescription: "User ID (username) to grant access",
                                Required:            true,
                        },
                        "role": schema.StringAttribute{
                                MarkdownDescription: "Role to grant (e.g., read, write, admin)",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *DatabaseGrantResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DatabaseGrantResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DatabaseGrantResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Database.ValueString()
        userID := data.UserID.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" || userID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, Database name, and User ID are required to create a database grant",
                )
                return
        }</span>

        // Build the create request
        // GrantRequest requires both User and Role fields
        <span class="cov0" title="0">createRequest := sdktypes.GrantRequest{
                User: sdktypes.GrantUser{Username: userID},
                Role: sdktypes.GrantRole{Name: data.Role.ValueString()},
        }

        // Create the grant using the SDK
        response, err := r.client.Client.FromDatabase().Grants().Create(ctx, projectID, dbaasID, databaseName, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Database grant create error", map[string]interface{}{
                        "error":      err.Error(),
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "database":   databaseName,
                        "user_id":    userID,
                })
                resp.Diagnostics.AddError(
                        "Error creating database grant",
                        fmt.Sprintf("Unable to create database grant: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "database":   databaseName,
                        "user_id":    userID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create database grant", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Set the grant ID - using a composite key
                data.Id = types.StringValue(fmt.Sprintf("%s/%s/%s/%s", projectID, dbaasID, databaseName, userID))
                data.Uri = types.StringNull() // Grants don't have URIs
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Database grant created but no data returned from API",
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Trace(ctx, "created a Database Grant resource", map[string]interface{}{
                "grant_id": data.Id.ValueString(),
        })</span>
}

func (r *DatabaseGrantResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DatabaseGrantResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Database.ValueString()
        userID := data.UserID.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" || userID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, Database name, and User ID are required to read the database grant",
                )
                return
        }</span>

        // Get grant details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().Grants().Get(ctx, projectID, dbaasID, databaseName, userID, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Database grant read error", map[string]interface{}{
                        "error":      err.Error(),
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "database":   databaseName,
                        "user_id":    userID,
                })
                resp.Diagnostics.AddError(
                        "Error reading database grant",
                        fmt.Sprintf("Unable to read database grant: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                // Handle 404 - Resource no longer exists
                if response.Error.Status != nil &amp;&amp; *response.Error.Status == 404 </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Database grant not found, removing from state", map[string]interface{}{
                                "project_id": projectID,
                                "dbaas_id":   dbaasID,
                                "database":   databaseName,
                                "user_id":    userID,
                        })
                        resp.State.RemoveResource(ctx)
                        return
                }</span>

                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "database":   databaseName,
                        "user_id":    userID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read database grant", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update state with current grant info
                data.Role = types.StringValue(response.Data.Role.Name)
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Database grant not found or no data returned from API",
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DatabaseGrantResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DatabaseGrantResourceModel
        var state DatabaseGrantResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        dbaasID := state.DBaaSID.ValueString()
        databaseName := state.Database.ValueString()
        userID := state.UserID.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" || userID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, Database name, and User ID are required to update the database grant",
                )
                return
        }</span>

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.GrantRequest{
                User: sdktypes.GrantUser{Username: userID},
                Role: sdktypes.GrantRole{Name: data.Role.ValueString()},
        }

        // Update the grant using the SDK
        response, err := r.client.Client.FromDatabase().Grants().Update(ctx, projectID, dbaasID, databaseName, userID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Database grant update error", map[string]interface{}{
                        "error":      err.Error(),
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "database":   databaseName,
                        "user_id":    userID,
                })
                resp.Diagnostics.AddError(
                        "Error updating database grant",
                        fmt.Sprintf("Unable to update database grant: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "database":   databaseName,
                        "user_id":    userID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update database grant", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update state with the response data
                data.Role = types.StringValue(response.Data.Role.Name)
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Database grant updated but no data returned from API",
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        tflog.Trace(ctx, "updated a Database Grant resource", map[string]interface{}{
                "grant_id": data.Id.ValueString(),
        })</span>
}

func (r *DatabaseGrantResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DatabaseGrantResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        databaseName := data.Database.ValueString()
        userID := data.UserID.ValueString()

        if projectID == "" || dbaasID == "" || databaseName == "" || userID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, Database name, and User ID are required to delete the database grant",
                )
                return
        }</span>

        // Delete the grant using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">grantID := data.Id.ValueString()
        err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().Grants().Delete(ctx, projectID, dbaasID, databaseName, userID, nil)
                }</span>,
                ExtractSDKError,
                "DatabaseGrant",
                grantID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting database grant",
                        fmt.Sprintf("Unable to delete database grant: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Database Grant resource", map[string]interface{}{
                "grant_id": grantID,
        })</span>
}

func (r *DatabaseGrantResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;DBaaSDataSource{}

func NewDBaaSDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;DBaaSDataSource{}
}</span>

type DBaaSDataSource struct {
        client *ArubaCloudClient
}

type DBaaSDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Zone          types.String `tfsdk:"zone"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        EngineID      types.String `tfsdk:"engine_id"`
        Flavor        types.String `tfsdk:"flavor"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        // Storage fields (flattened)
        StorageSizeGB             types.Int64 `tfsdk:"storage_size_gb"`
        AutoscalingEnabled        types.Bool  `tfsdk:"autoscaling_enabled"`
        AutoscalingAvailableSpace types.Int64 `tfsdk:"autoscaling_available_space"`
        AutoscalingStepSize       types.Int64 `tfsdk:"autoscaling_step_size"`
        // Network fields (flattened)
        VpcUriRef           types.String `tfsdk:"vpc_uri_ref"`
        SubnetUriRef        types.String `tfsdk:"subnet_uri_ref"`
        SecurityGroupUriRef types.String `tfsdk:"security_group_uri_ref"`
        ElasticIpUriRef     types.String `tfsdk:"elastic_ip_uri_ref"`
}

func (d *DBaaSDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_dbaas"
}</span>

func (d *DBaaSDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "DBaaS data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS identifier",
                                Required:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "DBaaS URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "DBaaS name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "DBaaS location",
                                Computed:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the DBaaS resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this DBaaS belongs to",
                                Computed:            true,
                        },
                        "engine_id": schema.StringAttribute{
                                MarkdownDescription: "Database engine ID (e.g., mysql-8.0, mssql-2022-web)",
                                Computed:            true,
                        },
                        "flavor": schema.StringAttribute{
                                MarkdownDescription: "DBaaS flavor name (e.g., DBO2A4)",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Computed:            true,
                        },
                        "storage_size_gb": schema.Int64Attribute{
                                MarkdownDescription: "Storage size in GB",
                                Computed:            true,
                        },
                        "autoscaling_enabled": schema.BoolAttribute{
                                MarkdownDescription: "Enable autoscaling",
                                Computed:            true,
                        },
                        "autoscaling_available_space": schema.Int64Attribute{
                                MarkdownDescription: "Minimum available space threshold in GB for autoscaling",
                                Computed:            true,
                        },
                        "autoscaling_step_size": schema.Int64Attribute{
                                MarkdownDescription: "Step size for autoscaling (in GB)",
                                Computed:            true,
                        },
                        "vpc_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "VPC URI reference",
                                Computed:            true,
                        },
                        "subnet_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Subnet URI reference",
                                Computed:            true,
                        },
                        "security_group_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Security Group URI reference",
                                Computed:            true,
                        },
                        "elastic_ip_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP URI reference",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *DBaaSDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *DBaaSDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data DBaaSDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Populate all fields with example data
        <span class="cov8" title="1">data.Uri = types.StringValue("/v2/dbaas/dbaas-68398923fb2cb026400d4d31")
        data.Name = types.StringValue("example-dbaas")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.Zone = types.StringValue("ITBG-1")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("database"),
                types.StringValue("production"),
        })
        data.ProjectID = types.StringValue("68398923fb2cb026400d4d31")
        data.EngineID = types.StringValue("mysql-8.0")
        data.Flavor = types.StringValue("DBO2A4")
        data.BillingPeriod = types.StringValue("Hour")
        // Storage fields
        data.StorageSizeGB = types.Int64Value(100)
        data.AutoscalingEnabled = types.BoolValue(true)
        data.AutoscalingAvailableSpace = types.Int64Value(10)
        data.AutoscalingStepSize = types.Int64Value(20)
        // Network fields
        data.VpcUriRef = types.StringValue("/v2/vpcs/vpc-68398923fb2cb026400d4d32")
        data.SubnetUriRef = types.StringValue("/v2/subnets/subnet-68398923fb2cb026400d4d33")
        data.SecurityGroupUriRef = types.StringValue("/v2/securitygroups/sg-68398923fb2cb026400d4d34")
        data.ElasticIpUriRef = types.StringValue("/v2/elasticips/eip-68398923fb2cb026400d4d35")
        tflog.Trace(ctx, "read a DBaaS data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "encoding/json"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DBaaSResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Zone          types.String `tfsdk:"zone"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        EngineID      types.String `tfsdk:"engine_id"`
        Flavor        types.String `tfsdk:"flavor"`
        Storage       types.Object `tfsdk:"storage"`
        Network       types.Object `tfsdk:"network"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

type DBaaSResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DBaaSResource{}
var _ resource.ResourceWithImportState = &amp;DBaaSResource{}

func NewDBaaSResource() resource.Resource <span class="cov8" title="1">{
        return &amp;DBaaSResource{}
}</span>

func (r *DBaaSResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_dbaas"
}</span>

func (r *DBaaSResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "DBaaS resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "DBaaS URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "DBaaS name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "DBaaS location",
                                Required:            true,
                        },
                        "zone": schema.StringAttribute{
                                MarkdownDescription: "Zone",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the DBaaS resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this DBaaS belongs to",
                                Required:            true,
                        },
                        "engine_id": schema.StringAttribute{
                                MarkdownDescription: "Database engine ID. Available engines are described in the [ArubaCloud API documentation](https://api.arubacloud.com/docs/metadata/#dbaas-engines). For example, `mysql-8.0` for MySQL version 8.0.",
                                Required:            true,
                        },
                        "flavor": schema.StringAttribute{
                                MarkdownDescription: "DBaaS flavor name. Available flavors are described in the [ArubaCloud API documentation](https://api.arubacloud.com/docs/metadata/#dbaas-flavors). For example, `DBO2A4` means 2 CPU and 4GB RAM.",
                                Required:            true,
                        },
                        "storage": schema.SingleNestedAttribute{
                                MarkdownDescription: "Storage configuration for the DBaaS instance",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "size_gb": schema.Int64Attribute{
                                                MarkdownDescription: "Storage size in GB for the DBaaS instance",
                                                Required:            true,
                                        },
                                        "autoscaling": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Autoscaling configuration for the DBaaS instance",
                                                Optional:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "enabled": schema.BoolAttribute{
                                                                MarkdownDescription: "Enable autoscaling",
                                                                Required:            true,
                                                        },
                                                        "available_space": schema.Int64Attribute{
                                                                MarkdownDescription: "Minimum available space threshold in GB. When the available storage falls below this value, autoscaling will increase the storage by the step_size amount.",
                                                                Required:            true,
                                                        },
                                                        "step_size": schema.Int64Attribute{
                                                                MarkdownDescription: "Step size for autoscaling (in GB)",
                                                                Required:            true,
                                                        },
                                                },
                                        },
                                },
                        },
                        "network": schema.SingleNestedAttribute{
                                MarkdownDescription: "Network configuration for the DBaaS instance",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "vpc_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "URI reference to the VPC resource (e.g., `arubacloud_vpc.example.uri`)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "subnet_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "URI reference to the Subnet resource (e.g., `arubacloud_subnet.example.uri`)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "security_group_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "URI reference to the Security Group resource (e.g., `arubacloud_securitygroup.example.uri`)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "elastic_ip_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "URI reference to the Elastic IP resource (e.g., `arubacloud_elasticip.example.uri`)",
                                                Optional:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                },
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *DBaaSResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DBaaSResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaaSResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a DBaaS instance",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">engineID := data.EngineID.ValueString()
        flavor := data.Flavor.ValueString()
        zone := data.Zone.ValueString()

        // Extract storage configuration from nested object
        if data.Storage.IsNull() || data.Storage.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Storage Configuration",
                        "Storage configuration is required to create a DBaaS instance",
                )
                return
        }</span>

        <span class="cov0" title="0">storageObj, diags := data.Storage.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">storageAttrs := storageObj.Attributes()
        sizeGBAttr, ok := storageAttrs["size_gb"].(types.Int64)
        if !ok || sizeGBAttr.IsNull() || sizeGBAttr.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Storage Size",
                        "Storage size_gb is required to create a DBaaS instance",
                )
                return
        }</span>
        <span class="cov0" title="0">storageSizeGB := int32(sizeGBAttr.ValueInt64())
        storageSizeGBPtr := &amp;storageSizeGB

        // Extract autoscaling if present
        var autoscaling *sdktypes.DBaaSAutoscaling
        if autoscalingAttr, ok := storageAttrs["autoscaling"]; ok &amp;&amp; autoscalingAttr != nil </span><span class="cov0" title="0">{
                if autoscalingObj, ok := autoscalingAttr.(types.Object); ok &amp;&amp; !autoscalingObj.IsNull() &amp;&amp; !autoscalingObj.IsUnknown() </span><span class="cov0" title="0">{
                        autoscalingObjValue, diags := autoscalingObj.ToObjectValue(ctx)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                autoscalingAttrs := autoscalingObjValue.Attributes()
                                enabledAttr, _ := autoscalingAttrs["enabled"].(types.Bool)
                                availableSpaceAttr, _ := autoscalingAttrs["available_space"].(types.Int64)
                                stepSizeAttr, _ := autoscalingAttrs["step_size"].(types.Int64)

                                if !enabledAttr.IsNull() &amp;&amp; !availableSpaceAttr.IsNull() &amp;&amp; !stepSizeAttr.IsNull() </span><span class="cov0" title="0">{
                                        enabled := enabledAttr.ValueBool()
                                        availableSpace := int32(availableSpaceAttr.ValueInt64())
                                        stepSize := int32(stepSizeAttr.ValueInt64())
                                        autoscaling = &amp;sdktypes.DBaaSAutoscaling{
                                                Enabled:        &amp;enabled,
                                                AvailableSpace: &amp;availableSpace,
                                                StepSize:       &amp;stepSize,
                                        }
                                }</span>
                        }
                }
        }

        // Extract network configuration from nested object
        <span class="cov0" title="0">if data.Network.IsNull() || data.Network.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Network Configuration",
                        "Network configuration is required to create a DBaaS instance",
                )
                return
        }</span>

        <span class="cov0" title="0">networkObj, diags := data.Network.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">networkAttrs := networkObj.Attributes()
        vpcUriRefAttr, ok := networkAttrs["vpc_uri_ref"].(types.String)
        if !ok || vpcUriRefAttr.IsNull() || vpcUriRefAttr.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing VPC URI Reference",
                        "VPC URI reference is required in network configuration",
                )
                return
        }</span>
        <span class="cov0" title="0">vpcUriRef := vpcUriRefAttr.ValueString()

        subnetUriRefAttr, ok := networkAttrs["subnet_uri_ref"].(types.String)
        if !ok || subnetUriRefAttr.IsNull() || subnetUriRefAttr.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Subnet URI Reference",
                        "Subnet URI reference is required in network configuration",
                )
                return
        }</span>
        <span class="cov0" title="0">subnetUriRef := subnetUriRefAttr.ValueString()

        securityGroupUriRefAttr, ok := networkAttrs["security_group_uri_ref"].(types.String)
        if !ok || securityGroupUriRefAttr.IsNull() || securityGroupUriRefAttr.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Security Group URI Reference",
                        "Security Group URI reference is required in network configuration",
                )
                return
        }</span>
        <span class="cov0" title="0">securityGroupUriRef := securityGroupUriRefAttr.ValueString()

        // Elastic IP is optional
        var elasticIpUriRef string
        if elasticIpAttr, ok := networkAttrs["elastic_ip_uri_ref"]; ok &amp;&amp; elasticIpAttr != nil </span><span class="cov0" title="0">{
                if elasticIpStr, ok := elasticIpAttr.(types.String); ok &amp;&amp; !elasticIpStr.IsNull() &amp;&amp; !elasticIpStr.IsUnknown() </span><span class="cov0" title="0">{
                        elasticIpUriRef = elasticIpStr.ValueString()
                }</span>
        }

        // Build the create request
        // Network configuration using DBaaSNetworking structure
        <span class="cov0" title="0">networking := &amp;sdktypes.DBaaSNetworking{
                VPCURI:           &amp;vpcUriRef,
                SubnetURI:        &amp;subnetUriRef,
                SecurityGroupURI: &amp;securityGroupUriRef,
        }

        // Add optional Elastic IP if provided
        if elasticIpUriRef != "" </span><span class="cov0" title="0">{
                networking.ElasticIPURI = &amp;elasticIpUriRef
        }</span>

        <span class="cov0" title="0">createRequest := sdktypes.DBaaSRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.DBaaSPropertiesRequest{
                        Engine: &amp;sdktypes.DBaaSEngine{
                                ID: &amp;engineID,
                        },
                        Flavor: &amp;sdktypes.DBaaSFlavor{
                                Name: &amp;flavor,
                        },
                        Storage: &amp;sdktypes.DBaaSStorage{
                                SizeGB: storageSizeGBPtr,
                        },
                        Autoscaling: autoscaling,
                        Networking:  networking,
                        Zone:        &amp;zone,
                },
        }

        // Add optional billing period
        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                billingPeriod := data.BillingPeriod.ValueString()
                createRequest.Properties.BillingPlan = &amp;sdktypes.DBaaSBillingPlan{
                        BillingPeriod: &amp;billingPeriod,
                }
        }</span>

        // Log the full request for debugging
        <span class="cov0" title="0">debugMap := map[string]interface{}{
                "project_id":         projectID,
                "name":               data.Name.ValueString(),
                "location":           data.Location.ValueString(),
                "zone":               zone,
                "engine_id":          engineID,
                "flavor":             flavor,
                "storage_size_gb":    storageSizeGB,
                "vpc_uri":            vpcUriRef,
                "subnet_uri":         subnetUriRef,
                "security_group_uri": securityGroupUriRef,
                "elastic_ip_uri":     elasticIpUriRef,
                "autoscaling":        autoscaling != nil,
        }
        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                debugMap["billing_period"] = data.BillingPeriod.ValueString()
        }</span>
        <span class="cov0" title="0">tflog.Debug(ctx, "DBaaS create request", debugMap)

        // Create the DBaaS instance using the SDK
        response, err := r.client.Client.FromDatabase().DBaaS().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "DBaaS create error", map[string]interface{}{
                        "error":      err.Error(),
                        "project_id": projectID,
                })
                resp.Diagnostics.AddError(
                        "Error creating DBaaS instance",
                        fmt.Sprintf("Unable to create DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                // Log detailed error information for debugging
                errorDetails := map[string]interface{}{
                        "project_id": projectID,
                        "engine_id":  engineID,
                        "flavor":     flavor,
                        "vpc_uri":    vpcUriRef,
                        "subnet_uri": subnetUriRef,
                        "sg_uri":     securityGroupUriRef,
                }

                // Log full request and error response JSON only on errors for debugging
                if requestJSON, jsonErr := json.MarshalIndent(createRequest, "", "  "); jsonErr == nil </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Full DBaaS create request JSON (error case)", map[string]interface{}{
                                "request_json": string(requestJSON),
                        })
                }</span>
                <span class="cov0" title="0">if errorJSON, jsonErr := json.MarshalIndent(response.Error, "", "  "); jsonErr == nil </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Full API error response JSON", map[string]interface{}{
                                "error_json": string(errorJSON),
                        })
                }</span>

                <span class="cov0" title="0">errorMsg := FormatAPIError(ctx, response.Error, "Failed to create DBaaS instance", errorDetails)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "DBaaS instance created but no data returned from API",
                )
                return
        }</span>

        // Wait for DBaaS to be active before returning
        // This ensures Terraform doesn't proceed until DBaaS is ready
        <span class="cov0" title="0">dbaasID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for DBaaS to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "DBaaS", dbaasID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "DBaaS Not Active",
                        fmt.Sprintf("DBaaS instance was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the DBaaS instance to populate URI
        <span class="cov0" title="0">getResp, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                dbaas := getResp.Data
                if dbaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*dbaas.Metadata.URI)
                }</span>

                // Build network object from extracted values
                <span class="cov0" title="0">networkAttrTypes := map[string]attr.Type{
                        "vpc_uri_ref":            types.StringType,
                        "subnet_uri_ref":         types.StringType,
                        "security_group_uri_ref": types.StringType,
                        "elastic_ip_uri_ref":     types.StringType,
                }
                networkAttrs := map[string]attr.Value{
                        "vpc_uri_ref":            types.StringValue(vpcUriRef),
                        "subnet_uri_ref":         types.StringValue(subnetUriRef),
                        "security_group_uri_ref": types.StringValue(securityGroupUriRef),
                }
                if elasticIpUriRef != "" </span><span class="cov0" title="0">{
                        networkAttrs["elastic_ip_uri_ref"] = types.StringValue(elasticIpUriRef)
                }</span> else<span class="cov0" title="0"> {
                        networkAttrs["elastic_ip_uri_ref"] = types.StringNull()
                }</span>
                <span class="cov0" title="0">networkObj, diags := types.ObjectValue(networkAttrTypes, networkAttrs)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Network = networkObj
                }</span>
        }

        <span class="cov0" title="0">tflog.Trace(ctx, "created a DBaaS resource", map[string]interface{}{
                "dbaas_id":   data.Id.ValueString(),
                "dbaas_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DBaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.Id.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to read the DBaaS instance",
                )
                return
        }</span>

        // Get DBaaS instance details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading DBaaS instance",
                        fmt.Sprintf("Unable to read DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read DBaaS instance", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                dbaas := response.Data

                if dbaas.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*dbaas.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if dbaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*dbaas.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if dbaas.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*dbaas.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if dbaas.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(dbaas.Metadata.LocationResponse.Value)
                }</span>
                // Zone is not in the response, preserve from state
                // data.Zone is already set from state in Read function
                <span class="cov0" title="0">if dbaas.Properties.Engine != nil &amp;&amp; dbaas.Properties.Engine.ID != nil </span><span class="cov0" title="0">{
                        data.EngineID = types.StringValue(*dbaas.Properties.Engine.ID)
                }</span>
                <span class="cov0" title="0">if dbaas.Properties.Flavor != nil &amp;&amp; dbaas.Properties.Flavor.Name != nil </span><span class="cov0" title="0">{
                        data.Flavor = types.StringValue(*dbaas.Properties.Flavor.Name)
                }</span>
                <span class="cov0" title="0">if dbaas.Properties.BillingPlan != nil &amp;&amp; dbaas.Properties.BillingPlan.BillingPeriod != nil </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(*dbaas.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        data.BillingPeriod = types.StringNull()
                }</span>

                // Build nested storage object from API response
                <span class="cov0" title="0">storageAttrs := make(map[string]attr.Value)
                storageAttrTypes := map[string]attr.Type{
                        "size_gb": types.Int64Type,
                        "autoscaling": types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "enabled":         types.BoolType,
                                        "available_space": types.Int64Type,
                                        "step_size":       types.Int64Type,
                                },
                        },
                }

                // Set storage size_gb
                if dbaas.Properties.Storage != nil &amp;&amp; dbaas.Properties.Storage.SizeGB != nil </span><span class="cov0" title="0">{
                        storageAttrs["size_gb"] = types.Int64Value(int64(*dbaas.Properties.Storage.SizeGB))
                }</span> else<span class="cov0" title="0"> {
                        // If not in API response, preserve from state
                        if !data.Storage.IsNull() &amp;&amp; !data.Storage.IsUnknown() </span><span class="cov0" title="0">{
                                storageObj, diags := data.Storage.ToObjectValue(ctx)
                                if !diags.HasError() </span><span class="cov0" title="0">{
                                        existingAttrs := storageObj.Attributes()
                                        if sizeGB, ok := existingAttrs["size_gb"]; ok </span><span class="cov0" title="0">{
                                                storageAttrs["size_gb"] = sizeGB
                                        }</span>
                                }
                        }
                }

                // Set autoscaling - preserve from state since API response structure may differ
                // DBaaSAutoscalingResponse has a different structure than DBaaSAutoscaling
                // We'll preserve autoscaling from state to maintain consistency
                <span class="cov0" title="0">if !data.Storage.IsNull() &amp;&amp; !data.Storage.IsUnknown() </span><span class="cov0" title="0">{
                        storageObj, diags := data.Storage.ToObjectValue(ctx)
                        if !diags.HasError() </span><span class="cov0" title="0">{
                                storageAttrsFromState := storageObj.Attributes()
                                if autoscalingAttr, ok := storageAttrsFromState["autoscaling"]; ok &amp;&amp; autoscalingAttr != nil </span><span class="cov0" title="0">{
                                        storageAttrs["autoscaling"] = autoscalingAttr
                                }</span> else<span class="cov0" title="0"> {
                                        // If no autoscaling in state, set to null
                                        storageAttrs["autoscaling"] = types.ObjectNull(map[string]attr.Type{
                                                "enabled":         types.BoolType,
                                                "available_space": types.Int64Type,
                                                "step_size":       types.Int64Type,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // If not in API response, preserve from state
                        if !data.Storage.IsNull() &amp;&amp; !data.Storage.IsUnknown() </span><span class="cov0" title="0">{
                                storageObj, diags := data.Storage.ToObjectValue(ctx)
                                if !diags.HasError() </span><span class="cov0" title="0">{
                                        existingAttrs := storageObj.Attributes()
                                        if autoscaling, ok := existingAttrs["autoscaling"]; ok </span><span class="cov0" title="0">{
                                                storageAttrs["autoscaling"] = autoscaling
                                        }</span>
                                }
                        }
                        // If no autoscaling in state either, set to null
                        <span class="cov0" title="0">if _, ok := storageAttrs["autoscaling"]; !ok </span><span class="cov0" title="0">{
                                storageAttrs["autoscaling"] = types.ObjectNull(map[string]attr.Type{
                                        "enabled":         types.BoolType,
                                        "available_space": types.Int64Type,
                                        "step_size":       types.Int64Type,
                                })
                        }</span>
                }

                // Build storage object
                <span class="cov0" title="0">storageObj, diags := types.ObjectValue(storageAttrTypes, storageAttrs)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Storage = storageObj
                }</span>

                // Build nested network object from state
                // Network configuration is preserved from state since it's not in API response
                <span class="cov0" title="0">networkAttrs := make(map[string]attr.Value)
                networkAttrTypes := map[string]attr.Type{
                        "vpc_uri_ref":            types.StringType,
                        "subnet_uri_ref":         types.StringType,
                        "security_group_uri_ref": types.StringType,
                        "elastic_ip_uri_ref":     types.StringType,
                }

                // Preserve network configuration from state
                if !data.Network.IsNull() &amp;&amp; !data.Network.IsUnknown() </span><span class="cov0" title="0">{
                        networkObj, diags := data.Network.ToObjectValue(ctx)
                        if !diags.HasError() </span><span class="cov0" title="0">{
                                existingNetworkAttrs := networkObj.Attributes()
                                networkAttrs["vpc_uri_ref"] = existingNetworkAttrs["vpc_uri_ref"]
                                networkAttrs["subnet_uri_ref"] = existingNetworkAttrs["subnet_uri_ref"]
                                networkAttrs["security_group_uri_ref"] = existingNetworkAttrs["security_group_uri_ref"]
                                if elasticIp, ok := existingNetworkAttrs["elastic_ip_uri_ref"]; ok </span><span class="cov0" title="0">{
                                        networkAttrs["elastic_ip_uri_ref"] = elasticIp
                                }</span> else<span class="cov0" title="0"> {
                                        networkAttrs["elastic_ip_uri_ref"] = types.StringNull()
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // If network not in state, set to null (should not happen)
                        networkAttrs["vpc_uri_ref"] = types.StringNull()
                        networkAttrs["subnet_uri_ref"] = types.StringNull()
                        networkAttrs["security_group_uri_ref"] = types.StringNull()
                        networkAttrs["elastic_ip_uri_ref"] = types.StringNull()
                }</span>

                // Build network object
                <span class="cov0" title="0">networkObj, diags := types.ObjectValue(networkAttrTypes, networkAttrs)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Network = networkObj
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(dbaas.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(dbaas.Metadata.Tags))
                        for i, tag := range dbaas.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DBaaSResourceModel
        var state DBaaSResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        dbaasID := state.Id.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to update the DBaaS instance",
                )
                return
        }</span>

        // Get current DBaaS instance details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current DBaaS instance",
                        fmt.Sprintf("Unable to get current DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "DBaaS Instance Not Found",
                        "DBaaS instance not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for DBaaS instance",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Extract storage configuration from plan's nested storage object
        <span class="cov0" title="0">var storageSizeGBPtr *int32
        var autoscaling *sdktypes.DBaaSAutoscaling

        if !data.Storage.IsNull() &amp;&amp; !data.Storage.IsUnknown() </span><span class="cov0" title="0">{
                storageObj, diags := data.Storage.ToObjectValue(ctx)
                if !diags.HasError() </span><span class="cov0" title="0">{
                        storageAttrs := storageObj.Attributes()

                        // Extract size_gb
                        if sizeGBAttr, ok := storageAttrs["size_gb"].(types.Int64); ok &amp;&amp; !sizeGBAttr.IsNull() &amp;&amp; !sizeGBAttr.IsUnknown() </span><span class="cov0" title="0">{
                                storageSizeGB := int32(sizeGBAttr.ValueInt64())
                                storageSizeGBPtr = &amp;storageSizeGB
                        }</span> else<span class="cov0" title="0"> if current.Properties.Storage != nil &amp;&amp; current.Properties.Storage.SizeGB != nil </span><span class="cov0" title="0">{
                                // Fallback to current if not in plan
                                sizeGB := *current.Properties.Storage.SizeGB
                                storageSizeGBPtr = &amp;sizeGB
                        }</span>

                        // Extract autoscaling if present
                        <span class="cov0" title="0">if autoscalingAttr, ok := storageAttrs["autoscaling"]; ok &amp;&amp; autoscalingAttr != nil </span><span class="cov0" title="0">{
                                if autoscalingObj, ok := autoscalingAttr.(types.Object); ok &amp;&amp; !autoscalingObj.IsNull() &amp;&amp; !autoscalingObj.IsUnknown() </span><span class="cov0" title="0">{
                                        autoscalingObjValue, diags := autoscalingObj.ToObjectValue(ctx)
                                        if !diags.HasError() </span><span class="cov0" title="0">{
                                                autoscalingAttrs := autoscalingObjValue.Attributes()
                                                enabledAttr, _ := autoscalingAttrs["enabled"].(types.Bool)
                                                availableSpaceAttr, _ := autoscalingAttrs["available_space"].(types.Int64)
                                                stepSizeAttr, _ := autoscalingAttrs["step_size"].(types.Int64)

                                                if !enabledAttr.IsNull() &amp;&amp; !availableSpaceAttr.IsNull() &amp;&amp; !stepSizeAttr.IsNull() </span><span class="cov0" title="0">{
                                                        enabled := enabledAttr.ValueBool()
                                                        availableSpace := int32(availableSpaceAttr.ValueInt64())
                                                        stepSize := int32(stepSizeAttr.ValueInt64())
                                                        autoscaling = &amp;sdktypes.DBaaSAutoscaling{
                                                                Enabled:        &amp;enabled,
                                                                AvailableSpace: &amp;availableSpace,
                                                                StepSize:       &amp;stepSize,
                                                        }
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> if current.Properties.Autoscaling != nil </span><span class="cov0" title="0">{
                                // Fallback to current if not in plan
                                // Convert from DBaaSAutoscalingResponse to DBaaSAutoscaling
                                // Note: Response type may have different structure, extract what we can
                                availableSpace := int32(0)
                                stepSize := int32(0)
                                if current.Properties.Autoscaling.AvailableSpace != nil </span><span class="cov0" title="0">{
                                        availableSpace = *current.Properties.Autoscaling.AvailableSpace
                                }</span>
                                <span class="cov0" title="0">if current.Properties.Autoscaling.StepSize != nil </span><span class="cov0" title="0">{
                                        stepSize = *current.Properties.Autoscaling.StepSize
                                }</span>
                                // Default enabled to true if autoscaling exists (we can't determine from response)
                                <span class="cov0" title="0">enabled := true
                                autoscaling = &amp;sdktypes.DBaaSAutoscaling{
                                        Enabled:        &amp;enabled,
                                        AvailableSpace: &amp;availableSpace,
                                        StepSize:       &amp;stepSize,
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // If storage not in plan, use current values
                if current.Properties.Storage != nil &amp;&amp; current.Properties.Storage.SizeGB != nil </span><span class="cov0" title="0">{
                        sizeGB := *current.Properties.Storage.SizeGB
                        storageSizeGBPtr = &amp;sizeGB
                }</span>
                <span class="cov0" title="0">if current.Properties.Autoscaling != nil </span><span class="cov0" title="0">{
                        // Convert from DBaaSAutoscalingResponse to DBaaSAutoscaling
                        availableSpace := int32(0)
                        stepSize := int32(0)
                        if current.Properties.Autoscaling.AvailableSpace != nil </span><span class="cov0" title="0">{
                                availableSpace = *current.Properties.Autoscaling.AvailableSpace
                        }</span>
                        <span class="cov0" title="0">if current.Properties.Autoscaling.StepSize != nil </span><span class="cov0" title="0">{
                                stepSize = *current.Properties.Autoscaling.StepSize
                        }</span>
                        // Default enabled to true if autoscaling exists
                        <span class="cov0" title="0">enabled := true
                        autoscaling = &amp;sdktypes.DBaaSAutoscaling{
                                Enabled:        &amp;enabled,
                                AvailableSpace: &amp;availableSpace,
                                StepSize:       &amp;stepSize,
                        }</span>
                }
        }

        // Build update request - only name and tags can be updated
        <span class="cov0" title="0">updateRequest := sdktypes.DBaaSRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.DBaaSPropertiesRequest{
                        // Preserve current engine if it exists
                        Engine: func() *sdktypes.DBaaSEngine </span><span class="cov0" title="0">{
                                if current.Properties.Engine != nil </span><span class="cov0" title="0">{
                                        return &amp;sdktypes.DBaaSEngine{
                                                ID: current.Properties.Engine.ID,
                                        }
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        // Preserve current flavor if it exists
                        Flavor: func() *sdktypes.DBaaSFlavor <span class="cov0" title="0">{
                                if current.Properties.Flavor != nil </span><span class="cov0" title="0">{
                                        return &amp;sdktypes.DBaaSFlavor{
                                                Name: current.Properties.Flavor.Name,
                                        }
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        // Use storage from plan or current
                        Storage: func() *sdktypes.DBaaSStorage <span class="cov0" title="0">{
                                if storageSizeGBPtr != nil </span><span class="cov0" title="0">{
                                        return &amp;sdktypes.DBaaSStorage{
                                                SizeGB: storageSizeGBPtr,
                                        }
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        Autoscaling: autoscaling,
                        // Preserve zone from plan or state (zone is immutable)
                        Zone: func() *string <span class="cov0" title="0">{
                                if !data.Zone.IsNull() &amp;&amp; !data.Zone.IsUnknown() </span><span class="cov0" title="0">{
                                        zone := data.Zone.ValueString()
                                        return &amp;zone
                                }</span>
                                // Preserve from state if not in plan
                                <span class="cov0" title="0">if !state.Zone.IsNull() &amp;&amp; !state.Zone.IsUnknown() </span><span class="cov0" title="0">{
                                        zone := state.Zone.ValueString()
                                        return &amp;zone
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        // Preserve networking from Terraform state (networking is immutable)
                        // Extract from state since response type structure may differ
                        Networking: func() *sdktypes.DBaaSNetworking <span class="cov0" title="0">{
                                if !state.Network.IsNull() &amp;&amp; !state.Network.IsUnknown() </span><span class="cov0" title="0">{
                                        networkObj, diags := state.Network.ToObjectValue(ctx)
                                        if !diags.HasError() </span><span class="cov0" title="0">{
                                                networkAttrs := networkObj.Attributes()
                                                vpcUriAttr, _ := networkAttrs["vpc_uri_ref"].(types.String)
                                                subnetUriAttr, _ := networkAttrs["subnet_uri_ref"].(types.String)
                                                securityGroupUriAttr, _ := networkAttrs["security_group_uri_ref"].(types.String)
                                                elasticIpUriAttr, _ := networkAttrs["elastic_ip_uri_ref"].(types.String)

                                                networking := &amp;sdktypes.DBaaSNetworking{}
                                                if !vpcUriAttr.IsNull() &amp;&amp; !vpcUriAttr.IsUnknown() </span><span class="cov0" title="0">{
                                                        vpcUri := vpcUriAttr.ValueString()
                                                        networking.VPCURI = &amp;vpcUri
                                                }</span>
                                                <span class="cov0" title="0">if !subnetUriAttr.IsNull() &amp;&amp; !subnetUriAttr.IsUnknown() </span><span class="cov0" title="0">{
                                                        subnetUri := subnetUriAttr.ValueString()
                                                        networking.SubnetURI = &amp;subnetUri
                                                }</span>
                                                <span class="cov0" title="0">if !securityGroupUriAttr.IsNull() &amp;&amp; !securityGroupUriAttr.IsUnknown() </span><span class="cov0" title="0">{
                                                        securityGroupUri := securityGroupUriAttr.ValueString()
                                                        networking.SecurityGroupURI = &amp;securityGroupUri
                                                }</span>
                                                <span class="cov0" title="0">if !elasticIpUriAttr.IsNull() &amp;&amp; !elasticIpUriAttr.IsUnknown() </span><span class="cov0" title="0">{
                                                        elasticIpUri := elasticIpUriAttr.ValueString()
                                                        networking.ElasticIPURI = &amp;elasticIpUri
                                                }</span>
                                                <span class="cov0" title="0">return networking</span>
                                        }
                                }
                                <span class="cov0" title="0">return nil</span>
                        }(),
                },
        }

        // Add billing period if provided, otherwise preserve from current
        <span class="cov0" title="0">if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                billingPeriod := data.BillingPeriod.ValueString()
                updateRequest.Properties.BillingPlan = &amp;sdktypes.DBaaSBillingPlan{
                        BillingPeriod: &amp;billingPeriod,
                }
        }</span> else<span class="cov0" title="0"> if current.Properties.BillingPlan != nil &amp;&amp; current.Properties.BillingPlan.BillingPeriod != nil </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.DBaaSBillingPlan{
                        BillingPeriod: current.Properties.BillingPlan.BillingPeriod,
                }
        }</span>

        // Update the DBaaS instance using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().DBaaS().Update(ctx, projectID, dbaasID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating DBaaS instance",
                        fmt.Sprintf("Unable to update DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                }

                // Log full request and error response JSON only on errors for debugging
                if requestJSON, jsonErr := json.MarshalIndent(updateRequest, "", "  "); jsonErr == nil </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Full DBaaS update request JSON (error case)", map[string]interface{}{
                                "request_json": string(requestJSON),
                        })
                }</span>
                <span class="cov0" title="0">if errorJSON, jsonErr := json.MarshalIndent(response.Error, "", "  "); jsonErr == nil </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Full API error response JSON", map[string]interface{}{
                                "error_json": string(errorJSON),
                        })
                }</span>

                <span class="cov0" title="0">errorMsg := FormatAPIError(ctx, response.Error, "Failed to update DBaaS instance", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Preserve immutable fields from state
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Uri = state.Uri
        // Preserve network configuration from state
        // Network configuration is immutable, so we preserve it from state
        data.Network = state.Network
        // Storage is preserved from plan (which includes autoscaling)

        // Re-read the DBaaS instance to get the latest state
        getResp, err := r.client.Client.FromDatabase().DBaaS().Get(ctx, projectID, dbaasID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                dbaas := getResp.Data
                if dbaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*dbaas.Metadata.URI)
                }</span>
                // Note: Network URI references are preserved from state
                // They are not yet available in the SDK response structure
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DBaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.Id.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to delete the DBaaS instance",
                )
                return
        }</span>

        // Delete the DBaaS instance using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().DBaaS().Delete(ctx, projectID, dbaasID, nil)
                }</span>,
                ExtractSDKError,
                "DBaaS",
                dbaasID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting DBaaS instance",
                        fmt.Sprintf("Unable to delete DBaaS instance: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a DBaaS resource", map[string]interface{}{
                "dbaas_id": dbaasID,
        })</span>
}

func (r *DBaaSResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DBaaSUserDataSourceModel struct {
        Id       types.String `tfsdk:"id"`
        DBaaSID  types.String `tfsdk:"dbaas_id"`
        Username types.String `tfsdk:"username"`
        Password types.String `tfsdk:"password"`
}

type DBaaSUserDataSource struct {
        client *ArubaCloudClient
}

var _ datasource.DataSource = &amp;DBaaSUserDataSource{}

func NewDBaaSUserDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;DBaaSUserDataSource{}
}</span>

func (d *DBaaSUserDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_dbaasuser"
}</span>

func (d *DBaaSUserDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "DBaaS User data source",
                Attributes: map[string]schema.Attribute{
                        "username": schema.StringAttribute{
                                MarkdownDescription: "Username for the DBaaS user (lookup key)",
                                Required:            true,
                        },
                        "id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS User identifier",
                                Computed:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this user belongs to",
                                Computed:            true,
                        },
                        "password": schema.StringAttribute{
                                MarkdownDescription: "Password for the DBaaS user",
                                Computed:            true,
                                Sensitive:           true,
                        },
                },
        }
}</span>

func (d *DBaaSUserDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected DataSource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *DBaaSUserDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data DBaaSUserDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response
        <span class="cov8" title="1">data.Id = types.StringValue("dbaasuser-id")
        data.Password = types.StringValue("simulated-password")
        tflog.Trace(ctx, "read a DBaaS User data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type DBaaSUserResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        ProjectID types.String `tfsdk:"project_id"`
        DBaaSID   types.String `tfsdk:"dbaas_id"`
        Username  types.String `tfsdk:"username"`
        Password  types.String `tfsdk:"password"`
}

type DBaaSUserResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;DBaaSUserResource{}
var _ resource.ResourceWithImportState = &amp;DBaaSUserResource{}

func NewDBaaSUserResource() resource.Resource <span class="cov8" title="1">{
        return &amp;DBaaSUserResource{}
}</span>

func (r *DBaaSUserResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_dbaasuser"
}</span>

func (r *DBaaSUserResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "DBaaS User resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS User identifier (same as username)",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "DBaaS User URI",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this user belongs to",
                                Required:            true,
                        },
                        "dbaas_id": schema.StringAttribute{
                                MarkdownDescription: "DBaaS ID this user belongs to",
                                Required:            true,
                        },
                        "username": schema.StringAttribute{
                                MarkdownDescription: "Username for the DBaaS user",
                                Required:            true,
                        },
                        "password": schema.StringAttribute{
                                MarkdownDescription: "Password for the DBaaS user",
                                Required:            true,
                                Sensitive:           true,
                        },
                },
        }
}</span>

func (r *DBaaSUserResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *DBaaSUserResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaaSUserResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()

        if projectID == "" || dbaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and DBaaS ID are required to create a DBaaS user",
                )
                return
        }</span>

        // Build the create request
        // Password must be base64 encoded for the API
        <span class="cov0" title="0">passwordBase64 := base64.StdEncoding.EncodeToString([]byte(data.Password.ValueString()))
        createRequest := sdktypes.UserRequest{
                Username: data.Username.ValueString(),
                Password: passwordBase64,
        }

        // Create the user using the SDK
        response, err := r.client.Client.FromDatabase().Users().Create(ctx, projectID, dbaasID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "DBaaS user create error", map[string]interface{}{
                        "error":      err.Error(),
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                })
                resp.Diagnostics.AddError(
                        "Error creating DBaaS user",
                        fmt.Sprintf("Unable to create DBaaS user: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                // Log full request JSON only on errors for debugging
                if requestJSON, jsonErr := json.MarshalIndent(createRequest, "", "  "); jsonErr == nil </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Full DBaaS user create request JSON (error case)", map[string]interface{}{
                                "request_json": string(requestJSON),
                        })
                }</span>

                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "username":   data.Username.ValueString(),
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create DBaaS user", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // User uses username as ID
                data.Id = types.StringValue(response.Data.Username)
                // UserResponse doesn't have Metadata.URI
                data.Uri = types.StringNull()
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "DBaaS user created but no data returned from API",
                )
                return
        }</span>

        // Wait for DBaaS User to be active before returning
        // This ensures Terraform doesn't proceed until User is ready
        <span class="cov0" title="0">username := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromDatabase().Users().Get(ctx, projectID, dbaasID, username, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Users don't have a status field, so if we can get it, it's ready
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        return "Active", nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for DBaaS User to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "DBaaSUser", username, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "DBaaS User Not Active",
                        fmt.Sprintf("DBaaS user was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a DBaaS User resource", map[string]interface{}{
                "user_id":  data.Id.ValueString(),
                "username": data.Username.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSUserResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data DBaaSUserResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        username := data.Id.ValueString()

        if projectID == "" || dbaasID == "" || username == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Username are required to read the DBaaS user",
                )
                return
        }</span>

        // Get user details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromDatabase().Users().Get(ctx, projectID, dbaasID, username, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading DBaaS user",
                        fmt.Sprintf("Unable to read DBaaS user: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "username":   username,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read DBaaS user", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                user := response.Data
                data.Id = types.StringValue(user.Username)
                // UserResponse doesn't have Metadata.URI
                data.Uri = types.StringNull()
                data.Username = types.StringValue(user.Username)
                // Password is not returned from API, so we keep the existing value
        }</span> else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSUserResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DBaaSUserResourceModel
        var state DBaaSUserResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        dbaasID := state.DBaaSID.ValueString()
        username := state.Id.ValueString()

        if projectID == "" || dbaasID == "" || username == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Username are required to update the DBaaS user",
                )
                return
        }</span>

        // Only password can be updated
        // Password must be base64 encoded for the API
        <span class="cov0" title="0">passwordBase64 := base64.StdEncoding.EncodeToString([]byte(data.Password.ValueString()))
        updateRequest := sdktypes.UserRequest{
                Username: username,
                Password: passwordBase64,
        }

        // Update the user using the SDK
        response, err := r.client.Client.FromDatabase().Users().Update(ctx, projectID, dbaasID, username, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating DBaaS user",
                        fmt.Sprintf("Unable to update DBaaS user: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "dbaas_id":   dbaasID,
                        "username":   username,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update DBaaS user", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(response.Data.Username)
                // UserResponse doesn't have Metadata.URI
                data.Uri = types.StringNull()
                data.Username = types.StringValue(response.Data.Username)
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.DBaaSID = state.DBaaSID

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update ID from response (username can change, so use response)
                data.Id = types.StringValue(response.Data.Username)
                data.Username = types.StringValue(response.Data.Username)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *DBaaSUserResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DBaaSUserResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        dbaasID := data.DBaaSID.ValueString()
        username := data.Id.ValueString()

        if projectID == "" || dbaasID == "" || username == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, DBaaS ID, and Username are required to delete the DBaaS user",
                )
                return
        }</span>

        // Delete the user using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromDatabase().Users().Delete(ctx, projectID, dbaasID, username, nil)
                }</span>,
                ExtractSDKError,
                "DBaaSUser",
                username,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting DBaaS user",
                        fmt.Sprintf("Unable to delete DBaaS user: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a DBaaS User resource", map[string]interface{}{
                "user_id": username,
        })</span>
}

func (r *DBaaSUserResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;ElasticIPDataSource{}

func NewElasticIPDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;ElasticIPDataSource{}
}</span>

type ElasticIPDataSource struct {
        client *ArubaCloudClient
}

type ElasticIPDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        ProjectId     types.String `tfsdk:"project_id"`
        Address       types.String `tfsdk:"address"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Tags          types.List   `tfsdk:"tags"`
}

func (d *ElasticIPDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_elasticip"
}</span>

func (d *ElasticIPDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Elastic IP data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP location",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Elastic IP belongs to",
                                Computed:            true,
                        },
                        "address": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP address",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period for the Elastic IP",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Elastic IP",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *ElasticIPDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *ElasticIPDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data ElasticIPDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Name = types.StringValue("example-elasticip")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.ProjectId = types.StringValue("68398923fb2cb026400d4d31")
        data.Address = types.StringValue("203.0.113.10")
        data.BillingPeriod = types.StringValue("Hour")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("public-ip"),
                types.StringValue("production"),
        })

        tflog.Trace(ctx, "read an Elastic IP data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;ElasticIPResource{}
var _ resource.ResourceWithImportState = &amp;ElasticIPResource{}

func NewElasticIPResource() resource.Resource <span class="cov8" title="1">{
        return &amp;ElasticIPResource{}
}</span>

type ElasticIPResource struct {
        client *ArubaCloudClient
}

type ElasticIPResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        Address       types.String `tfsdk:"address"`
        ProjectId     types.String `tfsdk:"project_id"`
}

func (r *ElasticIPResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_elasticip"
}</span>

func (r *ElasticIPResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Project resource",
                Attributes: map[string]schema.Attribute{
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Elastic IP",
                                Optional:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period for the Elastic IP (only 'hourly' allowed)",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                                // Validators removed for v1.16.1 compatibility
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Elastic IP belongs to",
                                Required:            true,
                        },
                        "address": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP address (computed from ElasticIpPropertiesResponse)",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP Identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Elastic IP URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
        }
}</span>

func (r *ElasticIPResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *ElasticIPResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ElasticIPResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create an Elastic IP",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.ElasticIPRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.ElasticIPPropertiesRequest{
                        BillingPlan: sdktypes.BillingPeriodResource{
                                BillingPeriod: func() string </span><span class="cov0" title="0">{
                                        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                                return data.BillingPeriod.ValueString()
                                        }</span>
                                        // Default to "hourly" if not provided
                                        <span class="cov0" title="0">return "hourly"</span>
                                }(),
                        },
                },
        }

        // Create the Elastic IP using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().ElasticIPs().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating Elastic IP",
                        fmt.Sprintf("Unable to create Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create Elastic IP", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span> else<span class="cov0" title="0"> {
                        resp.Diagnostics.AddError(
                                "Invalid API Response",
                                "Elastic IP created but ID not returned from API",
                        )
                        return
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                        data.Address = types.StringValue(*response.Data.Properties.Address)
                }</span>
                // Set billing_period from create response if available
                <span class="cov0" title="0">if response.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(response.Data.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> if data.BillingPeriod.IsNull() || data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                        // Fallback to plan value or default
                        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span>{<span class="cov0" title="0">
                                // Keep plan value
                        }</span> else<span class="cov0" title="0"> {
                                data.BillingPeriod = types.StringValue("hourly")
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Elastic IP created but no data returned from API",
                )
                return
        }</span>

        // Wait for Elastic IP to be active before returning (ElasticIP is referenced by CloudServer)
        // This ensures Terraform doesn't proceed to create dependent resources until ElasticIP is ready
        <span class="cov0" title="0">eipID := data.Id.ValueString()
        if eipID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Elastic IP ID",
                        "Elastic IP ID is required but was not set",
                )
                return
        }</span>
        <span class="cov0" title="0">checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Elastic IP to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "ElasticIP", eipID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Elastic IP Not Active",
                        fmt.Sprintf("Elastic IP was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Read the Elastic IP again to get the address and ensure ID is set (it might not be available immediately after creation)
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Update address from re-read response (computed field from ElasticIpPropertiesResponse)
                <span class="cov0" title="0">if getResp.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                        data.Address = types.StringValue(*getResp.Data.Properties.Address)
                }</span> else<span class="cov0" title="0"> {
                        // Address might not be available yet, set to null
                        data.Address = types.StringNull()
                }</span>
                // Update billing_period from the re-read response
                <span class="cov0" title="0">if getResp.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(getResp.Data.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to plan value or default if not available
                        if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span>{<span class="cov0" title="0">
                                // Keep the plan value
                        }</span> else<span class="cov0" title="0"> {
                                data.BillingPeriod = types.StringValue("hourly")
                        }</span>
                }
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Elastic IP after creation: %v", err))
                // Ensure billing_period is set even if re-read fails
                if data.BillingPeriod.IsNull() || data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue("hourly")
                }</span>
        }

        <span class="cov0" title="0">tflog.Trace(ctx, "created an Elastic IP resource", map[string]interface{}{
                "elasticip_id":   data.Id.ValueString(),
                "elasticip_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ElasticIPResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ElasticIPResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        eipID := data.Id.ValueString()

        // If ID is unknown or empty, the resource doesn't exist yet (e.g., during plan for new resources)
        // Return early without error - this is expected behavior
        if data.Id.IsUnknown() || data.Id.IsNull() || eipID == "" </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Elastic IP ID is unknown or empty, skipping read", map[string]interface{}{
                        "eip_id": eipID,
                })
                return
        }</span>

        // Project ID should always be set, but check to be safe
        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to read the Elastic IP",
                )
                return
        }</span>

        // Get Elastic IP details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading Elastic IP",
                        fmt.Sprintf("Unable to read Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "eip_id":     eipID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read Elastic IP", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                eip := response.Data

                if eip.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*eip.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if eip.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*eip.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if eip.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*eip.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if eip.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(eip.Metadata.LocationResponse.Value)
                }</span>
                // Update address from response (computed field from ElasticIpPropertiesResponse)
                <span class="cov0" title="0">if eip.Properties.Address != nil </span><span class="cov0" title="0">{
                        data.Address = types.StringValue(*eip.Properties.Address)
                }</span> else<span class="cov0" title="0"> {
                        // Address might not be available yet, set to null
                        data.Address = types.StringNull()
                }</span>
                // Always set billing_period from API response (it's always available from API)
                // This ensures it's always in state, preventing false changes in plan
                <span class="cov0" title="0">if eip.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(eip.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to "hourly" if API doesn't return it (shouldn't happen)
                        data.BillingPeriod = types.StringValue("hourly")
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(eip.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(eip.Metadata.Tags))
                        for i, tag := range eip.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ElasticIPResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ElasticIPResourceModel
        var state ElasticIPResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Use IDs from state (they are immutable)
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        eipID := state.Id.ValueString()

        if projectID == "" || eipID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Elastic IP ID are required to update the Elastic IP",
                )
                return
        }</span>

        // Get current Elastic IP details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current Elastic IP",
                        fmt.Sprintf("Unable to get current Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Elastic IP Not Found",
                        "Elastic IP not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if Elastic IP is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update During Creation",
                        "Cannot update Elastic IP while it is in 'InCreation' state. Please wait until the Elastic IP is fully created.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for Elastic IP",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build the update request
        <span class="cov0" title="0">updateRequest := sdktypes.ElasticIPRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.ElasticIPPropertiesRequest{
                        BillingPlan: current.Properties.BillingPlan,
                },
        }

        // Update the Elastic IP using the SDK
        response, err := r.client.Client.FromNetwork().ElasticIPs().Update(ctx, projectID, eipID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating Elastic IP",
                        fmt.Sprintf("Unable to update Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                        "eip_id":     eipID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update Elastic IP", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.Uri = state.Uri         // Preserve URI from state
        data.Address = state.Address // Preserve address from state (computed field)

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If no URI in response, re-read the Elastic IP to get the latest state
                        getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                                }</span> else<span class="cov0" title="0"> {
                                        data.Uri = state.Uri // Fallback to state if not available
                                }</span>
                                // Also update address from re-read if available
                                <span class="cov0" title="0">if getResp.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                                        data.Address = types.StringValue(*getResp.Data.Properties.Address)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if re-read fails
                        }</span>
                }
                // Update address from response if available (computed field from ElasticIpPropertiesResponse)
                <span class="cov0" title="0">if response.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                        data.Address = types.StringValue(*response.Data.Properties.Address)
                }</span>
                // Always set billing_period from response if available
                <span class="cov0" title="0">if response.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(response.Data.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        // If not in response, re-read to get it
                        getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                                        data.BillingPeriod = types.StringValue(getResp.Data.Properties.BillingPlan.BillingPeriod)
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback to state or default
                                        if !state.BillingPeriod.IsNull() &amp;&amp; !state.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                                data.BillingPeriod = state.BillingPeriod
                                        }</span> else<span class="cov0" title="0"> {
                                                data.BillingPeriod = types.StringValue("hourly")
                                        }</span>
                                }
                                // Also update address from re-read if available (computed field from ElasticIpPropertiesResponse)
                                <span class="cov0" title="0">if getResp.Data.Properties.Address != nil </span><span class="cov0" title="0">{
                                        data.Address = types.StringValue(*getResp.Data.Properties.Address)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Fallback to state or default
                                if !state.BillingPeriod.IsNull() &amp;&amp; !state.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                        data.BillingPeriod = state.BillingPeriod
                                }</span> else<span class="cov0" title="0"> {
                                        data.BillingPeriod = types.StringValue("hourly")
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI from state and set billing_period from API or default
                data.Uri = state.Uri
                // Re-read to get billing_period
                getResp, err := r.client.Client.FromNetwork().ElasticIPs().Get(ctx, projectID, eipID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                                data.BillingPeriod = types.StringValue(getResp.Data.Properties.BillingPlan.BillingPeriod)
                        }</span> else<span class="cov0" title="0"> {
                                if !state.BillingPeriod.IsNull() &amp;&amp; !state.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                        data.BillingPeriod = state.BillingPeriod
                                }</span> else<span class="cov0" title="0"> {
                                        data.BillingPeriod = types.StringValue("hourly")
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Fallback to state or default
                        if !state.BillingPeriod.IsNull() &amp;&amp; !state.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                                data.BillingPeriod = state.BillingPeriod
                        }</span> else<span class="cov0" title="0"> {
                                data.BillingPeriod = types.StringValue("hourly")
                        }</span>
                }
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ElasticIPResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ElasticIPResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        eipID := data.Id.ValueString()

        // If ID is unknown or empty, the resource doesn't exist (e.g., during plan or if never created)
        // Return early without error - this is expected behavior
        if data.Id.IsUnknown() || data.Id.IsNull() || eipID == "" </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Elastic IP ID is unknown or empty, skipping delete", map[string]interface{}{
                        "eip_id": eipID,
                })
                return
        }</span>

        // Project ID should always be set, but check to be safe
        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to delete the Elastic IP",
                )
                return
        }</span>

        // Delete the Elastic IP using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().ElasticIPs().Delete(ctx, projectID, eipID, nil)
                }</span>,
                ExtractSDKError,
                "ElasticIP",
                eipID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting Elastic IP",
                        fmt.Sprintf("Unable to delete Elastic IP: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted an Elastic IP resource", map[string]interface{}{
                "elasticip_id": eipID,
        })</span>
}

func (r *ElasticIPResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "encoding/json"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// FormatAPIError formats an API error response with detailed validation errors
// from the Extensions field, providing user-friendly error messages.
func FormatAPIError(ctx context.Context, err *sdktypes.ErrorResponse, baseMsg string, logContext map[string]interface{}) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return baseMsg
        }</span>

        <span class="cov0" title="0">errorMsg := baseMsg
        if err.Title != nil </span><span class="cov0" title="0">{
                errorMsg = fmt.Sprintf("%s: %s", errorMsg, *err.Title)
        }</span>
        <span class="cov0" title="0">if err.Detail != nil </span><span class="cov0" title="0">{
                errorMsg = fmt.Sprintf("%s - %s", errorMsg, *err.Detail)
        }</span>

        // Add validation errors if present in Extensions
        <span class="cov0" title="0">if len(err.Extensions) &gt; 0 </span><span class="cov0" title="0">{
                if errorsArray, ok := err.Extensions["errors"].([]interface{}); ok </span><span class="cov0" title="0">{
                        errorMsg += "\n\nValidation Errors:"
                        for _, errItem := range errorsArray </span><span class="cov0" title="0">{
                                if errMap, ok := errItem.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        fieldName := errMap["fieldName"]
                                        errorMessage := errMap["errorMessage"]
                                        errorMsg += fmt.Sprintf("\n  - %v: %v", fieldName, errorMessage)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // If not in expected format, include all extensions
                        errorMsg += "\n\nAdditional Error Details:"
                        for key, value := range err.Extensions </span><span class="cov0" title="0">{
                                errorMsg += fmt.Sprintf("\n  - %s: %v", key, value)
                        }</span>
                }
        }

        // Build error details for logging
        <span class="cov0" title="0">errorDetails := logContext
        if errorDetails == nil </span><span class="cov0" title="0">{
                errorDetails = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">if err.Title != nil </span><span class="cov0" title="0">{
                errorDetails["error_title"] = *err.Title
        }</span>
        <span class="cov0" title="0">if err.Detail != nil </span><span class="cov0" title="0">{
                errorDetails["error_detail"] = *err.Detail
        }</span>
        <span class="cov0" title="0">if err.Status != nil </span><span class="cov0" title="0">{
                errorDetails["error_status"] = *err.Status
        }</span>
        <span class="cov0" title="0">if err.Type != nil </span><span class="cov0" title="0">{
                errorDetails["error_type"] = *err.Type
        }</span>
        <span class="cov0" title="0">if err.Extensions != nil </span><span class="cov0" title="0">{
                errorDetails["error_extensions"] = err.Extensions
        }</span>

        // Log full error response JSON
        <span class="cov0" title="0">if errorJSON, jsonErr := json.MarshalIndent(err, "", "  "); jsonErr == nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Full API error response JSON", map[string]interface{}{
                        "error_json": string(errorJSON),
                })
        }</span>

        <span class="cov0" title="0">tflog.Error(ctx, "API request failed", errorDetails)

        return errorMsg</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;KaaSDataSource{}

func NewKaaSDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;KaaSDataSource{}
}</span>

type KaaSDataSource struct {
        client *ArubaCloudClient
}

type KaaSDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        ManagementIP  types.String `tfsdk:"management_ip"`
        // Network fields (flattened)
        VpcUriRef         types.String `tfsdk:"vpc_uri_ref"`
        SubnetUriRef      types.String `tfsdk:"subnet_uri_ref"`
        NodeCIDRAddress   types.String `tfsdk:"node_cidr_address"`
        NodeCIDRName      types.String `tfsdk:"node_cidr_name"`
        SecurityGroupName types.String `tfsdk:"security_group_name"`
        PodCIDR           types.String `tfsdk:"pod_cidr"`
        // Settings fields (flattened)
        KubernetesVersion types.String `tfsdk:"kubernetes_version"`
        NodePools         types.List   `tfsdk:"node_pools"`
        HA                types.Bool   `tfsdk:"ha"`
}

type NodePoolDataSourceModel struct {
        Name        types.String `tfsdk:"name"`
        Nodes       types.Int64  `tfsdk:"nodes"`
        Instance    types.String `tfsdk:"instance"`
        Zone        types.String `tfsdk:"zone"`
        Autoscaling types.Bool   `tfsdk:"autoscaling"`
        MinCount    types.Int64  `tfsdk:"min_count"`
        MaxCount    types.Int64  `tfsdk:"max_count"`
}

func (d *KaaSDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_kaas"
}</span>

func (d *KaaSDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "KaaS data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "KaaS identifier",
                                Required:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "KaaS URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "KaaS name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "KaaS location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the KaaS resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this KaaS resource belongs to",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Computed:            true,
                        },
                        "management_ip": schema.StringAttribute{
                                MarkdownDescription: "Management IP address",
                                Computed:            true,
                        },
                        "vpc_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "VPC URI reference",
                                Computed:            true,
                        },
                        "subnet_uri_ref": schema.StringAttribute{
                                MarkdownDescription: "Subnet URI reference",
                                Computed:            true,
                        },
                        "node_cidr_address": schema.StringAttribute{
                                MarkdownDescription: "Node CIDR address in CIDR notation",
                                Computed:            true,
                        },
                        "node_cidr_name": schema.StringAttribute{
                                MarkdownDescription: "Node CIDR name",
                                Computed:            true,
                        },
                        "security_group_name": schema.StringAttribute{
                                MarkdownDescription: "Security group name",
                                Computed:            true,
                        },
                        "pod_cidr": schema.StringAttribute{
                                MarkdownDescription: "Pod CIDR in CIDR notation",
                                Computed:            true,
                        },
                        "kubernetes_version": schema.StringAttribute{
                                MarkdownDescription: "Kubernetes version",
                                Computed:            true,
                        },
                        "node_pools": schema.ListNestedAttribute{
                                MarkdownDescription: "Node pools configuration",
                                Computed:            true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "name": schema.StringAttribute{
                                                        MarkdownDescription: "Node pool name",
                                                        Computed:            true,
                                                },
                                                "nodes": schema.Int64Attribute{
                                                        MarkdownDescription: "Number of nodes in the node pool",
                                                        Computed:            true,
                                                },
                                                "instance": schema.StringAttribute{
                                                        MarkdownDescription: "KaaS flavor name for nodes",
                                                        Computed:            true,
                                                },
                                                "zone": schema.StringAttribute{
                                                        MarkdownDescription: "Datacenter/zone code for nodes",
                                                        Computed:            true,
                                                },
                                                "autoscaling": schema.BoolAttribute{
                                                        MarkdownDescription: "Enable autoscaling for node pool",
                                                        Computed:            true,
                                                },
                                                "min_count": schema.Int64Attribute{
                                                        MarkdownDescription: "Minimum number of nodes for autoscaling",
                                                        Computed:            true,
                                                },
                                                "max_count": schema.Int64Attribute{
                                                        MarkdownDescription: "Maximum number of nodes for autoscaling",
                                                        Computed:            true,
                                                },
                                        },
                                },
                        },
                        "ha": schema.BoolAttribute{
                                MarkdownDescription: "High availability",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *KaaSDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *KaaSDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data KaaSDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Populate all fields with example data
        <span class="cov8" title="1">data.Uri = types.StringValue("/v2/kaas/kaas-68398923fb2cb026400d4d31")
        data.Name = types.StringValue("example-kaas")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("kubernetes"),
                types.StringValue("production"),
        })
        data.ProjectID = types.StringValue("68398923fb2cb026400d4d31")
        data.BillingPeriod = types.StringValue("Hour")
        data.ManagementIP = types.StringValue("10.0.2.100")
        // Network fields
        data.VpcUriRef = types.StringValue("/v2/vpcs/vpc-68398923fb2cb026400d4d32")
        data.SubnetUriRef = types.StringValue("/v2/subnets/subnet-68398923fb2cb026400d4d33")
        data.NodeCIDRAddress = types.StringValue("10.0.2.0/24")
        data.NodeCIDRName = types.StringValue("kaas-nodes")
        data.SecurityGroupName = types.StringValue("kaas-security-group")
        data.PodCIDR = types.StringValue("10.0.3.0/24")
        // Settings fields
        data.KubernetesVersion = types.StringValue("1.33.2")
        data.HA = types.BoolValue(true)

        // Create node pools
        nodePoolType := types.ObjectType{
                AttrTypes: map[string]attr.Type{
                        "name":        types.StringType,
                        "nodes":       types.Int64Type,
                        "instance":    types.StringType,
                        "zone":        types.StringType,
                        "autoscaling": types.BoolType,
                        "min_count":   types.Int64Type,
                        "max_count":   types.Int64Type,
                },
        }
        nodePool1, _ := types.ObjectValue(nodePoolType.AttrTypes, map[string]attr.Value{
                "name":        types.StringValue("pool-1"),
                "nodes":       types.Int64Value(3),
                "instance":    types.StringValue("K2A4"),
                "zone":        types.StringValue("ITBG-1"),
                "autoscaling": types.BoolValue(true),
                "min_count":   types.Int64Value(2),
                "max_count":   types.Int64Value(5),
        })
        nodePool2, _ := types.ObjectValue(nodePoolType.AttrTypes, map[string]attr.Value{
                "name":        types.StringValue("pool-2"),
                "nodes":       types.Int64Value(2),
                "instance":    types.StringValue("K4A8"),
                "zone":        types.StringValue("ITBG-2"),
                "autoscaling": types.BoolValue(false),
                "min_count":   types.Int64Null(),
                "max_count":   types.Int64Null(),
        })
        data.NodePools = types.ListValueMust(nodePoolType, []attr.Value{nodePool1, nodePool2})
        tflog.Trace(ctx, "read a KaaS data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KaaSResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;KaaSResource{}
var _ resource.ResourceWithImportState = &amp;KaaSResource{}

func NewKaaSResource() resource.Resource <span class="cov8" title="1">{
        return &amp;KaaSResource{}
}</span>

type KaaSResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        ProjectID     types.String `tfsdk:"project_id"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        ManagementIP  types.String `tfsdk:"management_ip"`
        Network       types.Object `tfsdk:"network"`
        Settings      types.Object `tfsdk:"settings"`
}

type KaaSNodeCIDRModel struct {
        Address types.String `tfsdk:"address"`
        Name    types.String `tfsdk:"name"`
}

type KaaSNodePoolModel struct {
        Name        types.String `tfsdk:"name"`
        Nodes       types.Int64  `tfsdk:"nodes"`
        Instance    types.String `tfsdk:"instance"`
        Zone        types.String `tfsdk:"zone"`
        Autoscaling types.Bool   `tfsdk:"autoscaling"`
        MinCount    types.Int64  `tfsdk:"min_count"`
        MaxCount    types.Int64  `tfsdk:"max_count"`
}

type KaaSNetworkModel struct {
        VpcUriRef         types.String `tfsdk:"vpc_uri_ref"`
        SubnetUriRef      types.String `tfsdk:"subnet_uri_ref"`
        NodeCIDR          types.Object `tfsdk:"node_cidr"`
        SecurityGroupName types.String `tfsdk:"security_group_name"`
        PodCIDR           types.String `tfsdk:"pod_cidr"`
}

type KaaSSettingsModel struct {
        KubernetesVersion types.String `tfsdk:"kubernetes_version"`
        NodePools         types.List   `tfsdk:"node_pools"`
        HA                types.Bool   `tfsdk:"ha"`
}

func (r *KaaSResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_kaas"
}</span>

func (r *KaaSResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "KaaS (Kubernetes as a Service) resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "KaaS identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "KaaS URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "KaaS name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "KaaS location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the KaaS resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this KaaS resource belongs to",
                                Required:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Optional:            true,
                        },
                        "management_ip": schema.StringAttribute{
                                MarkdownDescription: "Management IP address (available when KaaS is active)",
                                Computed:            true,
                        },
                        "network": schema.SingleNestedAttribute{
                                MarkdownDescription: "Network configuration for the KaaS cluster",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "vpc_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "VPC URI reference for the KaaS resource (e.g., arubacloud_vpc.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "subnet_uri_ref": schema.StringAttribute{
                                                MarkdownDescription: "Subnet URI reference for the KaaS resource (e.g., arubacloud_subnet.example.uri)",
                                                Required:            true,
                                                PlanModifiers: []planmodifier.String{
                                                        stringplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "node_cidr": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Node CIDR configuration",
                                                Required:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "address": schema.StringAttribute{
                                                                MarkdownDescription: "Node CIDR address in CIDR notation (e.g., 10.0.0.0/24)",
                                                                Required:            true,
                                                        },
                                                        "name": schema.StringAttribute{
                                                                MarkdownDescription: "Node CIDR name",
                                                                Required:            true,
                                                        },
                                                },
                                        },
                                        "security_group_name": schema.StringAttribute{
                                                MarkdownDescription: "Security group name",
                                                Required:            true,
                                        },
                                        "pod_cidr": schema.StringAttribute{
                                                MarkdownDescription: "Pod CIDR in CIDR notation (e.g., 10.0.3.0/24)",
                                                Optional:            true,
                                        },
                                },
                        },
                        "settings": schema.SingleNestedAttribute{
                                MarkdownDescription: "Kubernetes cluster settings",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "kubernetes_version": schema.StringAttribute{
                                                MarkdownDescription: "Kubernetes version. Available versions are described in the [ArubaCloud API documentation](https://api.arubacloud.com/docs/metadata#kubernetes-version). For example, `1.33.2`.",
                                                Required:            true,
                                        },
                                        "node_pools": schema.ListNestedAttribute{
                                                MarkdownDescription: "Node pools configuration",
                                                Required:            true,
                                                NestedObject: schema.NestedAttributeObject{
                                                        Attributes: map[string]schema.Attribute{
                                                                "name": schema.StringAttribute{
                                                                        MarkdownDescription: "Node pool name",
                                                                        Required:            true,
                                                                },
                                                                "nodes": schema.Int64Attribute{
                                                                        MarkdownDescription: "Number of nodes in the node pool",
                                                                        Required:            true,
                                                                },
                                                                "instance": schema.StringAttribute{
                                                                        MarkdownDescription: "KaaS flavor name for nodes. Available flavors are described in the [ArubaCloud API documentation](https://api.arubacloud.com/docs/metadata#kaas-flavors). For example, `K2A4` means 2 CPU, 4GB RAM, and 40GB storage.",
                                                                        Required:            true,
                                                                },
                                                                "zone": schema.StringAttribute{
                                                                        MarkdownDescription: "Datacenter/zone code for nodes",
                                                                        Required:            true,
                                                                },
                                                                "autoscaling": schema.BoolAttribute{
                                                                        MarkdownDescription: "Enable autoscaling for node pool",
                                                                        Optional:            true,
                                                                },
                                                                "min_count": schema.Int64Attribute{
                                                                        MarkdownDescription: "Minimum number of nodes for autoscaling",
                                                                        Optional:            true,
                                                                },
                                                                "max_count": schema.Int64Attribute{
                                                                        MarkdownDescription: "Maximum number of nodes for autoscaling",
                                                                        Optional:            true,
                                                                },
                                                        },
                                                },
                                        },
                                        "ha": schema.BoolAttribute{
                                                MarkdownDescription: "High availability",
                                                Optional:            true,
                                        },
                                },
                        },
                },
        }
}</span>

func (r *KaaSResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *KaaSResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data KaaSResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a KaaS cluster",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract Network configuration
        <span class="cov0" title="0">var networkModel KaaSNetworkModel
        diags := data.Network.As(ctx, &amp;networkModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Use VPC and Subnet URIs from network config
        <span class="cov0" title="0">vpcURI := networkModel.VpcUriRef.ValueString()
        subnetURI := networkModel.SubnetUriRef.ValueString()

        // Extract Node CIDR from network config
        var nodeCIDRModel KaaSNodeCIDRModel
        diags = networkModel.NodeCIDR.As(ctx, &amp;nodeCIDRModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract Settings configuration
        <span class="cov0" title="0">var settingsModel KaaSSettingsModel
        diags = data.Settings.As(ctx, &amp;settingsModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract Node Pools from settings
        <span class="cov0" title="0">var nodePoolModels []KaaSNodePoolModel
        if !settingsModel.NodePools.IsNull() &amp;&amp; !settingsModel.NodePools.IsUnknown() </span><span class="cov0" title="0">{
                diags := settingsModel.NodePools.ElementsAs(ctx, &amp;nodePoolModels, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">if len(nodePoolModels) == 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Node Pools",
                        "At least one node pool is required",
                )
                return
        }</span>

        // Build node pools
        <span class="cov0" title="0">nodePools := make([]sdktypes.NodePoolProperties, len(nodePoolModels))
        for i, np := range nodePoolModels </span><span class="cov0" title="0">{
                nodePool := sdktypes.NodePoolProperties{
                        Name:        np.Name.ValueString(),
                        Nodes:       int32(np.Nodes.ValueInt64()),
                        Instance:    np.Instance.ValueString(),
                        Zone:        np.Zone.ValueString(),
                        Autoscaling: np.Autoscaling.ValueBool(),
                }
                if !np.MinCount.IsNull() &amp;&amp; np.MinCount.ValueInt64() &gt; 0 </span><span class="cov0" title="0">{
                        minCount := int32(np.MinCount.ValueInt64())
                        nodePool.MinCount = &amp;minCount
                }</span>
                <span class="cov0" title="0">if !np.MaxCount.IsNull() &amp;&amp; np.MaxCount.ValueInt64() &gt; 0 </span><span class="cov0" title="0">{
                        maxCount := int32(np.MaxCount.ValueInt64())
                        nodePool.MaxCount = &amp;maxCount
                }</span>
                <span class="cov0" title="0">nodePools[i] = nodePool</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.KaaSRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.KaaSPropertiesRequest{
                        VPC: sdktypes.ReferenceResource{
                                URI: vpcURI,
                        },
                        Subnet: sdktypes.ReferenceResource{
                                URI: subnetURI,
                        },
                        NodeCIDR: sdktypes.NodeCIDRProperties{
                                Address: nodeCIDRModel.Address.ValueString(),
                                Name:    nodeCIDRModel.Name.ValueString(),
                        },
                        SecurityGroup: sdktypes.SecurityGroupProperties{
                                Name: networkModel.SecurityGroupName.ValueString(),
                        },
                        KubernetesVersion: sdktypes.KubernetesVersionInfo{
                                Value: settingsModel.KubernetesVersion.ValueString(),
                        },
                        NodePools: nodePools,
                },
        }

        // Add optional fields
        if !networkModel.PodCIDR.IsNull() &amp;&amp; !networkModel.PodCIDR.IsUnknown() </span><span class="cov0" title="0">{
                podCIDR := networkModel.PodCIDR.ValueString()
                createRequest.Properties.PodCIDR = &amp;podCIDR
        }</span>

        <span class="cov0" title="0">if !settingsModel.HA.IsNull() &amp;&amp; !settingsModel.HA.IsUnknown() </span><span class="cov0" title="0">{
                ha := settingsModel.HA.ValueBool()
                createRequest.Properties.HA = &amp;ha
        }</span>

        <span class="cov0" title="0">if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                createRequest.Properties.BillingPlan = sdktypes.BillingPeriodResource{
                        BillingPeriod: data.BillingPeriod.ValueString(),
                }
        }</span>

        // Create the KaaS cluster using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromContainer().KaaS().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating KaaS cluster",
                        fmt.Sprintf("Unable to create KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create KaaS cluster", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>

                // Build Network object from response
                <span class="cov0" title="0">networkAttrs := map[string]attr.Value{
                        "vpc_uri_ref":         types.StringValue(vpcURI),
                        "subnet_uri_ref":      types.StringValue(subnetURI),
                        "security_group_name": types.StringValue(networkModel.SecurityGroupName.ValueString()),
                }

                // Set node_cidr
                nodeCIDRAttrs := map[string]attr.Value{
                        "address": types.StringValue(nodeCIDRModel.Address.ValueString()),
                        "name":    types.StringValue(nodeCIDRModel.Name.ValueString()),
                }
                nodeCIDRObj, diags := types.ObjectValue(map[string]attr.Type{
                        "address": types.StringType,
                        "name":    types.StringType,
                }, nodeCIDRAttrs)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">networkAttrs["node_cidr"] = nodeCIDRObj

                // Set pod_cidr
                if !networkModel.PodCIDR.IsNull() &amp;&amp; !networkModel.PodCIDR.IsUnknown() </span><span class="cov0" title="0">{
                        networkAttrs["pod_cidr"] = types.StringValue(networkModel.PodCIDR.ValueString())
                }</span> else<span class="cov0" title="0"> {
                        networkAttrs["pod_cidr"] = types.StringNull()
                }</span>

                // Create Network object
                <span class="cov0" title="0">networkObj, diags := types.ObjectValue(map[string]attr.Type{
                        "vpc_uri_ref":         types.StringType,
                        "subnet_uri_ref":      types.StringType,
                        "node_cidr":           types.ObjectType{AttrTypes: map[string]attr.Type{"address": types.StringType, "name": types.StringType}},
                        "security_group_name": types.StringType,
                        "pod_cidr":            types.StringType,
                }, networkAttrs)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">data.Network = networkObj

                // Build Settings object from response
                settingsAttrs := map[string]attr.Value{
                        "kubernetes_version": types.StringValue(settingsModel.KubernetesVersion.ValueString()),
                        "node_pools":         settingsModel.NodePools,
                }

                // Set HA
                if !settingsModel.HA.IsNull() &amp;&amp; !settingsModel.HA.IsUnknown() </span><span class="cov0" title="0">{
                        settingsAttrs["ha"] = types.BoolValue(settingsModel.HA.ValueBool())
                }</span> else<span class="cov0" title="0"> {
                        settingsAttrs["ha"] = types.BoolNull()
                }</span>

                // Create Settings object
                <span class="cov0" title="0">settingsObj, diags := types.ObjectValue(map[string]attr.Type{
                        "kubernetes_version": types.StringType,
                        "node_pools": types.ListType{
                                ElemType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "name":        types.StringType,
                                                "nodes":       types.Int64Type,
                                                "instance":    types.StringType,
                                                "zone":        types.StringType,
                                                "autoscaling": types.BoolType,
                                                "min_count":   types.Int64Type,
                                                "max_count":   types.Int64Type,
                                        },
                                },
                        },
                        "ha": types.BoolType,
                }, settingsAttrs)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">data.Settings = settingsObj</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "KaaS cluster created but no data returned from API",
                )
                return
        }</span>

        // Wait for KaaS to be active before returning
        // This ensures Terraform doesn't proceed until KaaS is ready
        <span class="cov0" title="0">kaasID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for KaaS to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "KaaS", kaasID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "KaaS Not Active",
                        fmt.Sprintf("KaaS cluster was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read to get management IP now that KaaS is active
        <span class="cov0" title="0">finalGetResp, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
        if err == nil &amp;&amp; finalGetResp != nil &amp;&amp; finalGetResp.Data != nil </span><span class="cov0" title="0">{
                if finalGetResp.Data.Properties.ManagementIP != nil &amp;&amp; *finalGetResp.Data.Properties.ManagementIP != "" </span><span class="cov0" title="0">{
                        data.ManagementIP = types.StringValue(*finalGetResp.Data.Properties.ManagementIP)
                }</span> else<span class="cov0" title="0"> {
                        data.ManagementIP = types.StringNull()
                }</span>
        }

        <span class="cov0" title="0">tflog.Trace(ctx, "created a KaaS resource", map[string]interface{}{
                "kaas_id":   data.Id.ValueString(),
                "kaas_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KaaSResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data KaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Preserve the original state to fallback for fields not returned by API
        <span class="cov0" title="0">var originalState KaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;originalState)...)

        projectID := data.ProjectID.ValueString()
        kaasID := data.Id.ValueString()

        if projectID == "" || kaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KaaS ID are required to read the KaaS cluster",
                )
                return
        }</span>

        // Get KaaS cluster details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading KaaS cluster",
                        fmt.Sprintf("Unable to read KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "kaas_id":    kaasID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read KaaS cluster", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                kaas := response.Data

                if kaas.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*kaas.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if kaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*kaas.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if kaas.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*kaas.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if kaas.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(kaas.Metadata.LocationResponse.Value)
                }</span>

                <span class="cov0" title="0">if kaas.Properties.BillingPlan != nil &amp;&amp; kaas.Properties.BillingPlan.BillingPeriod != nil </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(*kaas.Properties.BillingPlan.BillingPeriod)
                }</span>

                // Set Management IP if available
                <span class="cov0" title="0">if kaas.Properties.ManagementIP != nil &amp;&amp; *kaas.Properties.ManagementIP != "" </span><span class="cov0" title="0">{
                        data.ManagementIP = types.StringValue(*kaas.Properties.ManagementIP)
                }</span> else<span class="cov0" title="0"> {
                        data.ManagementIP = types.StringNull()
                }</span>

                // Build Network object
                <span class="cov0" title="0">networkAttrs := map[string]attr.Value{
                        "vpc_uri_ref":         types.StringNull(),
                        "subnet_uri_ref":      types.StringNull(),
                        "node_cidr":           types.ObjectNull(map[string]attr.Type{"address": types.StringType, "name": types.StringType}),
                        "security_group_name": types.StringNull(),
                        "pod_cidr":            types.StringNull(),
                }

                if kaas.Properties.VPC.URI != nil &amp;&amp; *kaas.Properties.VPC.URI != "" </span><span class="cov0" title="0">{
                        networkAttrs["vpc_uri_ref"] = types.StringValue(*kaas.Properties.VPC.URI)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.Subnet.URI != nil &amp;&amp; *kaas.Properties.Subnet.URI != "" </span><span class="cov0" title="0">{
                        networkAttrs["subnet_uri_ref"] = types.StringValue(*kaas.Properties.Subnet.URI)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.SecurityGroup.Name != nil &amp;&amp; *kaas.Properties.SecurityGroup.Name != "" </span><span class="cov0" title="0">{
                        networkAttrs["security_group_name"] = types.StringValue(*kaas.Properties.SecurityGroup.Name)
                }</span> else<span class="cov0" title="0"> if !originalState.Network.IsNull() &amp;&amp; !originalState.Network.IsUnknown() </span><span class="cov0" title="0">{
                        // Preserve security_group_name from state if API doesn't return it
                        var originalNetwork KaaSNetworkModel
                        diags := originalState.Network.As(ctx, &amp;originalNetwork, basetypes.ObjectAsOptions{})
                        if !diags.HasError() &amp;&amp; !originalNetwork.SecurityGroupName.IsNull() </span><span class="cov0" title="0">{
                                networkAttrs["security_group_name"] = originalNetwork.SecurityGroupName
                        }</span>
                }
                <span class="cov0" title="0">if kaas.Properties.NodeCIDR.Address != nil &amp;&amp; *kaas.Properties.NodeCIDR.Address != "" </span><span class="cov0" title="0">{
                        nodeCIDRName := ""
                        if kaas.Properties.NodeCIDR.Name != nil &amp;&amp; *kaas.Properties.NodeCIDR.Name != "" </span><span class="cov0" title="0">{
                                nodeCIDRName = *kaas.Properties.NodeCIDR.Name
                        }</span> else<span class="cov0" title="0"> if !originalState.Network.IsNull() &amp;&amp; !originalState.Network.IsUnknown() </span><span class="cov0" title="0">{
                                // Preserve node_cidr.name from state if API doesn't return it
                                var originalNetwork KaaSNetworkModel
                                diags := originalState.Network.As(ctx, &amp;originalNetwork, basetypes.ObjectAsOptions{})
                                if !diags.HasError() &amp;&amp; !originalNetwork.NodeCIDR.IsNull() </span><span class="cov0" title="0">{
                                        var originalNodeCIDR struct {
                                                Address types.String `tfsdk:"address"`
                                                Name    types.String `tfsdk:"name"`
                                        }
                                        diagsNodeCIDR := originalNetwork.NodeCIDR.As(ctx, &amp;originalNodeCIDR, basetypes.ObjectAsOptions{})
                                        if !diagsNodeCIDR.HasError() &amp;&amp; !originalNodeCIDR.Name.IsNull() </span><span class="cov0" title="0">{
                                                nodeCIDRName = originalNodeCIDR.Name.ValueString()
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">nodeCIDRObj, diags := types.ObjectValue(map[string]attr.Type{
                                "address": types.StringType,
                                "name":    types.StringType,
                        }, map[string]attr.Value{
                                "address": types.StringValue(*kaas.Properties.NodeCIDR.Address),
                                "name":    types.StringValue(nodeCIDRName),
                        })
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                networkAttrs["node_cidr"] = nodeCIDRObj
                        }</span>
                }
                <span class="cov0" title="0">if kaas.Properties.PodCIDR != nil &amp;&amp; kaas.Properties.PodCIDR.Address != nil </span><span class="cov0" title="0">{
                        networkAttrs["pod_cidr"] = types.StringValue(*kaas.Properties.PodCIDR.Address)
                }</span>

                // Create Network object
                <span class="cov0" title="0">networkObj, diags := types.ObjectValue(map[string]attr.Type{
                        "vpc_uri_ref":         types.StringType,
                        "subnet_uri_ref":      types.StringType,
                        "node_cidr":           types.ObjectType{AttrTypes: map[string]attr.Type{"address": types.StringType, "name": types.StringType}},
                        "security_group_name": types.StringType,
                        "pod_cidr":            types.StringType,
                }, networkAttrs)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">data.Network = networkObj

                // Build Settings object
                settingsAttrs := map[string]attr.Value{
                        "kubernetes_version": types.StringNull(),
                        "node_pools":         types.ListNull(types.ObjectType{AttrTypes: map[string]attr.Type{"name": types.StringType, "nodes": types.Int64Type, "instance": types.StringType, "zone": types.StringType, "autoscaling": types.BoolType, "min_count": types.Int64Type, "max_count": types.Int64Type}}),
                        "ha":                 types.BoolNull(),
                }

                if kaas.Properties.KubernetesVersion.Value != nil </span><span class="cov0" title="0">{
                        settingsAttrs["kubernetes_version"] = types.StringValue(*kaas.Properties.KubernetesVersion.Value)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.HA != nil </span><span class="cov0" title="0">{
                        settingsAttrs["ha"] = types.BoolValue(*kaas.Properties.HA)
                }</span>

                // Build node pools
                <span class="cov0" title="0">if kaas.Properties.NodePools != nil &amp;&amp; len(*kaas.Properties.NodePools) &gt; 0 </span><span class="cov0" title="0">{
                        nodePoolValues := make([]attr.Value, 0)
                        for _, np := range *kaas.Properties.NodePools </span><span class="cov0" title="0">{
                                nodePoolMap := map[string]attr.Value{
                                        "name": types.StringValue(func() string </span><span class="cov0" title="0">{
                                                if np.Name != nil </span><span class="cov0" title="0">{
                                                        return *np.Name
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "nodes": types.Int64Value(func() int64 <span class="cov0" title="0">{
                                                if np.Nodes != nil </span><span class="cov0" title="0">{
                                                        return int64(*np.Nodes)
                                                }</span>
                                                <span class="cov0" title="0">return 0</span>
                                        }()),
                                        "instance": types.StringValue(func() string <span class="cov0" title="0">{
                                                if np.Instance != nil &amp;&amp; np.Instance.Name != nil </span><span class="cov0" title="0">{
                                                        return *np.Instance.Name
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "zone": types.StringValue(func() string <span class="cov0" title="0">{
                                                if np.DataCenter != nil &amp;&amp; np.DataCenter.Code != nil </span><span class="cov0" title="0">{
                                                        return *np.DataCenter.Code
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "autoscaling": types.BoolValue(np.Autoscaling),
                                }
                                <span class="cov0" title="0">if np.MinCount != nil </span><span class="cov0" title="0">{
                                        nodePoolMap["min_count"] = types.Int64Value(int64(*np.MinCount))
                                }</span> else<span class="cov0" title="0"> {
                                        nodePoolMap["min_count"] = types.Int64Null()
                                }</span>
                                <span class="cov0" title="0">if np.MaxCount != nil </span><span class="cov0" title="0">{
                                        nodePoolMap["max_count"] = types.Int64Value(int64(*np.MaxCount))
                                }</span> else<span class="cov0" title="0"> {
                                        nodePoolMap["max_count"] = types.Int64Null()
                                }</span>

                                <span class="cov0" title="0">nodePoolObj, diags := types.ObjectValue(map[string]attr.Type{
                                        "name":        types.StringType,
                                        "nodes":       types.Int64Type,
                                        "instance":    types.StringType,
                                        "zone":        types.StringType,
                                        "autoscaling": types.BoolType,
                                        "min_count":   types.Int64Type,
                                        "max_count":   types.Int64Type,
                                }, nodePoolMap)
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        nodePoolValues = append(nodePoolValues, nodePoolObj)
                                }</span>
                        }
                        <span class="cov0" title="0">nodePoolsList, diags := types.ListValue(types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "name":        types.StringType,
                                        "nodes":       types.Int64Type,
                                        "instance":    types.StringType,
                                        "zone":        types.StringType,
                                        "autoscaling": types.BoolType,
                                        "min_count":   types.Int64Type,
                                        "max_count":   types.Int64Type,
                                },
                        }, nodePoolValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                settingsAttrs["node_pools"] = nodePoolsList
                        }</span>
                } else<span class="cov0" title="0"> if !originalState.Settings.IsNull() &amp;&amp; !originalState.Settings.IsUnknown() </span><span class="cov0" title="0">{
                        // If API doesn't return node_pools, preserve from original state
                        var originalSettings KaaSSettingsModel
                        diags := originalState.Settings.As(ctx, &amp;originalSettings, basetypes.ObjectAsOptions{})
                        if !diags.HasError() &amp;&amp; !originalSettings.NodePools.IsNull() </span><span class="cov0" title="0">{
                                settingsAttrs["node_pools"] = originalSettings.NodePools
                        }</span>
                }

                // Create Settings object
                <span class="cov0" title="0">settingsObj, diags := types.ObjectValue(map[string]attr.Type{
                        "kubernetes_version": types.StringType,
                        "node_pools": types.ListType{
                                ElemType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "name":        types.StringType,
                                                "nodes":       types.Int64Type,
                                                "instance":    types.StringType,
                                                "zone":        types.StringType,
                                                "autoscaling": types.BoolType,
                                                "min_count":   types.Int64Type,
                                                "max_count":   types.Int64Type,
                                        },
                                },
                        },
                        "ha": types.BoolType,
                }, settingsAttrs)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">data.Settings = settingsObj

                // Update tags
                if len(kaas.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(kaas.Metadata.Tags))
                        for i, tag := range kaas.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KaaSResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data KaaSResourceModel
        var state KaaSResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        kaasID := state.Id.ValueString()

        if projectID == "" || kaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KaaS ID are required to update the KaaS cluster",
                )
                return
        }</span>

        // Get current KaaS cluster details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current KaaS cluster",
                        fmt.Sprintf("Unable to get current KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "KaaS Cluster Not Found",
                        "KaaS cluster not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for KaaS cluster",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        var diags diag.Diagnostics
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags = data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Extract Settings configuration
        <span class="cov0" title="0">var settingsModel KaaSSettingsModel
        diags = data.Settings.As(ctx, &amp;settingsModel, basetypes.ObjectAsOptions{})
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract Node Pools from settings
        <span class="cov0" title="0">var nodePoolModels []KaaSNodePoolModel
        if !settingsModel.NodePools.IsNull() &amp;&amp; !settingsModel.NodePools.IsUnknown() </span><span class="cov0" title="0">{
                diags := settingsModel.NodePools.ElementsAs(ctx, &amp;nodePoolModels, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build node pools
        <span class="cov0" title="0">nodePools := make([]sdktypes.NodePoolProperties, len(nodePoolModels))
        for i, np := range nodePoolModels </span><span class="cov0" title="0">{
                nodePool := sdktypes.NodePoolProperties{
                        Name:        np.Name.ValueString(),
                        Nodes:       int32(np.Nodes.ValueInt64()),
                        Instance:    np.Instance.ValueString(),
                        Zone:        np.Zone.ValueString(),
                        Autoscaling: np.Autoscaling.ValueBool(),
                }
                if !np.MinCount.IsNull() &amp;&amp; np.MinCount.ValueInt64() &gt; 0 </span><span class="cov0" title="0">{
                        minCount := int32(np.MinCount.ValueInt64())
                        nodePool.MinCount = &amp;minCount
                }</span>
                <span class="cov0" title="0">if !np.MaxCount.IsNull() &amp;&amp; np.MaxCount.ValueInt64() &gt; 0 </span><span class="cov0" title="0">{
                        maxCount := int32(np.MaxCount.ValueInt64())
                        nodePool.MaxCount = &amp;maxCount
                }</span>
                <span class="cov0" title="0">nodePools[i] = nodePool</span>
        }

        // Build Kubernetes version update
        <span class="cov0" title="0">kubernetesVersionValue := settingsModel.KubernetesVersion.ValueString()
        if kubernetesVersionValue == "" &amp;&amp; current.Properties.KubernetesVersion.Value != nil </span><span class="cov0" title="0">{
                kubernetesVersionValue = *current.Properties.KubernetesVersion.Value
        }</span>

        <span class="cov0" title="0">kubernetesVersionUpdate := sdktypes.KubernetesVersionInfoUpdate{
                Value: kubernetesVersionValue,
        }

        // Build update request
        updateRequest := sdktypes.KaaSUpdateRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.KaaSPropertiesUpdateRequest{
                        KubernetesVersion: kubernetesVersionUpdate,
                        NodePools:         nodePools,
                },
        }

        // Add optional fields
        if !settingsModel.HA.IsNull() &amp;&amp; !settingsModel.HA.IsUnknown() </span><span class="cov0" title="0">{
                ha := settingsModel.HA.ValueBool()
                updateRequest.Properties.HA = &amp;ha
        }</span> else<span class="cov0" title="0"> if current.Properties.HA != nil </span><span class="cov0" title="0">{
                updateRequest.Properties.HA = current.Properties.HA
        }</span>

        <span class="cov0" title="0">if !data.BillingPeriod.IsNull() &amp;&amp; !data.BillingPeriod.IsUnknown() </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: data.BillingPeriod.ValueString(),
                }
        }</span> else<span class="cov0" title="0"> if current.Properties.BillingPlan != nil &amp;&amp; current.Properties.BillingPlan.BillingPeriod != nil </span><span class="cov0" title="0">{
                updateRequest.Properties.BillingPlan = &amp;sdktypes.BillingPeriodResource{
                        BillingPeriod: *current.Properties.BillingPlan.BillingPeriod,
                }
        }</span>

        // Update the KaaS cluster using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromContainer().KaaS().Update(ctx, projectID, kaasID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating KaaS cluster",
                        fmt.Sprintf("Unable to update KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update KaaS cluster", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.Uri = state.Uri // Preserve URI from state
        data.ProjectID = state.ProjectID
        // Don't overwrite Network and Settings yet - preserve from plan until we read from API

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the KaaS cluster to get the latest state including URI
                getResp, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if not in response
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                }</span>
        }

        // Re-read to get the latest state and update all fields
        <span class="cov0" title="0">getResp, err := r.client.Client.FromContainer().KaaS().Get(ctx, projectID, kaasID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                kaas := getResp.Data
                // Update URI if available
                if kaas.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*kaas.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = state.Uri // Fallback to state if not available
                }</span>
                // Update other fields from re-read to ensure consistency
                <span class="cov0" title="0">if kaas.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*kaas.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if kaas.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(kaas.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.BillingPlan != nil &amp;&amp; kaas.Properties.BillingPlan.BillingPeriod != nil </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(*kaas.Properties.BillingPlan.BillingPeriod)
                }</span> else<span class="cov0" title="0"> {
                        data.BillingPeriod = types.StringNull()
                }</span>

                // Set Management IP if available
                <span class="cov0" title="0">if kaas.Properties.ManagementIP != nil &amp;&amp; *kaas.Properties.ManagementIP != "" </span><span class="cov0" title="0">{
                        data.ManagementIP = types.StringValue(*kaas.Properties.ManagementIP)
                }</span> else<span class="cov0" title="0"> {
                        data.ManagementIP = types.StringNull()
                }</span>

                // Build Network object from re-read, preserving fields not returned by API from the plan
                <span class="cov0" title="0">var planNetwork KaaSNetworkModel
                diagsNet := data.Network.As(ctx, &amp;planNetwork, basetypes.ObjectAsOptions{})

                networkAttrs := map[string]attr.Value{
                        "vpc_uri_ref":         types.StringNull(),
                        "subnet_uri_ref":      types.StringNull(),
                        "node_cidr":           types.ObjectNull(map[string]attr.Type{"address": types.StringType, "name": types.StringType}),
                        "security_group_name": types.StringNull(),
                        "pod_cidr":            types.StringNull(),
                }

                if kaas.Properties.VPC.URI != nil &amp;&amp; *kaas.Properties.VPC.URI != "" </span><span class="cov0" title="0">{
                        networkAttrs["vpc_uri_ref"] = types.StringValue(*kaas.Properties.VPC.URI)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.Subnet.URI != nil &amp;&amp; *kaas.Properties.Subnet.URI != "" </span><span class="cov0" title="0">{
                        networkAttrs["subnet_uri_ref"] = types.StringValue(*kaas.Properties.Subnet.URI)
                }</span>

                // Preserve security_group_name from plan if API doesn't return it
                <span class="cov0" title="0">if kaas.Properties.SecurityGroup.Name != nil &amp;&amp; *kaas.Properties.SecurityGroup.Name != "" </span><span class="cov0" title="0">{
                        networkAttrs["security_group_name"] = types.StringValue(*kaas.Properties.SecurityGroup.Name)
                }</span> else<span class="cov0" title="0"> if !diagsNet.HasError() &amp;&amp; !planNetwork.SecurityGroupName.IsNull() </span><span class="cov0" title="0">{
                        networkAttrs["security_group_name"] = planNetwork.SecurityGroupName
                }</span>

                // Build node_cidr, preserving name from plan if API doesn't return it
                <span class="cov0" title="0">if kaas.Properties.NodeCIDR.Address != nil &amp;&amp; *kaas.Properties.NodeCIDR.Address != "" </span><span class="cov0" title="0">{
                        nodeCIDRName := ""
                        if kaas.Properties.NodeCIDR.Name != nil &amp;&amp; *kaas.Properties.NodeCIDR.Name != "" </span><span class="cov0" title="0">{
                                nodeCIDRName = *kaas.Properties.NodeCIDR.Name
                        }</span> else<span class="cov0" title="0"> if !diagsNet.HasError() &amp;&amp; !planNetwork.NodeCIDR.IsNull() </span><span class="cov0" title="0">{
                                var planNodeCIDR struct {
                                        Address types.String `tfsdk:"address"`
                                        Name    types.String `tfsdk:"name"`
                                }
                                diagsNodeCIDR := planNetwork.NodeCIDR.As(ctx, &amp;planNodeCIDR, basetypes.ObjectAsOptions{})
                                if !diagsNodeCIDR.HasError() &amp;&amp; !planNodeCIDR.Name.IsNull() </span><span class="cov0" title="0">{
                                        nodeCIDRName = planNodeCIDR.Name.ValueString()
                                }</span>
                        }

                        <span class="cov0" title="0">nodeCIDRObj, diags := types.ObjectValue(map[string]attr.Type{
                                "address": types.StringType,
                                "name":    types.StringType,
                        }, map[string]attr.Value{
                                "address": types.StringValue(*kaas.Properties.NodeCIDR.Address),
                                "name":    types.StringValue(nodeCIDRName),
                        })
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                networkAttrs["node_cidr"] = nodeCIDRObj
                        }</span>
                }

                <span class="cov0" title="0">if kaas.Properties.PodCIDR != nil &amp;&amp; kaas.Properties.PodCIDR.Address != nil </span><span class="cov0" title="0">{
                        networkAttrs["pod_cidr"] = types.StringValue(*kaas.Properties.PodCIDR.Address)
                }</span>

                // Create Network object
                <span class="cov0" title="0">networkObj, diags := types.ObjectValue(map[string]attr.Type{
                        "vpc_uri_ref":         types.StringType,
                        "subnet_uri_ref":      types.StringType,
                        "node_cidr":           types.ObjectType{AttrTypes: map[string]attr.Type{"address": types.StringType, "name": types.StringType}},
                        "security_group_name": types.StringType,
                        "pod_cidr":            types.StringType,
                }, networkAttrs)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Network = networkObj
                }</span>

                // Build Settings object from re-read, preserving node_pools from plan if API doesn't return them
                <span class="cov0" title="0">var planSettings KaaSSettingsModel
                diagsSettings := data.Settings.As(ctx, &amp;planSettings, basetypes.ObjectAsOptions{})

                settingsAttrs := map[string]attr.Value{
                        "kubernetes_version": types.StringNull(),
                        "node_pools":         types.ListNull(types.ObjectType{AttrTypes: map[string]attr.Type{"name": types.StringType, "nodes": types.Int64Type, "instance": types.StringType, "zone": types.StringType, "autoscaling": types.BoolType, "min_count": types.Int64Type, "max_count": types.Int64Type}}),
                        "ha":                 types.BoolNull(),
                }

                if kaas.Properties.KubernetesVersion.Value != nil </span><span class="cov0" title="0">{
                        settingsAttrs["kubernetes_version"] = types.StringValue(*kaas.Properties.KubernetesVersion.Value)
                }</span>
                <span class="cov0" title="0">if kaas.Properties.HA != nil </span><span class="cov0" title="0">{
                        settingsAttrs["ha"] = types.BoolValue(*kaas.Properties.HA)
                }</span>

                // Build node pools from re-read, or preserve from plan if not returned
                <span class="cov0" title="0">if kaas.Properties.NodePools != nil &amp;&amp; len(*kaas.Properties.NodePools) &gt; 0 </span><span class="cov0" title="0">{
                        nodePoolValues := make([]attr.Value, 0)
                        for _, np := range *kaas.Properties.NodePools </span><span class="cov0" title="0">{
                                nodePoolMap := map[string]attr.Value{
                                        "name": types.StringValue(func() string </span><span class="cov0" title="0">{
                                                if np.Name != nil </span><span class="cov0" title="0">{
                                                        return *np.Name
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "nodes": types.Int64Value(func() int64 <span class="cov0" title="0">{
                                                if np.Nodes != nil </span><span class="cov0" title="0">{
                                                        return int64(*np.Nodes)
                                                }</span>
                                                <span class="cov0" title="0">return 0</span>
                                        }()),
                                        "instance": types.StringValue(func() string <span class="cov0" title="0">{
                                                if np.Instance != nil &amp;&amp; np.Instance.Name != nil </span><span class="cov0" title="0">{
                                                        return *np.Instance.Name
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "zone": types.StringValue(func() string <span class="cov0" title="0">{
                                                if np.DataCenter != nil &amp;&amp; np.DataCenter.Code != nil </span><span class="cov0" title="0">{
                                                        return *np.DataCenter.Code
                                                }</span>
                                                <span class="cov0" title="0">return ""</span>
                                        }()),
                                        "autoscaling": types.BoolValue(np.Autoscaling),
                                }
                                <span class="cov0" title="0">if np.MinCount != nil </span><span class="cov0" title="0">{
                                        nodePoolMap["min_count"] = types.Int64Value(int64(*np.MinCount))
                                }</span> else<span class="cov0" title="0"> {
                                        nodePoolMap["min_count"] = types.Int64Null()
                                }</span>
                                <span class="cov0" title="0">if np.MaxCount != nil </span><span class="cov0" title="0">{
                                        nodePoolMap["max_count"] = types.Int64Value(int64(*np.MaxCount))
                                }</span> else<span class="cov0" title="0"> {
                                        nodePoolMap["max_count"] = types.Int64Null()
                                }</span>

                                <span class="cov0" title="0">nodePoolObj, diags := types.ObjectValue(map[string]attr.Type{
                                        "name":        types.StringType,
                                        "nodes":       types.Int64Type,
                                        "instance":    types.StringType,
                                        "zone":        types.StringType,
                                        "autoscaling": types.BoolType,
                                        "min_count":   types.Int64Type,
                                        "max_count":   types.Int64Type,
                                }, nodePoolMap)
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        nodePoolValues = append(nodePoolValues, nodePoolObj)
                                }</span>
                        }
                        <span class="cov0" title="0">nodePoolsList, diags := types.ListValue(types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "name":        types.StringType,
                                        "nodes":       types.Int64Type,
                                        "instance":    types.StringType,
                                        "zone":        types.StringType,
                                        "autoscaling": types.BoolType,
                                        "min_count":   types.Int64Type,
                                        "max_count":   types.Int64Type,
                                },
                        }, nodePoolValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                settingsAttrs["node_pools"] = nodePoolsList
                        }</span>
                } else<span class="cov0" title="0"> if !diagsSettings.HasError() &amp;&amp; !planSettings.NodePools.IsNull() </span><span class="cov0" title="0">{
                        // Preserve node_pools from plan if API doesn't return them
                        settingsAttrs["node_pools"] = planSettings.NodePools
                }</span>

                // Create Settings object
                <span class="cov0" title="0">settingsObj, diags := types.ObjectValue(map[string]attr.Type{
                        "kubernetes_version": types.StringType,
                        "node_pools": types.ListType{
                                ElemType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "name":        types.StringType,
                                                "nodes":       types.Int64Type,
                                                "instance":    types.StringType,
                                                "zone":        types.StringType,
                                                "autoscaling": types.BoolType,
                                                "min_count":   types.Int64Type,
                                                "max_count":   types.Int64Type,
                                        },
                                },
                        },
                        "ha": types.BoolType,
                }, settingsAttrs)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Settings = settingsObj
                }</span> else<span class="cov0" title="0"> {
                        data.Settings = state.Settings // Fallback to state on error
                }</span>

                // Update tags from re-read
                <span class="cov0" title="0">if len(kaas.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(kaas.Metadata.Tags))
                        for i, tag := range kaas.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If re-read fails, preserve fields from state
                data.Uri = state.Uri
                data.Network = state.Network
                data.Settings = state.Settings
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KaaSResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data KaaSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        kaasID := data.Id.ValueString()

        if projectID == "" || kaasID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KaaS ID are required to delete the KaaS cluster",
                )
                return
        }</span>

        // Delete the KaaS cluster using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromContainer().KaaS().Delete(ctx, projectID, kaasID, nil)
                }</span>,
                ExtractSDKError,
                "KaaS",
                kaasID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting KaaS cluster",
                        fmt.Sprintf("Unable to delete KaaS cluster: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a KaaS resource", map[string]interface{}{
                "kaas_id": kaasID,
        })</span>
}

func (r *KaaSResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KeypairDataSourceModel struct {
        Id        types.String `tfsdk:"id"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        ProjectID types.String `tfsdk:"project_id"`
        Value     types.String `tfsdk:"value"`
        Tags      types.List   `tfsdk:"tags"`
}

type KeypairDataSource struct {
        client *ArubaCloudClient
}

var _ datasource.DataSource = &amp;KeypairDataSource{}

func NewKeypairDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;KeypairDataSource{}
}</span>

func (d *KeypairDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_keypair"
}</span>

func (d *KeypairDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Keypair data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Keypair identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Keypair name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Keypair location",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this keypair belongs to",
                                Computed:            true,
                        },
                        "value": schema.StringAttribute{
                                MarkdownDescription: "Keypair value (public key)",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the keypair",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *KeypairDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected DataSource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *KeypairDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data KeypairDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Name = types.StringValue("example-keypair")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.ProjectID = types.StringValue("68398923fb2cb026400d4d31")
        data.Value = types.StringValue("ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3o7qyMh8...")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("ssh"),
                types.StringValue("production"),
                types.StringValue("keypair-main"),
        })

        tflog.Trace(ctx, "read a Keypair data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KeypairResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        ProjectID types.String `tfsdk:"project_id"`
        Value     types.String `tfsdk:"value"`
        Tags      types.List   `tfsdk:"tags"`
}

type KeypairResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;KeypairResource{}
var _ resource.ResourceWithImportState = &amp;KeypairResource{}

func NewKeypairResource() resource.Resource <span class="cov8" title="1">{
        return &amp;KeypairResource{}
}</span>

func (r *KeypairResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_keypair"
}</span>

func (r *KeypairResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Keypair resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Keypair identifier (name)",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Keypair URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Keypair name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Keypair location",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "Project ID",
                                Required:            true,
                        },
                        "value": schema.StringAttribute{
                                MarkdownDescription: "Public key value",
                                Required:            true,
                                Sensitive:           true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the keypair",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *KeypairResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *KeypairResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data KeypairResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a keypair",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.KeyPairRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.KeyPairPropertiesRequest{
                        Value: data.Value.ValueString(),
                },
        }

        // Create the keypair using the SDK
        response, err := r.client.Client.FromCompute().KeyPairs().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating keypair",
                        fmt.Sprintf("Unable to create keypair: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "keypair_name": data.Name.ValueString(),
                        "project_id":   projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create keypair", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Get ID from Metadata.ID (like other resources)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span> else<span class="cov0" title="0"> {
                        resp.Diagnostics.AddError(
                                "Invalid API Response",
                                "Keypair created but ID is missing from response",
                        )
                        return
                }</span>

                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Keypair created but no data returned from API",
                )
                return
        }</span>

        // Wait for Keypair to be active before returning (Keypair is referenced by CloudServer)
        // This ensures Terraform doesn't proceed to create dependent resources until Keypair is ready
        <span class="cov0" title="0">keypairID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromCompute().KeyPairs().Get(ctx, projectID, keypairID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Keypairs don't have a Status field - if we can get it, it's ready
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        return "Active", nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Keypair to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Keypair", keypairID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Keypair Not Active",
                        fmt.Sprintf("Keypair was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Keypair resource", map[string]interface{}{
                "keypair_id":   data.Id.ValueString(),
                "keypair_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KeypairResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data KeypairResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get project ID and keypair ID from state
        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        keypairID := data.Id.ValueString()

        // If ID is unknown or null, check if this is a new resource (no state) or existing resource (state exists but ID missing)
        // For new resources (during plan), we can return early
        // For existing resources, we need the ID to read - if it's missing, that's an error
        if data.Id.IsUnknown() || data.Id.IsNull() || keypairID == "" </span><span class="cov0" title="0">{
                // Check if ProjectID is also unknown - if so, this is definitely a new resource
                if data.ProjectID.IsUnknown() || data.ProjectID.IsNull() </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair ID and Project ID are unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
                // If ProjectID is set but ID is unknown, still skip (new resource)
                <span class="cov0" title="0">if keypairID == "" </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair ID is unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
        }

        // If ProjectID is missing, we can't read the keypair
        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                // Check if ProjectID is unknown (new resource) vs missing (error)
                if data.ProjectID.IsUnknown() || data.ProjectID.IsNull() </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair Project ID is unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to read the keypair",
                )
                return</span>
        }

        // Get keypair details using the SDK
        // The API Get method accepts the keypair ID
        <span class="cov0" title="0">tflog.Debug(ctx, "Reading keypair", map[string]interface{}{
                "project_id":   projectID,
                "keypair_id":   keypairID,
                "keypair_name": data.Name.ValueString(),
                "keypair_uri":  data.Uri.ValueString(),
        })

        response, err := r.client.Client.FromCompute().KeyPairs().Get(ctx, projectID, keypairID, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Error calling keypair Get API", map[string]interface{}{
                        "error":      err,
                        "project_id": projectID,
                        "keypair_id": keypairID,
                })
                resp.Diagnostics.AddError(
                        "Error reading keypair",
                        fmt.Sprintf("Unable to read keypair: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair not found (404), removing from state", map[string]interface{}{
                                "project_id": projectID,
                                "keypair_id": keypairID,
                        })
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "keypair_id": keypairID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read keypair", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                keypair := response.Data

                // Preserve ProjectID and Value from state (they're not in the API response)
                projectIDFromState := data.ProjectID
                valueFromState := data.Value
                idFromState := data.Id

                // Get ID from Metadata.ID (like other resources)
                if keypair.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*keypair.Metadata.ID)
                }</span> else<span class="cov0" title="0"> {
                        // If API doesn't provide ID, preserve from state
                        data.Id = idFromState
                }</span>

                <span class="cov0" title="0">if keypair.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*keypair.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if keypair.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*keypair.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if keypair.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(keypair.Metadata.LocationResponse.Value)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(keypair.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(keypair.Metadata.Tags))
                        for i, tag := range keypair.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Set tags to null when empty to match state (prevents false changes)
                        data.Tags = types.ListNull(types.StringType)
                }</span>

                // Restore ProjectID and Value from state (they're not returned by the API)
                <span class="cov0" title="0">data.ProjectID = projectIDFromState
                data.Value = valueFromState</span>
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KeypairResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data KeypairResourceModel
        var state KeypairResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Use IDs from state (they are immutable)
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        keypairID := state.Id.ValueString()

        if projectID == "" || keypairID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Keypair ID are required to update the keypair",
                )
                return
        }</span>

        // Keypair update is not supported by the API
        // Check if immutable fields changed
        <span class="cov0" title="0">if !data.Name.Equal(state.Name) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Keypair Name Update Not Supported",
                        "Changing the keypair name is not supported by the API. Please delete and recreate the keypair with the new name.",
                )
                return
        }</span>

        <span class="cov0" title="0">if !data.Value.Equal(state.Value) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Keypair Public Key Update Not Supported",
                        "Changing the public key value is not supported by the API. Please delete and recreate the keypair with the new public key.",
                )
                return
        }</span>

        <span class="cov0" title="0">if !data.Location.Equal(state.Location) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Keypair Location Update Not Supported",
                        "Changing the keypair location is not supported by the API. Please delete and recreate the keypair in the new location.",
                )
                return
        }</span>

        // Since updates aren't supported, we just read the resource to refresh state
        // This ensures URI and other computed fields are up to date
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromCompute().KeyPairs().Get(ctx, projectID, keypairID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading keypair",
                        fmt.Sprintf("Unable to read keypair: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.IsError() || getResponse.Data == nil </span><span class="cov0" title="0">{
                if getResponse != nil &amp;&amp; getResponse.StatusCode == 404 </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Keypair not found (404), removing from state", map[string]interface{}{
                                "project_id": projectID,
                                "keypair_id": keypairID,
                        })
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Keypair Not Found",
                        "Keypair not found or no data returned",
                )
                return</span>
        }

        <span class="cov0" title="0">keypair := getResponse.Data

        // Ensure immutable fields are set from state before saving
        data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Location = state.Location
        data.Value = state.Value

        // Update URI from API response
        if keypair.Metadata.URI != nil </span><span class="cov0" title="0">{
                data.Uri = types.StringValue(*keypair.Metadata.URI)
        }</span> else<span class="cov0" title="0"> {
                data.Uri = state.Uri
        }</span>

        // Tags cannot be updated via API, so preserve tags from state
        // (The API doesn't support tag updates, so we keep what's in state)
        <span class="cov0" title="0">data.Tags = state.Tags

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KeypairResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data KeypairResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        keypairID := data.Id.ValueString()

        if projectID == "" || keypairID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Keypair ID are required to delete the keypair",
                )
                return
        }</span>

        // Delete the keypair using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromCompute().KeyPairs().Delete(ctx, projectID, keypairID, nil)
                }</span>,
                ExtractSDKError,
                "Keypair",
                keypairID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting keypair",
                        fmt.Sprintf("Unable to delete keypair: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Keypair resource", map[string]interface{}{
                "keypair_id": keypairID,
        })</span>
}

func (r *KeypairResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KMSDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Endpoint    types.String `tfsdk:"endpoint"`
}

type KMSDataSource struct {
        client *ArubaCloudClient
}

var _ datasource.DataSource = &amp;KMSDataSource{}

func NewKMSDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;KMSDataSource{}
}</span>

func (d *KMSDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_kms"
}</span>

func (d *KMSDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "KMS data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "KMS identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Name of the KMS resource",
                                Computed:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Description of the KMS resource",
                                Computed:            true,
                        },
                        "endpoint": schema.StringAttribute{
                                MarkdownDescription: "KMS endpoint URL",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *KMSDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected DataSource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *KMSDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data KMSDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Simulate API response
        <span class="cov8" title="1">data.Id = types.StringValue("kms-id")
        data.Description = types.StringValue("Simulated KMS description")
        data.Endpoint = types.StringValue("https://kms.example.com")
        tflog.Trace(ctx, "read a KMS data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type KMSResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        ProjectID     types.String `tfsdk:"project_id"`
        Location      types.String `tfsdk:"location"`
        Tags          types.List   `tfsdk:"tags"`
        BillingPeriod types.String `tfsdk:"billing_period"`
}

type KMSResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;KMSResource{}
var _ resource.ResourceWithImportState = &amp;KMSResource{}

func NewKMSResource() resource.Resource <span class="cov8" title="1">{
        return &amp;KMSResource{}
}</span>

func (r *KMSResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_kms"
}</span>

func (r *KMSResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "KMS resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "KMS identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "KMS URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "KMS name",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this KMS belongs to",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Location for the KMS",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the KMS",
                                Optional:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period for the KMS",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *KMSResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *KMSResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data KMSResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()

        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to create a KMS",
                )
                return
        }</span>

        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.KmsRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.KmsPropertiesRequest{
                        BillingPeriod: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Create the KMS using the SDK
        response, err := r.client.Client.FromSecurity().KMSKeys().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating KMS",
                        fmt.Sprintf("Unable to create KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create KMS", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "KMS created but no ID returned from API",
                )
                return
        }</span>

        // Wait for KMS to be active before returning
        // This ensures Terraform doesn't proceed until KMS is ready
        <span class="cov0" title="0">kmsID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromSecurity().KMSKeys().Get(ctx, projectID, kmsID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for KMS to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "KMS", kmsID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "KMS Not Active",
                        fmt.Sprintf("KMS was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a KMS resource", map[string]interface{}{
                "kms_id":   data.Id.ValueString(),
                "kms_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KMSResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data KMSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        kmsID := data.Id.ValueString()

        if projectID == "" || kmsID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KMS ID are required to read the KMS",
                )
                return
        }</span>

        // Get KMS details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromSecurity().KMSKeys().Get(ctx, projectID, kmsID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading KMS",
                        fmt.Sprintf("Unable to read KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "kms_id":     kmsID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read KMS", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                kms := response.Data
                if kms.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*kms.Metadata.ID)
                        if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                }
                <span class="cov0" title="0">if kms.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*kms.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if kms.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(kms.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if kms.Metadata.Tags != nil </span><span class="cov0" title="0">{
                        tagValues := make([]attr.Value, len(kms.Metadata.Tags))
                        for i, tag := range kms.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValue(types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.Tags = types.ListNull(types.StringType)
                }</span>
                <span class="cov0" title="0">if kms.Properties.BillingPeriod.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(kms.Properties.BillingPeriod.BillingPeriod)
                }</span>
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KMSResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data KMSResourceModel
        var state KMSResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        kmsID := state.Id.ValueString()

        if projectID == "" || kmsID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KMS ID are required to update the KMS",
                )
                return
        }</span>

        // Get current KMS to preserve fields
        <span class="cov0" title="0">getResp, err := r.client.Client.FromSecurity().KMSKeys().Get(ctx, projectID, kmsID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting KMS",
                        fmt.Sprintf("Unable to get KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResp == nil || getResp.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "KMS Not Found",
                        "KMS not found",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResp.Data
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>

        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.KmsRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.KmsPropertiesRequest{
                        BillingPeriod: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Update the KMS using the SDK
        response, err := r.client.Client.FromSecurity().KMSKeys().Update(ctx, projectID, kmsID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating KMS",
                        fmt.Sprintf("Unable to update KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update KMS", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *KMSResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data KMSResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        kmsID := data.Id.ValueString()

        if projectID == "" || kmsID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and KMS ID are required to delete the KMS",
                )
                return
        }</span>

        // Delete the KMS using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromSecurity().KMSKeys().Delete(ctx, projectID, kmsID, nil)
                }</span>,
                ExtractSDKError,
                "KMS",
                kmsID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting KMS",
                        fmt.Sprintf("Unable to delete KMS: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a KMS resource", map[string]interface{}{
                "kms_id": kmsID,
        })</span>
}

func (r *KMSResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;ProjectDataSource{}

func NewProjectDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;ProjectDataSource{}
}</span>

type ProjectDataSource struct {
        client *ArubaCloudClient
}

type ProjectDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Tags        types.List   `tfsdk:"tags"`
}

func (d *ProjectDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_project"
}</span>

func (d *ProjectDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Project data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Project identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Project name",
                                Computed:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Project description",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the project",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *ProjectDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *ProjectDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data ProjectDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Name = types.StringValue("example-project")
        data.Description = types.StringValue("Example project for demonstration purposes")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("production"),
                types.StringValue("web-services"),
                types.StringValue("team-alpha"),
        })

        tflog.Trace(ctx, "read project data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;ProjectResource{}
var _ resource.ResourceWithImportState = &amp;ProjectResource{}

func NewProjectResource() resource.Resource <span class="cov8" title="1">{
        return &amp;ProjectResource{}
}</span>

type ProjectResource struct {
        client *ArubaCloudClient
}
type ProjectResourceModel struct {
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Tags        types.List   `tfsdk:"tags"`
        Id          types.String `tfsdk:"id"`
}

func (r *ProjectResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_project"
}</span>

func (r *ProjectResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Project resource",
                Attributes: map[string]schema.Attribute{
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Project name",
                                Required:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Project description",
                                Optional:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the project",
                                Optional:            true,
                        },
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Project Identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
        }
}</span>

func (r *ProjectResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">r.client = client</span>
}

func (r *ProjectResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        var data ProjectResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov8" title="1">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov8" title="1">createRequest := sdktypes.ProjectRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
                Properties: sdktypes.ProjectPropertiesRequest{
                        Default: false, // Default to false unless specified
                },
        }

        // Add description if provided
        if !data.Description.IsNull() &amp;&amp; !data.Description.IsUnknown() </span><span class="cov0" title="0">{
                description := data.Description.ValueString()
                createRequest.Properties.Description = &amp;description
        }</span>

        // Create the project using the SDK
        <span class="cov8" title="1">response, err := r.client.Client.FromProject().Create(ctx, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating project",
                        fmt.Sprintf("Unable to create project: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create project", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov8" title="1">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov8" title="1">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)

                // Update description from response if available
                if response.Data.Properties.Description != nil </span><span class="cov0" title="0">{
                        data.Description = types.StringValue(*response.Data.Properties.Description)
                }</span>

                // Update tags from response
                <span class="cov8" title="1">if len(response.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(response.Data.Metadata.Tags))
                        for i, tag := range response.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov8" title="1"> {
                        // If the config had null tags, keep it null to avoid drift
                        // If it had an empty list, set empty list
                        if data.Tags.IsNull() </span><span class="cov8" title="1">{
                                data.Tags = types.ListNull(types.StringType)
                        }</span> else<span class="cov0" title="0"> {
                                // Set empty list if no tags and config had a list
                                emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        data.Tags = emptyList
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Project created but no ID returned from API",
                )
                return
        }</span>

        // Write logs using the tflog package
        <span class="cov8" title="1">tflog.Trace(ctx, "created a project resource", map[string]interface{}{
                "project_id":   data.Id.ValueString(),
                "project_name": data.Name.ValueString(),
        })

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        var data ProjectResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get project ID from state
        <span class="cov8" title="1">projectID := data.Id.ValueString()

        // If ID is unknown or null, check if this is a new resource (no state) or existing resource (state exists but ID missing)
        // For new resources (during plan), we can return early
        // For existing resources, we need the ID to read - if it's missing, that's a state corruption issue
        if data.Id.IsUnknown() || data.Id.IsNull() || projectID == "" </span><span class="cov0" title="0">{
                // Check if we have any other state data that indicates this is an existing resource
                // If name is set in state, this is likely an existing resource with missing ID (state corruption)
                if !data.Name.IsUnknown() &amp;&amp; !data.Name.IsNull() &amp;&amp; data.Name.ValueString() != "" </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Project exists in state but ID is missing - this indicates a state corruption issue")
                        resp.Diagnostics.AddError(
                                "Missing Project ID",
                                "Project ID is required to read the project. The resource exists in state but the ID is missing. This indicates a state corruption issue. To fix this, you can:\n"+
                                        "1. Find the project ID using: acloud management project list\n"+
                                        "2. Import the resource: terraform import arubacloud_project.test &lt;project_id&gt;\n"+
                                        "Or manually edit the terraform.tfstate file to add the ID.",
                        )
                        return
                }</span>
                // Otherwise, this is likely a new resource during plan - return early
                <span class="cov0" title="0">tflog.Info(ctx, "Project ID is unknown or null during read, skipping API call (likely new resource).")
                return</span> // Do not error, as this is expected during plan for new resources
        }

        // Get project details using the SDK
        <span class="cov8" title="1">response, err := r.client.Client.FromProject().Get(ctx, projectID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading project",
                        fmt.Sprintf("Unable to read project: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                // If project not found, mark as removed
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read project", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov8" title="1">if response != nil &amp;&amp; response.Data != nil </span><span class="cov8" title="1">{
                project := response.Data

                // Update data from API response
                if project.Metadata.ID != nil </span><span class="cov8" title="1">{
                        data.Id = types.StringValue(*project.Metadata.ID)
                }</span>
                <span class="cov8" title="1">if project.Metadata.Name != nil </span><span class="cov8" title="1">{
                        data.Name = types.StringValue(*project.Metadata.Name)
                }</span>
                <span class="cov8" title="1">if project.Properties.Description != nil </span><span class="cov0" title="0">{
                        data.Description = types.StringValue(*project.Properties.Description)
                }</span> else<span class="cov8" title="1"> {
                        data.Description = types.StringNull()
                }</span>

                // Update tags from response
                <span class="cov8" title="1">if len(project.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(project.Metadata.Tags))
                        for i, tag := range project.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov8" title="1"> {
                        // If the config had null tags, keep it null to avoid drift
                        // If it had an empty list, set empty list
                        if data.Tags.IsNull() </span><span class="cov8" title="1">{
                                data.Tags = types.ListNull(types.StringType)
                        }</span> else<span class="cov0" title="0"> {
                                // Set empty list if no tags and config had a list
                                emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        data.Tags = emptyList
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Project not found, mark as removed
                resp.State.RemoveResource(ctx)
                return
        }</span>

        // Save updated data into Terraform state
        <span class="cov8" title="1">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        var data ProjectResourceModel
        var state ProjectResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read current state to preserve values
        <span class="cov8" title="1">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get project ID from state (not plan) - ID is immutable and should always be in state
        // If state doesn't have ID, try to get it from plan as fallback (shouldn't happen but be defensive)
        <span class="cov8" title="1">var projectID string
        if !state.Id.IsUnknown() &amp;&amp; !state.Id.IsNull() &amp;&amp; state.Id.ValueString() != "" </span><span class="cov8" title="1">{
                projectID = state.Id.ValueString()
        }</span> else<span class="cov0" title="0"> if !data.Id.IsUnknown() &amp;&amp; !data.Id.IsNull() &amp;&amp; data.Id.ValueString() != "" </span><span class="cov0" title="0">{
                // Fallback to plan if state doesn't have it (shouldn't happen for existing resources)
                tflog.Warn(ctx, "Project ID not found in state, using plan ID as fallback")
                projectID = data.Id.ValueString()
        }</span>

        <span class="cov8" title="1">if projectID == "" </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Project ID is missing from both state and plan", map[string]interface{}{
                        "state_id_unknown": state.Id.IsUnknown(),
                        "state_id_null":    state.Id.IsNull(),
                        "state_id_value":   state.Id.ValueString(),
                        "plan_id_unknown":  data.Id.IsUnknown(),
                        "plan_id_null":     data.Id.IsNull(),
                        "plan_id_value":    data.Id.ValueString(),
                        "state_name":       state.Name.ValueString(),
                })
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to update the project. The resource exists in state but the ID is missing. This indicates a state corruption issue. To fix this, you can:\n"+
                                "1. Find the project ID using: acloud management project list\n"+
                                "2. Import the resource: terraform import arubacloud_project.test &lt;project_id&gt;\n"+
                                "Or manually edit the terraform.tfstate file to add the ID.",
                )
                return
        }</span>

        // Get current project details to preserve existing values
        <span class="cov8" title="1">getResponse, err := r.client.Client.FromProject().Get(ctx, projectID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current project",
                        fmt.Sprintf("Unable to get current project: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Project Not Found",
                        "Project not found or no data returned",
                )
                return
        }</span>

        <span class="cov8" title="1">currentProject := getResponse.Data

        // Extract tags from Terraform list
        var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the update request with current values as defaults
        <span class="cov8" title="1">updateRequest := sdktypes.ProjectRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
                Properties: sdktypes.ProjectPropertiesRequest{
                        Default: currentProject.Properties.Default,
                },
        }

        // Update description if provided
        if !data.Description.IsNull() &amp;&amp; !data.Description.IsUnknown() </span><span class="cov0" title="0">{
                description := data.Description.ValueString()
                updateRequest.Properties.Description = &amp;description
        }</span> else<span class="cov8" title="1"> if currentProject.Properties.Description != nil </span><span class="cov0" title="0">{
                updateRequest.Properties.Description = currentProject.Properties.Description
        }</span>

        // Update the project using the SDK
        <span class="cov8" title="1">response, err := r.client.Client.FromProject().Update(ctx, projectID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating project",
                        fmt.Sprintf("Unable to update project: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update project", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure ID and Name are set from state (they are immutable)
        <span class="cov8" title="1">data.Id = state.Id
        data.Name = state.Name

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov8" title="1">{
                // Update ID from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov8" title="1">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                // Update name from response if available (should match state)
                <span class="cov8" title="1">if response.Data.Metadata.Name != nil </span><span class="cov8" title="1">{
                        data.Name = types.StringValue(*response.Data.Metadata.Name)
                }</span>
                // Update description from response if available
                <span class="cov8" title="1">if response.Data.Properties.Description != nil </span><span class="cov0" title="0">{
                        data.Description = types.StringValue(*response.Data.Properties.Description)
                }</span>

                // Update tags from response
                <span class="cov8" title="1">if len(response.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(response.Data.Metadata.Tags))
                        for i, tag := range response.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov8" title="1"> {
                        // If the config had null tags, keep it null to avoid drift
                        // If it had an empty list, set empty list
                        if data.Tags.IsNull() </span><span class="cov8" title="1">{
                                data.Tags = types.ListNull(types.StringType)
                        }</span> else<span class="cov0" title="0"> {
                                // Set empty list if no tags and config had a list
                                emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        data.Tags = emptyList
                                }</span>
                        }
                }
        }

        // Save updated data into Terraform state
        <span class="cov8" title="1">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ProjectResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        var data ProjectResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">projectID := data.Id.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to delete the project",
                )
                return
        }</span>

        // Delete the project using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov8" title="1">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov8" title="1">{
                        return r.client.Client.FromProject().Delete(ctx, projectID, nil)
                }</span>,
                ExtractSDKError,
                "Project",
                projectID,
                r.client.ResourceTimeout,
        )

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting project",
                        fmt.Sprintf("Unable to delete project: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "deleted a project resource", map[string]interface{}{
                "project_id": projectID,
        })</span>
}

func (r *ProjectResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/Arubacloud/sdk-go/pkg/aruba"
        "github.com/hashicorp/terraform-plugin-framework/path"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/ephemeral"
        "github.com/hashicorp/terraform-plugin-framework/function"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure ArubaCloudProvider satisfies various provider interfaces.
var _ provider.Provider = &amp;ArubaCloudProvider{}
var _ provider.ProviderWithFunctions = &amp;ArubaCloudProvider{}
var _ provider.ProviderWithEphemeralResources = &amp;ArubaCloudProvider{}

// ArubaCloudProvider defines the provider implementation.
type ArubaCloudProvider struct {
        // version is set to the provider version on release, "dev" when the
        // provider is built and ran locally, and "test" when running acceptance
        // testing.
        version string
}

// ArubaCloudProviderModel describes the provider data model.
type ArubaCloudProviderModel struct {
        ApiKey          types.String `tfsdk:"api_key"`
        ApiSecret       types.String `tfsdk:"api_secret"`
        ResourceTimeout types.String `tfsdk:"resource_timeout"`
}

func (p *ArubaCloudProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = "arubacloud"
        resp.Version = p.version
}</span>

func (p *ArubaCloudProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "api_key": schema.StringAttribute{
                                MarkdownDescription: "API key for ArubaCloud. Can also be set via ARUBACLOUD_API_KEY environment variable.",
                                Optional:            true,
                        },
                        "api_secret": schema.StringAttribute{
                                MarkdownDescription: "API secret for ArubaCloud. Can also be set via ARUBACLOUD_API_SECRET environment variable.",
                                Optional:            true,
                                Sensitive:           true,
                        },
                        "resource_timeout": schema.StringAttribute{
                                MarkdownDescription: "Timeout for waiting for resources to become active after creation (e.g., \"5m\", \"10m\", \"15m\"). This timeout applies to all resources that need to wait for active state. Default: \"10m\"",
                                Optional:            true,
                        },
                },
        }
}</span>

func (p *ArubaCloudProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov8" title="1">{

        // Default values to environment variables, but override with Terraform configuration value if set.
        apiKey := os.Getenv("ARUBACLOUD_API_KEY")
        apiSecret := os.Getenv("ARUBACLOUD_API_SECRET")

        // Retrieve provider data from configuration
        var config ArubaCloudProviderModel
        diags := req.Config.Get(ctx, &amp;config)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if !config.ApiKey.IsNull() </span><span class="cov0" title="0">{
                apiKey = config.ApiKey.ValueString()
        }</span>

        <span class="cov8" title="1">if !config.ApiSecret.IsNull() </span><span class="cov0" title="0">{
                apiSecret = config.ApiSecret.ValueString()
        }</span>

        <span class="cov8" title="1">if apiKey == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("api_key"),
                        "Unknown ArubaCloud API Key",
                        "The provider cannot create the ArubaCloud API client as there is an unknown configuration value for the API key. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the ARUBACLOUD_API_KEY environment variable.",
                )
        }</span>

        <span class="cov8" title="1">if apiSecret == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("api_secret"),
                        "Unknown ArubaCloud API Secret",
                        "The provider cannot create the ArubaCloud API client as there is an unknown configuration value for the API secret. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the ARUBACLOUD_API_SECRET environment variable.",
                )
        }</span>

        <span class="cov8" title="1">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create SDK client with credentials using DefaultOptions
        <span class="cov8" title="1">options := aruba.DefaultOptions(apiKey, apiSecret)
        options = options.WithDefaultLogger()

        sdkClient, err := aruba.NewClient(options)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Failed to create ArubaCloud SDK client",
                        fmt.Sprintf("Unable to create ArubaCloud SDK client: %s", err),
                )
                return
        }</span>

        // Parse timeout configuration with default (10 minutes - enough for most resources including CloudServer)
        <span class="cov8" title="1">resourceTimeout := parseTimeout(config.ResourceTimeout, 10*time.Minute)

        // Create a new ArubaCloud client using the SDK client
        client := &amp;ArubaCloudClient{
                ApiKey:          apiKey,
                ApiSecret:       apiSecret,
                Client:          sdkClient,
                ResourceTimeout: resourceTimeout,
        }

        resp.DataSourceData = client
        resp.ResourceData = client</span>
}

// parseTimeout parses a timeout string (e.g., "5m", "10m") and returns the duration.
// If the string is empty or invalid, returns the default duration.
func parseTimeout(timeoutStr types.String, defaultDuration time.Duration) time.Duration <span class="cov8" title="1">{
        if timeoutStr.IsNull() || timeoutStr.IsUnknown() || timeoutStr.ValueString() == "" </span><span class="cov8" title="1">{
                return defaultDuration
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(timeoutStr.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                // If parsing fails, return default
                return defaultDuration
        }</span>

        <span class="cov0" title="0">return duration</span>
}

// ArubaCloudClient wraps the SDK client with API credentials and timeout configuration.
type ArubaCloudClient struct {
        ApiKey          string
        ApiSecret       string
        Client          aruba.Client
        ResourceTimeout time.Duration
}

func (p *ArubaCloudProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov8" title="1">{

        return []func() resource.Resource{
                NewProjectResource,
                NewCloudServerResource,
                NewKeypairResource,
                NewElasticIPResource,
                NewBlockStorageResource,
                NewSnapshotResource,
                NewVPCResource,
                NewVPNTunnelResource,
                NewVPNRouteResource,
                NewSubnetResource,
                NewSecurityGroupResource,
                NewSecurityRuleResource,
                NewVpcPeeringResource,
                NewVpcPeeringRouteResource,
                NewKaaSResource,
                NewContainerRegistryResource,
                NewBackupResource,
                NewRestoreResource,
                NewDBaaSResource,
                NewDatabaseResource,
                NewDatabaseGrantResource,
                NewDatabaseBackupResource,
                NewDBaaSUserResource,
                NewScheduleJobResource,
                NewKMSResource,
                // NewKMIPResource, // TODO: KMIP not available in SDK yet
        }

}</span>

func (p *ArubaCloudProvider) EphemeralResources(ctx context.Context) []func() ephemeral.EphemeralResource <span class="cov8" title="1">{
        return []func() ephemeral.EphemeralResource{}
}</span>

func (p *ArubaCloudProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov8" title="1">{
        return []func() datasource.DataSource{
                NewProjectDataSource,
                NewBlockStorageDataSource,
                NewSnapshotDataSource,
                NewVPCDataSource,
                NewKeypairDataSource,
                NewCloudServerDataSource,
                NewSubnetDataSource,
                NewElasticIPDataSource,
                NewSecurityGroupDataSource,
                NewSecurityRuleDataSource,
                NewVPCPeeringDataSource,
                NewVPCPeeringRouteDataSource,
                NewKaaSDataSource,
                NewContainerRegistryDataSource,
                NewBackupDataSource,
                NewDatabaseDataSource,
                NewDatabaseBackupDataSource,
                NewDatabaseGrantDataSource,
                NewDBaaSDataSource,
                NewDBaaSUserDataSource,
                // NewKMIPDataSource, // TODO: KMIP not available in SDK yet
                NewKMSDataSource,
                NewRestoreDataSource,
                NewScheduleJobDataSource,
                NewVPNRouteDataSource,
                NewVPNTunnelDataSource,
        }
}</span>

func (p *ArubaCloudProvider) Functions(ctx context.Context) []func() function.Function <span class="cov8" title="1">{
        return []func() function.Function{}
}</span>

func New(version string) func() provider.Provider <span class="cov8" title="1">{
        return func() provider.Provider </span><span class="cov8" title="1">{
                return &amp;ArubaCloudProvider{
                        version: version,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// ResourceStateChecker is a function that checks the current state of a resource.
// Returns the state string and an error if the check failed.
type ResourceStateChecker func(ctx context.Context) (string, error)

// WaitForResourceActive waits for a resource to reach an active/ready state.
// It polls the resource status until it's not in a transitional state.
func WaitForResourceActive(ctx context.Context, checker ResourceStateChecker, resourceType, resourceID string, timeout time.Duration) error <span class="cov0" title="0">{
        deadline := time.Now().Add(timeout)
        ticker := time.NewTicker(5 * time.Second) // Poll every 5 seconds
        defer ticker.Stop()

        tflog.Info(ctx, fmt.Sprintf("Waiting for %s %s to become active", resourceType, resourceID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("context cancelled while waiting for %s %s", resourceType, resourceID)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if time.Now().After(deadline) </span><span class="cov0" title="0">{
                                return fmt.Errorf("timeout waiting for %s %s to become active (timeout: %v)", resourceType, resourceID, timeout)
                        }</span>

                        <span class="cov0" title="0">state, err := checker(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                tflog.Warn(ctx, fmt.Sprintf("Error checking %s %s status: %v", resourceType, resourceID, err))
                                continue</span>
                        }

                        // Check if resource is in a ready state
                        <span class="cov0" title="0">if isReadyState(state) </span><span class="cov0" title="0">{
                                tflog.Info(ctx, fmt.Sprintf("%s %s is now active (state: %s)", resourceType, resourceID, state))
                                return nil
                        }</span>

                        <span class="cov0" title="0">tflog.Debug(ctx, fmt.Sprintf("%s %s is still in state: %s, waiting...", resourceType, resourceID, state))</span>
                }
        }
}

// isReadyState checks if a resource state indicates it's ready to be used.
// Resources in "InCreation", "Creating", "Updating", or "Deleting" states are not ready.
func isReadyState(state string) bool <span class="cov0" title="0">{
        transitionalStates := []string{
                "InCreation",
                "Creating",
                "Updating",
                "Deleting",
                "Pending",
                "Provisioning",
        }

        for _, ts := range transitionalStates </span><span class="cov0" title="0">{
                if state == ts </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // If not in a transitional state, consider it ready
        // Common ready states: "Active", "NotUsed", "InUse", "Used", "Stopped", "Running", etc.
        <span class="cov0" title="0">return true</span>
}

// IsDependencyError checks if an API error should be retried.
// According to user requirements: retry on any error except 404 (Resource Not Found).
// We also check for dependency-related keywords in the error message for better logging.
func IsDependencyError(statusCode int, errorTitle, errorDetail *string) bool <span class="cov0" title="0">{
        // 404 means resource not found - don't retry, consider it already deleted
        if statusCode == 404 </span><span class="cov0" title="0">{
                return false
        }</span>

        // For any other error (400, 409, 500, etc.), retry as it might be a dependency issue
        // The API might return 400 for dependency errors, but we'll retry on any error
        // to handle cases where dependencies are being deleted by Terraform

        // Build error message from title and detail for logging
        <span class="cov0" title="0">errorMsg := ""
        if errorTitle != nil </span><span class="cov0" title="0">{
                errorMsg = *errorTitle
        }</span>
        <span class="cov0" title="0">if errorDetail != nil </span><span class="cov0" title="0">{
                if errorMsg != "" </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *errorDetail)
                }</span> else<span class="cov0" title="0"> {
                        errorMsg = *errorDetail
                }</span>
        }

        // If error message contains dependency keywords, it's definitely a dependency error
        <span class="cov0" title="0">if errorMsg != "" &amp;&amp; containsDependencyKeywords(errorMsg) </span><span class="cov0" title="0">{
                return true
        }</span>

        // For any non-404 error, retry (might be dependency or transient issue)
        // This handles cases where the API returns errors while dependencies are being cleaned up
        <span class="cov0" title="0">return true</span>
}

// containsDependencyKeywords checks if a string contains keywords that indicate dependency issues.
func containsDependencyKeywords(s string) bool <span class="cov0" title="0">{
        keywords := []string{
                "dependency",
                "dependent",
                "depend",
                "cannot delete",
                "can't delete",
                "still in use",
                "in use",
                "has resources",
                "contains resources",
                "has subnets",
                "has security groups",
                "has securitygroup",
                "must be deleted first",
                "delete first",
                "remove first",
                "still exists",
                "associated",
                "attached",
                "linked",
        }

        lower := strings.ToLower(s)
        for _, keyword := range keywords </span><span class="cov0" title="0">{
                if strings.Contains(lower, keyword) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// DeleteResourceWithRetry is a generic function that attempts to delete a resource with retry logic.
// It retries deletion on any error (API errors, network errors, etc.) except 404 (Resource Not Found).
// This handles cases where resources cannot be deleted due to dependencies, transient issues, or network problems.
//
// All SDK responses follow the same structure:
//   - response.IsError() - method to check if error
//   - response.StatusCode - field with HTTP status code
//   - response.Error.Title - field with error title (pointer to string)
//   - response.Error.Detail - field with error detail (pointer to string)
//
// Parameters:
//   - ctx: Context for cancellation
//   - deleteFunc: Function that performs the delete operation and returns (response, error)
//   - extractErrorFunc: Function that extracts error details from the response
//   - resourceType: Human-readable resource type name (e.g., "VPC", "Subnet")
//   - resourceID: Resource identifier for logging
//   - timeout: Maximum time to wait for successful deletion
//
// The function will:
//   - Retry on any error except 404 (consider 404 as already deleted)
//   - Retry on network errors (EOF, connection reset, timeouts, etc.)
//   - Retry on API errors (400, 409, 500, etc.) that might indicate dependencies or transient issues
//   - Use exponential backoff (5s, 10s, 15s, up to 30s max)
//   - Log retry attempts with error details
//   - Return error only if timeout is reached
func DeleteResourceWithRetry(
        ctx context.Context,
        deleteFunc func() (interface{}, error),
        extractErrorFunc func(interface{}) (statusCode int, errorTitle *string, errorDetail *string, isError bool),
        resourceType, resourceID string,
        timeout time.Duration,
) error <span class="cov8" title="1">{
        deadline := time.Now().Add(timeout)
        retryInterval := 5 * time.Second // Start with 5 second intervals
        maxRetryInterval := 30 * time.Second
        attempt := 0

        tflog.Info(ctx, fmt.Sprintf("Attempting to delete %s %s", resourceType, resourceID))

        for </span><span class="cov8" title="1">{
                attempt++
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("context cancelled while deleting %s %s", resourceType, resourceID)</span>
                default:<span class="cov8" title="1">
                        if time.Now().After(deadline) </span><span class="cov0" title="0">{
                                return fmt.Errorf("timeout waiting to delete %s %s (timeout: %v, attempts: %d)", resourceType, resourceID, timeout, attempt)
                        }</span>

                        // Attempt deletion
                        <span class="cov8" title="1">response, err := deleteFunc()
                        if err != nil </span><span class="cov0" title="0">{
                                // Network or other non-API errors - retry as they might be transient
                                // Examples: EOF, connection reset, timeout, etc.
                                errorMsg := err.Error()
                                tflog.Info(ctx, fmt.Sprintf("%s %s deletion failed with network/connection error: %s. Retrying (attempt %d)...", resourceType, resourceID, errorMsg, attempt))

                                // Wait before retrying (exponential backoff with max limit)
                                waitTime := retryInterval
                                if attempt &gt; 1 </span><span class="cov0" title="0">{
                                        // Exponential backoff: 5s, 10s, 15s, 20s, 25s, 30s (max)
                                        waitTime = time.Duration(5*attempt) * time.Second
                                        if waitTime &gt; maxRetryInterval </span><span class="cov0" title="0">{
                                                waitTime = maxRetryInterval
                                        }</span>
                                }

                                <span class="cov0" title="0">select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return fmt.Errorf("context cancelled while waiting to delete %s %s", resourceType, resourceID)</span>
                                case &lt;-time.After(waitTime):<span class="cov0" title="0">
                                        // Continue to next iteration
                                        continue</span>
                                }
                        }

                        // Extract error details using provided extractor function
                        <span class="cov8" title="1">statusCode, errorTitle, errorDetail, isError := extractErrorFunc(response)

                        // Check if deletion succeeded (no error)
                        if !isError </span><span class="cov8" title="1">{
                                tflog.Info(ctx, fmt.Sprintf("Successfully deleted %s %s", resourceType, resourceID))
                                return nil
                        }</span>

                        // Check if resource was already deleted (404) - don't retry, consider success
                        <span class="cov0" title="0">if statusCode == 404 </span><span class="cov0" title="0">{
                                tflog.Info(ctx, fmt.Sprintf("%s %s already deleted (404)", resourceType, resourceID))
                                return nil
                        }</span>

                        // For any other API error, retry (might be dependency or transient issue)
                        // Build error message for logging
                        <span class="cov0" title="0">errorMsg := ""
                        if errorTitle != nil </span><span class="cov0" title="0">{
                                errorMsg = *errorTitle
                        }</span>
                        <span class="cov0" title="0">if errorDetail != nil </span><span class="cov0" title="0">{
                                if errorMsg != "" </span><span class="cov0" title="0">{
                                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *errorDetail)
                                }</span> else<span class="cov0" title="0"> {
                                        errorMsg = *errorDetail
                                }</span>
                        }
                        <span class="cov0" title="0">if errorMsg == "" </span><span class="cov0" title="0">{
                                errorMsg = fmt.Sprintf("API error (status: %d)", statusCode)
                        }</span>

                        <span class="cov0" title="0">tflog.Info(ctx, fmt.Sprintf("%s %s deletion failed: %s. Retrying (attempt %d)...", resourceType, resourceID, errorMsg, attempt))

                        // Wait before retrying (exponential backoff with max limit)
                        waitTime := retryInterval
                        if attempt &gt; 1 </span><span class="cov0" title="0">{
                                // Exponential backoff: 5s, 10s, 15s, 20s, 25s, 30s (max)
                                waitTime = time.Duration(5*attempt) * time.Second
                                if waitTime &gt; maxRetryInterval </span><span class="cov0" title="0">{
                                        waitTime = maxRetryInterval
                                }</span>
                        }

                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return fmt.Errorf("context cancelled while waiting to delete %s %s", resourceType, resourceID)</span>
                        case &lt;-time.After(waitTime):<span class="cov0" title="0"></span>
                                // Continue to next iteration
                        }
                }
        }
}

// ExtractSDKError extracts error information from SDK responses using reflection.
// All SDK responses follow the same structure: StatusCode (int), Error.Title (*string), Error.Detail (*string)
// This function can be used by all Delete methods to extract error info generically.
func ExtractSDKError(response interface{}) (statusCode int, errorTitle *string, errorDetail *string, isError bool) <span class="cov8" title="1">{
        // First check if response has IsError() method
        type errorResponse interface {
                IsError() bool
        }
        resp, ok := response.(errorResponse)
        if !ok </span><span class="cov0" title="0">{
                return 0, nil, nil, false
        }</span>
        <span class="cov8" title="1">if !resp.IsError() </span><span class="cov8" title="1">{
                return 0, nil, nil, false
        }</span>

        // Use reflection to access StatusCode and Error fields
        <span class="cov0" title="0">v := reflect.ValueOf(response)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        // Access StatusCode field
        <span class="cov0" title="0">statusCodeField := v.FieldByName("StatusCode")
        if !statusCodeField.IsValid() || !statusCodeField.CanInterface() </span><span class="cov0" title="0">{
                return 0, nil, nil, true // It's an error but can't extract details
        }</span>
        <span class="cov0" title="0">statusCode = int(statusCodeField.Int())

        // Access Error field
        errorField := v.FieldByName("Error")
        if !errorField.IsValid() </span><span class="cov0" title="0">{
                return statusCode, nil, nil, true
        }</span>

        // Access Error.Title and Error.Detail
        <span class="cov0" title="0">var title, detail *string
        errorVal := errorField
        if errorVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if errorVal.IsNil() </span><span class="cov0" title="0">{
                        return statusCode, nil, nil, true
                }</span>
                <span class="cov0" title="0">errorVal = errorVal.Elem()</span>
        }

        <span class="cov0" title="0">if errorVal.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                titleField := errorVal.FieldByName("Title")
                if titleField.IsValid() &amp;&amp; titleField.CanInterface() &amp;&amp; !titleField.IsNil() </span><span class="cov0" title="0">{
                        if titlePtr, ok := titleField.Interface().(*string); ok </span><span class="cov0" title="0">{
                                title = titlePtr
                        }</span>
                }

                <span class="cov0" title="0">detailField := errorVal.FieldByName("Detail")
                if detailField.IsValid() &amp;&amp; detailField.CanInterface() &amp;&amp; !detailField.IsNil() </span><span class="cov0" title="0">{
                        if detailPtr, ok := detailField.Interface().(*string); ok </span><span class="cov0" title="0">{
                                detail = detailPtr
                        }</span>
                }
        }

        <span class="cov0" title="0">return statusCode, title, detail, true</span>
}

// RetryDeleteOperation is a helper that handles retry logic for delete operations.
// It should be called from Delete methods when an API error occurs (except 404).
// This function handles the retry loop with exponential backoff.
//
// Parameters:
//   - ctx: Context for cancellation
//   - deleteFunc: Function that performs the delete operation
//   - extractError: Function that extracts error info from response
//   - resourceType: Resource type name for logging
//   - resourceID: Resource ID for logging
//   - timeout: Maximum time to wait
//
// Returns error if timeout is reached, nil on success.
func RetryDeleteOperation(
        ctx context.Context,
        deleteFunc func() (interface{}, error),
        extractError func(interface{}) (statusCode int, errorTitle *string, errorDetail *string, isError bool),
        resourceType, resourceID string,
        timeout time.Duration,
) error <span class="cov0" title="0">{
        return DeleteResourceWithRetry(ctx, deleteFunc, extractError, resourceType, resourceID, timeout)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;RestoreDataSource{}

func NewRestoreDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;RestoreDataSource{}
}</span>

type RestoreDataSource struct {
        client *ArubaCloudClient
}

type RestoreDataSourceModel struct {
        Id        types.String   `tfsdk:"id"`
        Name      types.String   `tfsdk:"name"`
        Location  types.String   `tfsdk:"location"`
        Tags      []types.String `tfsdk:"tags"`
        ProjectId types.String   `tfsdk:"project_id"`
        VolumeId  types.String   `tfsdk:"volume_id"`
}

func (d *RestoreDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_restore"
}</span>

func (d *RestoreDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Restore data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Restore identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Restore name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Restore location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the restore resource",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this restore belongs to",
                                Computed:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "Volume ID to restore",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *RestoreDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *RestoreDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data RestoreDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-restore")
        data.Location = types.StringValue("it-dc1")
        data.ProjectId = types.StringValue("example-project-id")
        data.VolumeId = types.StringValue("example-volume-id")
        data.Tags = []types.String{types.StringValue("tag1"), types.StringValue("tag2")}
        tflog.Trace(ctx, "read a Restore data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type RestoreResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectID types.String `tfsdk:"project_id"`
        BackupID  types.String `tfsdk:"backup_id"`
        VolumeID  types.String `tfsdk:"volume_id"`
}

type RestoreResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;RestoreResource{}
var _ resource.ResourceWithImportState = &amp;RestoreResource{}

func NewRestoreResource() resource.Resource <span class="cov8" title="1">{
        return &amp;RestoreResource{}
}</span>

func (r *RestoreResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_restore"
}</span>

func (r *RestoreResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Restore resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Restore identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Restore URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Restore name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Restore location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the restore resource",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this restore belongs to",
                                Required:            true,
                        },
                        "backup_id": schema.StringAttribute{
                                MarkdownDescription: "Backup ID to restore from",
                                Required:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "Volume ID to restore to",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *RestoreResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *RestoreResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data RestoreResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.BackupID.ValueString()
        volumeID := data.VolumeID.ValueString()

        if projectID == "" || backupID == "" || volumeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, Backup ID, and Volume ID are required to create a restore",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Get the backup details to get the full URI
        <span class="cov0" title="0">backupResponse, err := r.client.Client.FromStorage().Backups().Get(ctx, projectID, backupID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting backup details",
                        fmt.Sprintf("Unable to get backup details: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if backupResponse == nil || backupResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Backup Not Found",
                        "Backup not found",
                )
                return
        }</span>

        // backupURI is not used - removed unused variable

        // Get the volume details to get the full URI
        <span class="cov0" title="0">volumeResponse, err := r.client.Client.FromStorage().Volumes().Get(ctx, projectID, volumeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting volume details",
                        fmt.Sprintf("Unable to get volume details: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if volumeResponse == nil || volumeResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Volume Not Found",
                        "Volume not found",
                )
                return
        }</span>

        <span class="cov0" title="0">volumeURI := ""
        if volumeResponse.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                volumeURI = *volumeResponse.Data.Metadata.URI
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid Volume Response",
                        "Volume URI not found in response",
                )
                return
        }</span>

        // Build the restore request
        <span class="cov0" title="0">createRequest := sdktypes.RestoreRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.RestorePropertiesRequest{
                        Target: sdktypes.ReferenceResource{
                                URI: volumeURI,
                        },
                },
        }

        // Create the restore using the SDK
        response, err := r.client.Client.FromStorage().Restores().Create(ctx, projectID, backupID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating restore",
                        fmt.Sprintf("Unable to create restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create restore", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Restore created but no data returned from API",
                )
                return
        }</span>

        // Wait for Restore to be active before returning
        // This ensures Terraform doesn't proceed until Restore is ready
        <span class="cov0" title="0">restoreID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Restores().Get(ctx, projectID, backupID, restoreID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Restore to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Restore", restoreID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Restore Not Active",
                        fmt.Sprintf("Restore was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Restore resource", map[string]interface{}{
                "restore_id":   data.Id.ValueString(),
                "restore_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RestoreResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data RestoreResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.BackupID.ValueString()
        restoreID := data.Id.ValueString()

        if projectID == "" || backupID == "" || restoreID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, Backup ID, and Restore ID are required to read the restore",
                )
                return
        }</span>

        // Get restore details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Restores().Get(ctx, projectID, backupID, restoreID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading restore",
                        fmt.Sprintf("Unable to read restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "restore_id": restoreID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read restore", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                restore := response.Data

                if restore.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*restore.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if restore.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*restore.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if restore.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*restore.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if restore.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(restore.Metadata.LocationResponse.Value)
                }</span>
                // Note: Target field may not be available in RestorePropertiesResult
                // VolumeID is stored from the create request, preserve from state if needed
                // If Target is needed, check SDK for correct field name

                // Update tags
                <span class="cov0" title="0">if len(restore.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(restore.Metadata.Tags))
                        for i, tag := range restore.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RestoreResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data RestoreResourceModel
        var state RestoreResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        backupID := state.BackupID.ValueString()
        restoreID := state.Id.ValueString()

        if projectID == "" || backupID == "" || restoreID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, Backup ID, and Restore ID are required to update the restore",
                )
                return
        }</span>

        // Get current restore details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromStorage().Restores().Get(ctx, projectID, backupID, restoreID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current restore",
                        fmt.Sprintf("Unable to get current restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Restore Not Found",
                        "Restore not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for restore",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated
        <span class="cov0" title="0">updateRequest := sdktypes.RestoreRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.RestorePropertiesRequest{
                        // Properties cannot be updated
                        // Note: Target field may not be available in RestorePropertiesResult
                        // Preserve from state or use original create request values
                },
        }

        // Update the restore using the SDK
        response, err := r.client.Client.FromStorage().Restores().Update(ctx, projectID, backupID, restoreID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating restore",
                        fmt.Sprintf("Unable to update restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update restore", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.BackupID = state.BackupID
        data.Uri = state.Uri           // Preserve URI from state
        data.VolumeID = state.VolumeID // Immutable

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no response, re-read the restore to get the latest state including URI
                getResp, err := r.client.Client.FromStorage().Restores().Get(ctx, projectID, backupID, restoreID, nil)
                if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                        if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if not in response
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If re-read fails, preserve from state
                        data.Uri = state.Uri
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *RestoreResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data RestoreResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        backupID := data.BackupID.ValueString()
        restoreID := data.Id.ValueString()

        if projectID == "" || backupID == "" || restoreID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, Backup ID, and Restore ID are required to delete the restore",
                )
                return
        }</span>

        // Delete the restore using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromStorage().Restores().Delete(ctx, projectID, backupID, restoreID, nil)
                }</span>,
                ExtractSDKError,
                "Restore",
                restoreID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting restore",
                        fmt.Sprintf("Unable to delete restore: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Restore resource", map[string]interface{}{
                "restore_id": restoreID,
        })</span>
}

func (r *RestoreResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;ScheduleJobDataSource{}

func NewScheduleJobDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;ScheduleJobDataSource{}
}</span>

type ScheduleJobDataSource struct {
        client *ArubaCloudClient
}

type ScheduleJobDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Cron        types.String `tfsdk:"cron"`
}

func (d *ScheduleJobDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_schedulejob"
}</span>

func (d *ScheduleJobDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Schedule Job data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job name",
                                Computed:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job description",
                                Computed:            true,
                        },
                        "cron": schema.StringAttribute{
                                MarkdownDescription: "Cron expression for the schedule job",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *ScheduleJobDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *ScheduleJobDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data ScheduleJobDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-schedulejob")
        data.Description = types.StringValue("Simulated schedule job description")
        data.Cron = types.StringValue("0 0 * * *")
        tflog.Trace(ctx, "read a Schedule Job data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type ScheduleJobResourceModel struct {
        Id         types.String `tfsdk:"id"`
        Uri        types.String `tfsdk:"uri"`
        Name       types.String `tfsdk:"name"`
        ProjectID  types.String `tfsdk:"project_id"`
        Tags       types.List   `tfsdk:"tags"`
        Location   types.String `tfsdk:"location"`
        Properties types.Object `tfsdk:"properties"`
}

type ScheduleJobResource struct {
        client *ArubaCloudClient
}

var _ resource.Resource = &amp;ScheduleJobResource{}
var _ resource.ResourceWithImportState = &amp;ScheduleJobResource{}

func NewScheduleJobResource() resource.Resource <span class="cov8" title="1">{
        return &amp;ScheduleJobResource{}
}</span>

func (r *ScheduleJobResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_schedulejob"
}</span>

func (r *ScheduleJobResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Schedule Job resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Schedule Job name",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this job belongs to",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the job",
                                Optional:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Location for the job",
                                Required:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "enabled": schema.BoolAttribute{
                                                MarkdownDescription: "Whether the job is enabled.",
                                                Optional:            true,
                                        },
                                        "schedule_job_type": schema.StringAttribute{
                                                MarkdownDescription: "Type of job (OneShot, Recurring)",
                                                Required:            true,
                                        },
                                        "schedule_at": schema.StringAttribute{
                                                MarkdownDescription: "Date and time when the job should run (for OneShot)",
                                                Optional:            true,
                                        },
                                        "execute_until": schema.StringAttribute{
                                                MarkdownDescription: "End date until which the job can run (for Recurring)",
                                                Optional:            true,
                                        },
                                        "cron": schema.StringAttribute{
                                                MarkdownDescription: "CRON expression for recurrence (for Recurring)",
                                                Optional:            true,
                                        },
                                        "steps": schema.ListNestedAttribute{
                                                NestedObject: schema.NestedAttributeObject{
                                                        Attributes: map[string]schema.Attribute{
                                                                "name": schema.StringAttribute{
                                                                        MarkdownDescription: "Descriptive name of the step.",
                                                                        Optional:            true,
                                                                },
                                                                "resource_uri": schema.StringAttribute{
                                                                        MarkdownDescription: "URI of the resource.",
                                                                        Required:            true,
                                                                },
                                                                "action_uri": schema.StringAttribute{
                                                                        MarkdownDescription: "URI of the action to execute.",
                                                                        Required:            true,
                                                                },
                                                                "http_verb": schema.StringAttribute{
                                                                        MarkdownDescription: "HTTP verb to use (GET, POST, etc.)",
                                                                        Required:            true,
                                                                },
                                                                "body": schema.StringAttribute{
                                                                        MarkdownDescription: "Optional HTTP request body.",
                                                                        Optional:            true,
                                                                },
                                                        },
                                                },
                                                Optional: true,
                                        },
                                },
                                Required: true,
                        },
                },
        }
}</span>

func (r *ScheduleJobResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *ScheduleJobResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ScheduleJobResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()

        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to create a schedule job",
                )
                return
        }</span>

        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract properties
        <span class="cov0" title="0">propertiesObj := data.Properties.Attributes()

        jobTypeAttr, ok := propertiesObj["schedule_job_type"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "schedule_job_type must be a String")
                return
        }</span>
        <span class="cov0" title="0">jobType := jobTypeAttr.ValueString()

        enabled := true
        if enabledAttr, ok := propertiesObj["enabled"]; ok </span><span class="cov0" title="0">{
                if enabledBool, ok := enabledAttr.(types.Bool); ok &amp;&amp; !enabledBool.IsNull() </span><span class="cov0" title="0">{
                        enabled = enabledBool.ValueBool()
                }</span>
        }

        <span class="cov0" title="0">var scheduleAt *string
        if scheduleAtAttr, ok := propertiesObj["schedule_at"]; ok </span><span class="cov0" title="0">{
                if scheduleAtStr, ok := scheduleAtAttr.(types.String); ok &amp;&amp; !scheduleAtStr.IsNull() </span><span class="cov0" title="0">{
                        scheduleAtVal := scheduleAtStr.ValueString()
                        scheduleAt = &amp;scheduleAtVal
                }</span>
        }

        <span class="cov0" title="0">var cron *string
        if cronAttr, ok := propertiesObj["cron"]; ok </span><span class="cov0" title="0">{
                if cronStr, ok := cronAttr.(types.String); ok &amp;&amp; !cronStr.IsNull() </span><span class="cov0" title="0">{
                        cronVal := cronStr.ValueString()
                        cron = &amp;cronVal
                }</span>
        }

        <span class="cov0" title="0">var executeUntil *string
        if executeUntilAttr, ok := propertiesObj["execute_until"]; ok </span><span class="cov0" title="0">{
                if executeUntilStr, ok := executeUntilAttr.(types.String); ok &amp;&amp; !executeUntilStr.IsNull() </span><span class="cov0" title="0">{
                        executeUntilVal := executeUntilStr.ValueString()
                        executeUntil = &amp;executeUntilVal
                }</span>
        }

        // Extract steps
        <span class="cov0" title="0">var steps []sdktypes.JobStep
        if stepsAttr, ok := propertiesObj["steps"]; ok </span><span class="cov0" title="0">{
                if stepsList, ok := stepsAttr.(types.List); ok &amp;&amp; !stepsList.IsNull() </span><span class="cov0" title="0">{
                        var stepsElements []types.Object
                        diags := stepsList.ElementsAs(ctx, &amp;stepsElements, false)
                        resp.Diagnostics.Append(diags...)
                        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">for _, stepObj := range stepsElements </span><span class="cov0" title="0">{
                                stepAttrs := stepObj.Attributes()

                                var name *string
                                if nameAttr, ok := stepAttrs["name"]; ok </span><span class="cov0" title="0">{
                                        if nameStr, ok := nameAttr.(types.String); ok &amp;&amp; !nameStr.IsNull() </span><span class="cov0" title="0">{
                                                nameVal := nameStr.ValueString()
                                                name = &amp;nameVal
                                        }</span>
                                }

                                <span class="cov0" title="0">var resourceURI string
                                if resURIAttr, ok := stepAttrs["resource_uri"]; ok </span><span class="cov0" title="0">{
                                        if resURIStr, ok := resURIAttr.(types.String); ok </span><span class="cov0" title="0">{
                                                resourceURI = resURIStr.ValueString()
                                        }</span>
                                }

                                <span class="cov0" title="0">var actionURI string
                                if actURIAttr, ok := stepAttrs["action_uri"]; ok </span><span class="cov0" title="0">{
                                        if actURIStr, ok := actURIAttr.(types.String); ok </span><span class="cov0" title="0">{
                                                actionURI = actURIStr.ValueString()
                                        }</span>
                                }

                                <span class="cov0" title="0">var httpVerb string
                                if verbAttr, ok := stepAttrs["http_verb"]; ok </span><span class="cov0" title="0">{
                                        if verbStr, ok := verbAttr.(types.String); ok </span><span class="cov0" title="0">{
                                                httpVerb = verbStr.ValueString()
                                        }</span>
                                }

                                <span class="cov0" title="0">var body *string
                                if bodyAttr, ok := stepAttrs["body"]; ok </span><span class="cov0" title="0">{
                                        if bodyStr, ok := bodyAttr.(types.String); ok &amp;&amp; !bodyStr.IsNull() </span><span class="cov0" title="0">{
                                                bodyVal := bodyStr.ValueString()
                                                body = &amp;bodyVal
                                        }</span>
                                }

                                <span class="cov0" title="0">steps = append(steps, sdktypes.JobStep{
                                        Name:        name,
                                        ResourceURI: resourceURI,
                                        ActionURI:   actionURI,
                                        HttpVerb:    httpVerb,
                                        Body:        body,
                                })</span>
                        }
                }
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.JobRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.JobPropertiesRequest{
                        Enabled:      enabled,
                        JobType:      sdktypes.TypeJob(jobType),
                        ScheduleAt:   scheduleAt,
                        Cron:         cron,
                        ExecuteUntil: executeUntil,
                        Steps:        steps,
                },
        }

        // Create the job using the SDK
        response, err := r.client.Client.FromSchedule().Jobs().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating schedule job",
                        fmt.Sprintf("Unable to create schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create schedule job", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Schedule job created but no ID returned from API",
                )
                return
        }</span>

        // Wait for Schedule Job to be active before returning
        // This ensures Terraform doesn't proceed until Job is ready
        <span class="cov0" title="0">jobID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromSchedule().Jobs().Get(ctx, projectID, jobID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Schedule Job to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "ScheduleJob", jobID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Schedule Job Not Active",
                        fmt.Sprintf("Schedule job was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Schedule Job resource", map[string]interface{}{
                "job_id":   data.Id.ValueString(),
                "job_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ScheduleJobResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data ScheduleJobResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        jobID := data.Id.ValueString()

        if projectID == "" || jobID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Job ID are required to read the schedule job",
                )
                return
        }</span>

        // Get job details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromSchedule().Jobs().Get(ctx, projectID, jobID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading schedule job",
                        fmt.Sprintf("Unable to read schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "job_id":     jobID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read schedule job", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                job := response.Data
                if job.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*job.Metadata.ID)
                        if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                        <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                data.Uri = types.StringValue(*response.Data.Metadata.URI)
                        }</span> else<span class="cov0" title="0"> {
                                data.Uri = types.StringNull()
                        }</span>
                }
                <span class="cov0" title="0">if job.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*job.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if job.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(job.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if job.Metadata.Tags != nil </span><span class="cov0" title="0">{
                        tagValues := make([]attr.Value, len(job.Metadata.Tags))
                        for i, tag := range job.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValue(types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.Tags = types.ListNull(types.StringType)
                }</span>

                // Define step object type
                <span class="cov0" title="0">stepObjectType := types.ObjectType{
                        AttrTypes: map[string]attr.Type{
                                "name":         types.StringType,
                                "resource_uri": types.StringType,
                                "action_uri":   types.StringType,
                                "http_verb":    types.StringType,
                                "body":         types.StringType,
                        },
                }

                // Convert steps from API response
                var stepsListValue types.List
                if len(job.Properties.Steps) &gt; 0 </span><span class="cov0" title="0">{
                        stepObjects := make([]attr.Value, len(job.Properties.Steps))
                        for i, step := range job.Properties.Steps </span><span class="cov0" title="0">{
                                stepAttrs := map[string]attr.Value{
                                        "name":         types.StringNull(),
                                        "resource_uri": types.StringNull(),
                                        "action_uri":   types.StringNull(),
                                        "http_verb":    types.StringNull(),
                                        "body":         types.StringNull(),
                                }

                                if step.Name != nil </span><span class="cov0" title="0">{
                                        stepAttrs["name"] = types.StringValue(*step.Name)
                                }</span>
                                <span class="cov0" title="0">if step.ResourceURI != nil </span><span class="cov0" title="0">{
                                        stepAttrs["resource_uri"] = types.StringValue(*step.ResourceURI)
                                }</span>
                                <span class="cov0" title="0">if step.ActionURI != nil </span><span class="cov0" title="0">{
                                        stepAttrs["action_uri"] = types.StringValue(*step.ActionURI)
                                }</span>
                                <span class="cov0" title="0">if step.HttpVerb != nil </span><span class="cov0" title="0">{
                                        stepAttrs["http_verb"] = types.StringValue(*step.HttpVerb)
                                }</span>
                                <span class="cov0" title="0">if step.Body != nil </span><span class="cov0" title="0">{
                                        stepAttrs["body"] = types.StringValue(*step.Body)
                                }</span>

                                <span class="cov0" title="0">stepObj, diags := types.ObjectValue(stepObjectType.AttrTypes, stepAttrs)
                                resp.Diagnostics.Append(diags...)
                                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">stepObjects[i] = stepObj</span>
                        }
                        <span class="cov0" title="0">var diags diag.Diagnostics
                        stepsListValue, diags = types.ListValue(stepObjectType, stepObjects)
                        resp.Diagnostics.Append(diags...)
                        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        stepsListValue = types.ListNull(stepObjectType)
                }</span>

                // Reconstruct properties object
                <span class="cov0" title="0">propertiesAttrs := map[string]attr.Value{
                        "enabled":           types.BoolValue(job.Properties.Enabled),
                        "schedule_job_type": types.StringValue(string(job.Properties.JobType)),
                        "schedule_at":       types.StringNull(),
                        "execute_until":     types.StringNull(),
                        "cron":              types.StringNull(),
                        "steps":             stepsListValue,
                }

                if job.Properties.ScheduleAt != nil </span><span class="cov0" title="0">{
                        propertiesAttrs["schedule_at"] = types.StringValue(*job.Properties.ScheduleAt)
                }</span>
                <span class="cov0" title="0">if job.Properties.ExecuteUntil != nil </span><span class="cov0" title="0">{
                        propertiesAttrs["execute_until"] = types.StringValue(*job.Properties.ExecuteUntil)
                }</span>
                <span class="cov0" title="0">if job.Properties.Cron != nil </span><span class="cov0" title="0">{
                        propertiesAttrs["cron"] = types.StringValue(*job.Properties.Cron)
                }</span>

                <span class="cov0" title="0">propertiesObj, diags := types.ObjectValue(
                        map[string]attr.Type{
                                "enabled":           types.BoolType,
                                "schedule_job_type": types.StringType,
                                "schedule_at":       types.StringType,
                                "execute_until":     types.StringType,
                                "cron":              types.StringType,
                                "steps":             types.ListType{ElemType: stepObjectType},
                        },
                        propertiesAttrs,
                )
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Properties = propertiesObj
                }</span>
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ScheduleJobResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data ScheduleJobResourceModel
        var state ScheduleJobResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        jobID := state.Id.ValueString()

        if projectID == "" || jobID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Job ID are required to update the schedule job",
                )
                return
        }</span>

        // Get current job to preserve fields
        <span class="cov0" title="0">getResp, err := r.client.Client.FromSchedule().Jobs().Get(ctx, projectID, jobID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting schedule job",
                        fmt.Sprintf("Unable to get schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResp == nil || getResp.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Job Not Found",
                        "Schedule job not found",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResp.Data
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>

        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Extract properties
        <span class="cov0" title="0">propertiesObj := data.Properties.Attributes()

        enabled := current.Properties.Enabled
        if enabledAttr, ok := propertiesObj["enabled"]; ok </span><span class="cov0" title="0">{
                if enabledBool, ok := enabledAttr.(types.Bool); ok &amp;&amp; !enabledBool.IsNull() </span><span class="cov0" title="0">{
                        enabled = enabledBool.ValueBool()
                }</span>
        }

        // Extract steps from properties
        <span class="cov0" title="0">var steps []sdktypes.JobStep
        if stepsAttr, ok := propertiesObj["steps"]; ok </span><span class="cov0" title="0">{
                if stepsList, ok := stepsAttr.(types.List); ok &amp;&amp; !stepsList.IsNull() </span><span class="cov0" title="0">{
                        var stepsElements []types.Object
                        diags := stepsList.ElementsAs(ctx, &amp;stepsElements, false)
                        resp.Diagnostics.Append(diags...)
                        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">for _, stepObj := range stepsElements </span><span class="cov0" title="0">{
                                stepAttrs := stepObj.Attributes()

                                var name *string
                                if nameAttr, ok := stepAttrs["name"]; ok </span><span class="cov0" title="0">{
                                        if nameStr, ok := nameAttr.(types.String); ok &amp;&amp; !nameStr.IsNull() </span><span class="cov0" title="0">{
                                                nameVal := nameStr.ValueString()
                                                name = &amp;nameVal
                                        }</span>
                                }

                                <span class="cov0" title="0">var resourceURI string
                                if resURIAttr, ok := stepAttrs["resource_uri"]; ok </span><span class="cov0" title="0">{
                                        if resURIStr, ok := resURIAttr.(types.String); ok </span><span class="cov0" title="0">{
                                                resourceURI = resURIStr.ValueString()
                                        }</span>
                                }

                                <span class="cov0" title="0">var actionURI string
                                if actURIAttr, ok := stepAttrs["action_uri"]; ok </span><span class="cov0" title="0">{
                                        if actURIStr, ok := actURIAttr.(types.String); ok </span><span class="cov0" title="0">{
                                                actionURI = actURIStr.ValueString()
                                        }</span>
                                }

                                <span class="cov0" title="0">var httpVerb string
                                if verbAttr, ok := stepAttrs["http_verb"]; ok </span><span class="cov0" title="0">{
                                        if verbStr, ok := verbAttr.(types.String); ok </span><span class="cov0" title="0">{
                                                httpVerb = verbStr.ValueString()
                                        }</span>
                                }

                                <span class="cov0" title="0">var body *string
                                if bodyAttr, ok := stepAttrs["body"]; ok </span><span class="cov0" title="0">{
                                        if bodyStr, ok := bodyAttr.(types.String); ok &amp;&amp; !bodyStr.IsNull() </span><span class="cov0" title="0">{
                                                bodyVal := bodyStr.ValueString()
                                                body = &amp;bodyVal
                                        }</span>
                                }

                                <span class="cov0" title="0">steps = append(steps, sdktypes.JobStep{
                                        Name:        name,
                                        ResourceURI: resourceURI,
                                        ActionURI:   actionURI,
                                        HttpVerb:    httpVerb,
                                        Body:        body,
                                })</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // If steps not provided in update, use current steps
                if current.Properties.Steps != nil </span><span class="cov0" title="0">{
                        steps = make([]sdktypes.JobStep, len(current.Properties.Steps))
                        for i, currentStep := range current.Properties.Steps </span><span class="cov0" title="0">{
                                step := sdktypes.JobStep{
                                        Name: currentStep.Name,
                                        Body: currentStep.Body,
                                }
                                if currentStep.ResourceURI != nil </span><span class="cov0" title="0">{
                                        step.ResourceURI = *currentStep.ResourceURI
                                }</span>
                                <span class="cov0" title="0">if currentStep.ActionURI != nil </span><span class="cov0" title="0">{
                                        step.ActionURI = *currentStep.ActionURI
                                }</span>
                                <span class="cov0" title="0">if currentStep.HttpVerb != nil </span><span class="cov0" title="0">{
                                        step.HttpVerb = *currentStep.HttpVerb
                                }</span>
                                <span class="cov0" title="0">steps[i] = step</span>
                        }
                }
        }

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.JobRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.JobPropertiesRequest{
                        Enabled:      enabled,
                        JobType:      current.Properties.JobType,
                        ScheduleAt:   current.Properties.ScheduleAt,
                        ExecuteUntil: current.Properties.ExecuteUntil,
                        Cron:         current.Properties.Cron,
                        Steps:        steps,
                },
        }

        // Update the job using the SDK
        response, err := r.client.Client.FromSchedule().Jobs().Update(ctx, projectID, jobID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating schedule job",
                        fmt.Sprintf("Unable to update schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update schedule job", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil &amp;&amp; response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*response.Data.Metadata.ID)
                if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ScheduleJobResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ScheduleJobResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        jobID := data.Id.ValueString()

        if projectID == "" || jobID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Job ID are required to delete the schedule job",
                )
                return
        }</span>

        // Delete the job using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromSchedule().Jobs().Delete(ctx, projectID, jobID, nil)
                }</span>,
                ExtractSDKError,
                "ScheduleJob",
                jobID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting schedule job",
                        fmt.Sprintf("Unable to delete schedule job: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Schedule Job resource", map[string]interface{}{
                "job_id": jobID,
        })</span>
}

func (r *ScheduleJobResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;SecurityGroupDataSource{}

func NewSecurityGroupDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;SecurityGroupDataSource{}
}</span>

type SecurityGroupDataSource struct {
        client *ArubaCloudClient
}

type SecurityGroupDataSourceModel struct {
        Id        types.String `tfsdk:"id"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
}

func (d *SecurityGroupDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_securitygroup"
}</span>

func (d *SecurityGroupDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Security Group data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Security Group identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Security Group name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Security Group location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Security Group",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Security Group belongs to",
                                Computed:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this Security Group belongs to",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *SecurityGroupDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *SecurityGroupDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data SecurityGroupDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Name = types.StringValue("example-securitygroup")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.ProjectId = types.StringValue("68398923fb2cb026400d4d31")
        data.VpcId = types.StringValue("vpc-68398923fb2cb026400d4d32")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("security"),
                types.StringValue("firewall"),
                types.StringValue("production"),
        })

        tflog.Trace(ctx, "read a Security Group data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;SecurityGroupResource{}
var _ resource.ResourceWithImportState = &amp;SecurityGroupResource{}

func NewSecurityGroupResource() resource.Resource <span class="cov8" title="1">{
        return &amp;SecurityGroupResource{}
}</span>

type SecurityGroupResource struct {
        client *ArubaCloudClient
}

type SecurityGroupResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
}

func (r *SecurityGroupResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_securitygroup"
}</span>

func (r *SecurityGroupResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Security Group resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Security Group identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Security Group URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Security Group name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Security Group location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Security Group",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Security Group belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this Security Group belongs to",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
        }
}</span>

func (r *SecurityGroupResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *SecurityGroupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SecurityGroupResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to create a security group",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.SecurityGroupRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
        }

        // Create the security group using the SDK
        response, err := r.client.Client.FromNetwork().SecurityGroups().Create(ctx, projectID, vpcID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating security group",
                        fmt.Sprintf("Unable to create security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create security group", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(response.Data.Metadata.LocationResponse.Value)
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Security group created but no data returned from API",
                )
                return
        }</span>

        // Wait for Security Group to be active before returning (SecurityGroup is referenced by CloudServer, SecurityRule)
        // This ensures Terraform doesn't proceed to create dependent resources until SecurityGroup is ready
        <span class="cov0" title="0">sgID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Security Group to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "SecurityGroup", sgID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Security Group Not Active",
                        fmt.Sprintf("Security group was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the Security Group to get the URI and ensure all fields are properly set
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(getResp.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(getResp.Data.Metadata.Tags))
                        for i, tag := range getResp.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Security Group after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Security Group resource", map[string]interface{}{
                "securitygroup_id":   data.Id.ValueString(),
                "securitygroup_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityGroupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SecurityGroupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        sgID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || sgID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Security Group ID are required to read the security group",
                )
                return
        }</span>

        // Get security group details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading security group",
                        fmt.Sprintf("Unable to read security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id":        projectID,
                        "security_group_id": sgID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read security group", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                sg := response.Data

                if sg.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*sg.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if sg.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*sg.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if sg.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*sg.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if sg.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(sg.Metadata.LocationResponse.Value)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(sg.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(sg.Metadata.Tags))
                        for i, tag := range sg.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityGroupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SecurityGroupResourceModel
        var state SecurityGroupResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        sgID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || sgID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Security Group ID are required to update the security group",
                )
                return
        }</span>

        // Get current security group details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current security group",
                        fmt.Sprintf("Unable to get current security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Security Group Not Found",
                        "Security group not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Extract tags from Terraform list
        var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build the update request
        <span class="cov0" title="0">updateRequest := sdktypes.SecurityGroupRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
        }

        // Update the security group using the SDK
        response, err := r.client.Client.FromNetwork().SecurityGroups().Update(ctx, projectID, vpcID, sgID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating security group",
                        fmt.Sprintf("Unable to update security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update security group", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId
        data.Uri = state.Uri // Preserve URI from state

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If no URI in response, re-read the security group to get the latest state
                        getResp, err := r.client.Client.FromNetwork().SecurityGroups().Get(ctx, projectID, vpcID, sgID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                                }</span> else<span class="cov0" title="0"> {
                                        data.Uri = state.Uri // Fallback to state if not available
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if re-read fails
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI from state
                data.Uri = state.Uri
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityGroupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SecurityGroupResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        sgID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || sgID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Security Group ID are required to delete the security group",
                )
                return
        }</span>

        // Delete the security group using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().SecurityGroups().Delete(ctx, projectID, vpcID, sgID, nil)
                }</span>,
                ExtractSDKError,
                "SecurityGroup",
                sgID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting security group",
                        fmt.Sprintf("Unable to delete security group: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Security Group resource", map[string]interface{}{
                "securitygroup_id": sgID,
        })</span>
}

func (r *SecurityGroupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;SecurityRuleDataSource{}

func NewSecurityRuleDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;SecurityRuleDataSource{}
}</span>

type SecurityRuleDataSource struct {
        client *ArubaCloudClient
}

type SecurityRuleDataSourceModel struct {
        Id              types.String `tfsdk:"id"`
        Uri             types.String `tfsdk:"uri"`
        Name            types.String `tfsdk:"name"`
        Location        types.String `tfsdk:"location"`
        ProjectId       types.String `tfsdk:"project_id"`
        VpcId           types.String `tfsdk:"vpc_id"`
        SecurityGroupId types.String `tfsdk:"security_group_id"`
        Tags            types.List   `tfsdk:"tags"`
        // Properties fields (flattened)
        Direction types.String `tfsdk:"direction"`
        Protocol  types.String `tfsdk:"protocol"`
        Port      types.String `tfsdk:"port"`
        // Target fields (flattened)
        TargetKind  types.String `tfsdk:"target_kind"`
        TargetValue types.String `tfsdk:"target_value"`
}

func (d *SecurityRuleDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_securityrule"
}</span>

func (d *SecurityRuleDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Security Rule data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Security Rule identifier",
                                Required:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Security Rule URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Security Rule name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Security Rule location",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Security Rule belongs to",
                                Computed:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this Security Rule belongs to",
                                Computed:            true,
                        },
                        "security_group_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the Security Group this rule belongs to",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Security Rule",
                                Computed:            true,
                        },
                        "direction": schema.StringAttribute{
                                MarkdownDescription: "Direction of the rule (Ingress/Egress)",
                                Computed:            true,
                        },
                        "protocol": schema.StringAttribute{
                                MarkdownDescription: "Protocol (ANY, TCP, UDP, ICMP)",
                                Computed:            true,
                        },
                        "port": schema.StringAttribute{
                                MarkdownDescription: "Port or port range (for TCP/UDP)",
                                Computed:            true,
                        },
                        "target_kind": schema.StringAttribute{
                                MarkdownDescription: "Type of the target (IP/SecurityGroup)",
                                Computed:            true,
                        },
                        "target_value": schema.StringAttribute{
                                MarkdownDescription: "Value of the target (CIDR or SecurityGroup URI)",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *SecurityRuleDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *SecurityRuleDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data SecurityRuleDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        // Populate all fields with example data
        <span class="cov8" title="1">data.Uri = types.StringValue("/v2/securityrules/sr-68398923fb2cb026400d4d31")
        data.Name = types.StringValue("example-securityrule")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.ProjectId = types.StringValue("68398923fb2cb026400d4d31")
        data.VpcId = types.StringValue("vpc-68398923fb2cb026400d4d32")
        data.SecurityGroupId = types.StringValue("sg-68398923fb2cb026400d4d33")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("security"),
                types.StringValue("firewall"),
        })
        // Properties fields
        data.Direction = types.StringValue("Ingress")
        data.Protocol = types.StringValue("TCP")
        data.Port = types.StringValue("80")
        // Target fields
        data.TargetKind = types.StringValue("IP")
        data.TargetValue = types.StringValue("192.168.1.0/24")

        tflog.Trace(ctx, "read a Security Rule data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// RuleDirection represents the direction of a security rule.
type RuleDirection string

const (
        RuleDirectionIngress RuleDirection = "Ingress"
        RuleDirectionEgress  RuleDirection = "Egress"
)

type SecurityRuleResource struct {
        client *ArubaCloudClient
}

// EndpointTypeDto represents the type of target endpoint
// ...existing code...
type EndpointTypeDto string

const (
        EndpointTypeIP EndpointTypeDto = "Ip"
)

// normalizeProtocol normalizes protocol values to match API expectations.
// API expects: Any, TCP, UDP, ICMP (case-sensitive).
func normalizeProtocol(protocol string) string <span class="cov0" title="0">{
        protocolUpper := strings.ToUpper(protocol)
        switch protocolUpper </span>{
        case "ANY":<span class="cov0" title="0">
                return "Any"</span>
        case "TCP":<span class="cov0" title="0">
                return "TCP"</span>
        case "UDP":<span class="cov0" title="0">
                return "UDP"</span>
        case "ICMP":<span class="cov0" title="0">
                return "ICMP"</span>
        default:<span class="cov0" title="0">
                // If it's already in the correct format (e.g., "Any"), return as-is
                // Otherwise, try to capitalize first letter
                if len(protocol) &gt; 0 </span><span class="cov0" title="0">{
                        return strings.ToUpper(protocol[:1]) + strings.ToLower(protocol[1:])
                }</span>
                <span class="cov0" title="0">return protocol</span>
        }
}

// protocolNormalizePlanModifier normalizes protocol values during planning
// to prevent false positives when comparing state ("Any") with config ("ANY").
type protocolNormalizePlanModifier struct{}

func (m protocolNormalizePlanModifier) Description(ctx context.Context) string <span class="cov0" title="0">{
        return "Normalizes protocol values to prevent case-sensitivity issues"
}</span>

func (m protocolNormalizePlanModifier) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return "Normalizes protocol values to prevent case-sensitivity issues"
}</span>

func (m protocolNormalizePlanModifier) PlanModifyString(ctx context.Context, req planmodifier.StringRequest, resp *planmodifier.StringResponse) <span class="cov0" title="0">{
        // Normalize the plan value to uppercase to match state format
        // State stores protocol in uppercase (e.g., "ANY") to match user input format
        if !req.PlanValue.IsNull() &amp;&amp; !req.PlanValue.IsUnknown() </span><span class="cov0" title="0">{
                normalized := strings.ToUpper(req.PlanValue.ValueString())
                resp.PlanValue = types.StringValue(normalized)
                return
        }</span>

        // If plan is null/unknown, use state value (already in uppercase)
        <span class="cov0" title="0">if !req.StateValue.IsNull() &amp;&amp; !req.StateValue.IsUnknown() </span><span class="cov0" title="0">{
                resp.PlanValue = req.StateValue
                return
        }</span>
}

// normalizeTargetKind normalizes target kind values to match API expectations
// API expects: IP (not Ip, ip, etc.)
func normalizeTargetKind(kind string) string <span class="cov0" title="0">{
        kindUpper := strings.ToUpper(kind)
        switch kindUpper </span>{
        case "IP":<span class="cov0" title="0">
                return "IP"</span>
        case "SECURITYGROUP":<span class="cov0" title="0">
                return "SecurityGroup"</span>
        default:<span class="cov0" title="0">
                // If it's already in the correct format, return as-is
                // For "Ip", convert to "IP"
                if strings.EqualFold(kind, "Ip") </span><span class="cov0" title="0">{
                        return "IP"
                }</span>
                <span class="cov0" title="0">return kind</span>
        }
}

// RuleTarget represents the target of the rule (source or destination according to the direction).
type RuleTarget struct {
        Kind  EndpointTypeDto `tfsdk:"kind"`
        Value string          `tfsdk:"value"`
}

// SecurityRuleProperties contains the properties of a security rule.
type SecurityRulePropertiesRequest struct {
        Direction RuleDirection `tfsdk:"direction"`
        Protocol  string        `tfsdk:"protocol"`
        Port      string        `tfsdk:"port"`
        Target    *RuleTarget   `tfsdk:"target"`
}

var _ resource.Resource = &amp;SecurityRuleResource{}
var _ resource.ResourceWithImportState = &amp;SecurityRuleResource{}

func NewSecurityRuleResource() resource.Resource <span class="cov8" title="1">{
        return &amp;SecurityRuleResource{}
}</span>

type SecurityRuleResourceModel struct {
        Id              types.String `tfsdk:"id"`
        Uri             types.String `tfsdk:"uri"`
        Name            types.String `tfsdk:"name"`
        Location        types.String `tfsdk:"location"`
        Tags            types.List   `tfsdk:"tags"`
        ProjectId       types.String `tfsdk:"project_id"`
        VpcId           types.String `tfsdk:"vpc_id"`
        SecurityGroupId types.String `tfsdk:"security_group_id"`
        Properties      types.Object `tfsdk:"properties"`
}

func (r *SecurityRuleResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_securityrule"
}</span>

func (r *SecurityRuleResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Security Rule resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Security Rule identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Security Rule URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Security Rule name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Security Rule location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Security Rule belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this Security Rule belongs to",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "security_group_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the Security Group this rule belongs to",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the Security Rule",
                                Optional:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                MarkdownDescription: "Properties of the security rule",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "direction": schema.StringAttribute{
                                                MarkdownDescription: "Direction of the rule (Ingress/Egress)",
                                                Required:            true,
                                                // Validators removed for v1.16.1 compatibility
                                        },
                                        "protocol": schema.StringAttribute{
                                                MarkdownDescription: "Protocol (ANY, TCP, UDP, ICMP)",
                                                Required:            true,
                                                // Validators removed for v1.16.1 compatibility
                                                PlanModifiers: []planmodifier.String{
                                                        // Custom plan modifier to normalize protocol values
                                                        // This prevents false positives when comparing state ("Any") with config ("ANY")
                                                        protocolNormalizePlanModifier{},
                                                },
                                        },
                                        "port": schema.StringAttribute{
                                                MarkdownDescription: "Port or port range (for TCP/UDP)",
                                                Optional:            true,
                                        },
                                        "target": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Target of the rule (source or destination)",
                                                Required:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "kind": schema.StringAttribute{
                                                                MarkdownDescription: "Type of the target (Ip/SecurityGroup)",
                                                                Required:            true,
                                                                // Validators removed for v1.16.1 compatibility
                                                        },
                                                        "value": schema.StringAttribute{
                                                                MarkdownDescription: "Value of the target (CIDR or SecurityGroup URI)",
                                                                Required:            true,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func (r *SecurityRuleResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *SecurityRuleResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SecurityRuleResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        securityGroupID := data.SecurityGroupId.ValueString()

        if projectID == "" || vpcID == "" || securityGroupID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Security Group ID are required to create a security rule",
                )
                return
        }</span>

        // Extract tags - only include if actually provided
        // CLI doesn't include tags in JSON if not provided (SDK omits empty slices with omitempty)
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        // Don't set tags to empty slice - let SDK handle it (will be omitted with omitempty)
        // This matches CLI behavior where tags are only included if provided

        // Extract properties from Terraform object
        <span class="cov0" title="0">propertiesObj, diags := data.Properties.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">propertiesAttrs := propertiesObj.Attributes()
        directionAttr, ok := propertiesAttrs["direction"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "direction must be a String")
                return
        }</span>
        <span class="cov0" title="0">direction := directionAttr.ValueString()

        protocolAttr, ok := propertiesAttrs["protocol"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "protocol must be a String")
                return
        }</span>
        <span class="cov0" title="0">protocol := protocolAttr.ValueString()

        // Normalize protocol to match API expectations (case-sensitive)
        // API expects: Any, TCP, UDP, ICMP (not ANY, tcp, etc.)
        protocol = normalizeProtocol(protocol)

        port := ""
        if portAttr, ok := propertiesAttrs["port"]; ok &amp;&amp; portAttr != nil </span><span class="cov0" title="0">{
                if portStr, ok := portAttr.(types.String); ok &amp;&amp; !portStr.IsNull() </span><span class="cov0" title="0">{
                        port = portStr.ValueString()
                }</span>
        }

        // Adapter: If protocol is Any or ICMP, port must be completely omitted (API requirement)
        // The CLI omits the port field entirely for Any/ICMP protocols (see CLI request JSON)
        // Clear port to empty string so it will be omitted in JSON
        <span class="cov0" title="0">originalPort := port
        if strings.EqualFold(protocol, "Any") || strings.EqualFold(protocol, "ICMP") </span><span class="cov0" title="0">{
                port = ""
                tflog.Info(ctx, "Clearing port field for Any/ICMP protocol (will be omitted from JSON)", map[string]interface{}{
                        "protocol":     protocol,
                        "originalPort": originalPort,
                        "clearedPort":  port,
                })
        }</span>

        // Extract target
        <span class="cov0" title="0">targetObjAttr, ok := propertiesAttrs["target"].(types.Object)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "target must be an Object")
                return
        }</span>
        <span class="cov0" title="0">targetObjValue, diags := targetObjAttr.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">targetAttrs := targetObjValue.Attributes()
        targetKindAttr, ok := targetAttrs["kind"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "target.kind must be a String")
                return
        }</span>
        <span class="cov0" title="0">targetKind := targetKindAttr.ValueString()

        // Normalize target kind to match API expectations (case-sensitive)
        // API expects: IP (not Ip, ip, etc.)
        targetKind = normalizeTargetKind(targetKind)

        targetValueAttr, ok := targetAttrs["value"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "target.value must be a String")
                return
        }</span>
        <span class="cov0" title="0">targetValue := targetValueAttr.ValueString()

        tflog.Debug(ctx, "Creating security rule request", map[string]interface{}{
                "protocol":    protocol,
                "port":        port,
                "portEmpty":   port == "",
                "direction":   direction,
                "targetKind":  targetKind,
                "targetValue": targetValue,
        })

        // Build the properties
        // Note: The SDK should handle empty Port strings with omitempty JSON tag
        // If that doesn't work, we'll need to use JSON manipulation
        target := &amp;sdktypes.RuleTarget{
                Kind:  sdktypes.EndpointTypeDto(targetKind),
                Value: targetValue,
        }

        // Build properties - match CLI behavior exactly
        // CLI omits Port field entirely for Any/ICMP protocols (see CLI request JSON)
        // IMPORTANT: For Any/ICMP, port MUST be empty string (cleared above) and Port field MUST be omitted
        // Use JSON manipulation to ensure Port is completely omitted when empty
        var properties sdktypes.SecurityRulePropertiesRequest

        // Double-check: If protocol is Any/ICMP, ensure port is empty (safety check)
        if strings.EqualFold(protocol, "Any") || strings.EqualFold(protocol, "ICMP") </span><span class="cov0" title="0">{
                if port != "" </span><span class="cov0" title="0">{
                        tflog.Warn(ctx, "Port was not cleared for Any/ICMP protocol, forcing it now", map[string]interface{}{
                                "protocol": protocol,
                                "port":     port,
                        })
                        port = ""
                }</span>
        }

        <span class="cov0" title="0">if port == "" </span><span class="cov0" title="0">{
                // For Any/ICMP protocols, omit Port field completely (match CLI behavior)
                tflog.Debug(ctx, "Omitting Port field for Any/ICMP protocol (matching CLI behavior)", map[string]interface{}{
                        "protocol": protocol,
                })
                propertiesMap := map[string]interface{}{
                        "direction": string(sdktypes.RuleDirection(direction)),
                        "protocol":  protocol,
                        "target": map[string]interface{}{
                                "kind":  string(sdktypes.EndpointTypeDto(targetKind)),
                                "value": targetValue,
                        },
                }
                jsonData, err := json.Marshal(propertiesMap)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error building request",
                                fmt.Sprintf("Unable to build security rule properties: %s", err),
                        )
                        return
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;properties); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error building request",
                                fmt.Sprintf("Unable to parse security rule properties: %s", err),
                        )
                        return
                }</span>
                // Ensure Target is set correctly after unmarshal
                <span class="cov0" title="0">properties.Target = target
                // Explicitly clear Port field in struct (double safety)
                properties.Port = ""</span>
        } else<span class="cov0" title="0"> {
                // Normal case with Port field
                properties = sdktypes.SecurityRulePropertiesRequest{
                        Direction: sdktypes.RuleDirection(direction),
                        Protocol:  protocol,
                        Port:      port,
                        Target:    target,
                }
        }</span>

        <span class="cov0" title="0">tflog.Debug(ctx, "Properties built", map[string]interface{}{
                "direction":    properties.Direction,
                "protocol":     properties.Protocol,
                "port":         properties.Port,
                "portEmpty":    properties.Port == "",
                "hasTarget":    properties.Target != nil,
                "originalPort": port,
        })

        // Verify properties JSON doesn't include port when it should be omitted
        propsJSON, _ := json.Marshal(properties)
        if port == "" &amp;&amp; strings.Contains(string(propsJSON), `"port"`) </span><span class="cov0" title="0">{
                tflog.Error(ctx, "Port field still present in properties JSON after omitting!", map[string]interface{}{
                        "propertiesJSON": string(propsJSON),
                })
        }</span>

        // Build the create request
        // Match CLI behavior exactly - only include tags if they're actually provided
        // CLI doesn't include tags in JSON if not provided (SDK omits empty slices with omitempty)
        <span class="cov0" title="0">metadataRequest := sdktypes.ResourceMetadataRequest{
                Name: data.Name.ValueString(),
        }
        // Only set Tags if we have actual tags (not empty slice)
        // This ensures SDK omits tags field in JSON when empty (matches CLI behavior)
        if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                metadataRequest.Tags = tags
        }</span>

        <span class="cov0" title="0">createRequest := sdktypes.SecurityRuleRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: metadataRequest,
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: properties,
        }

        // Debug: Log the actual JSON that will be sent
        requestJSON, _ := json.MarshalIndent(createRequest, "", "  ")
        requestJSONStr := string(requestJSON)

        // Verify Port field is not present in JSON when it should be omitted
        // CRITICAL: If port should be omitted but is still in JSON, rebuild request without it
        if port == "" || strings.EqualFold(protocol, "Any") || strings.EqualFold(protocol, "ICMP") </span><span class="cov0" title="0">{
                if strings.Contains(requestJSONStr, `"port"`) </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "CRITICAL: Port field found in final JSON when it should be omitted! Rebuilding request...", map[string]interface{}{
                                "json":           requestJSONStr,
                                "propertiesPort": properties.Port,
                                "port":           port,
                                "protocol":       protocol,
                        })
                        // Rebuild the entire request using JSON manipulation to ensure Port is omitted
                        requestMap := map[string]interface{}{
                                "metadata": map[string]interface{}{
                                        "name": data.Name.ValueString(),
                                        "location": map[string]interface{}{
                                                "value": data.Location.ValueString(),
                                        },
                                },
                                "properties": map[string]interface{}{
                                        "direction": string(sdktypes.RuleDirection(direction)),
                                        "protocol":  protocol,
                                        "target": map[string]interface{}{
                                                "kind":  string(sdktypes.EndpointTypeDto(targetKind)),
                                                "value": targetValue,
                                        },
                                },
                        }
                        // Only add tags if they exist
                        if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                                if metadata, ok := requestMap["metadata"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        metadata["tags"] = tags
                                }</span>
                        }
                        // Rebuild request from JSON to ensure Port is omitted
                        <span class="cov0" title="0">rebuildJSON, err := json.Marshal(requestMap)
                        if err == nil </span><span class="cov0" title="0">{
                                if err := json.Unmarshal(rebuildJSON, &amp;createRequest); err == nil </span><span class="cov0" title="0">{
                                        requestJSON, _ = json.MarshalIndent(createRequest, "", "  ")
                                        requestJSONStr = string(requestJSON)
                                        tflog.Info(ctx, "Rebuilt request without Port field", map[string]interface{}{
                                                "newJSON": requestJSONStr,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        tflog.Debug(ctx, "Port field correctly omitted from final JSON")
                }</span>
        }

        <span class="cov0" title="0">tflog.Info(ctx, "Creating security rule", map[string]interface{}{
                "name":           data.Name.ValueString(),
                "direction":      direction,
                "protocol":       protocol,
                "port":           port,
                "targetKind":     targetKind,
                "targetValue":    targetValue,
                "portOmitted":    port == "",
                "propertiesPort": properties.Port,
        })

        // Create the security rule using the SDK
        response, err := r.client.Client.FromNetwork().SecurityGroupRules().Create(ctx, projectID, vpcID, securityGroupID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, "SDK error creating security rule", map[string]interface{}{
                        "error": err.Error(),
                })
                resp.Diagnostics.AddError(
                        "Error creating security rule",
                        fmt.Sprintf("Unable to create security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create security rule"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                // Log detailed error information including full response
                <span class="cov0" title="0">tflog.Error(ctx, "API error creating security rule", map[string]interface{}{
                        "statusCode":  response.StatusCode,
                        "title":       response.Error.Title,
                        "detail":      response.Error.Detail,
                        "requestJSON": string(requestJSON),
                        "fullError":   fmt.Sprintf("%+v", response.Error),
                })
                // Include request JSON in error message for debugging
                errorMsg = fmt.Sprintf("%s\n\nRequest JSON:\n%s", errorMsg, string(requestJSON))
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Security rule created but no data returned from API",
                )
                return
        }</span>

        // Wait for Security Rule to be active before returning
        // This ensures Terraform doesn't proceed to create dependent resources until Security Rule is ready
        <span class="cov0" title="0">ruleID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().SecurityGroupRules().Get(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Security Rule to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "SecurityRule", ruleID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Security Rule Not Active",
                        fmt.Sprintf("Security rule was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the Security Rule to get the latest state including tags
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().SecurityGroupRules().Get(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                rule := getResp.Data
                // Update tags from re-read response
                if len(rule.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(rule.Metadata.Tags))
                        for i, tag := range rule.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        data.Tags = types.ListNull(types.StringType)
                }</span>
        }

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Security Rule resource", map[string]interface{}{
                "securityrule_id":   data.Id.ValueString(),
                "securityrule_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityRuleResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SecurityRuleResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        securityGroupID := data.SecurityGroupId.ValueString()
        ruleID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || securityGroupID == "" || ruleID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, Security Group ID, and Rule ID are required to read the security rule",
                )
                return
        }</span>

        // Get security rule details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().SecurityGroupRules().Get(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading security rule",
                        fmt.Sprintf("Unable to read security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read security rule"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                rule := response.Data

                if rule.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*rule.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if rule.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*rule.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if rule.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*rule.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if rule.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(rule.Metadata.LocationResponse.Value)
                }</span>

                // Store protocol in user-friendly format (uppercase) to match typical user input
                // API returns "Any" but users typically write "ANY", so store in uppercase format
                // This prevents false positives when comparing state with config
                <span class="cov0" title="0">protocolFromAPI := rule.Properties.Protocol
                protocolForState := strings.ToUpper(protocolFromAPI) // Store as "ANY" instead of "Any"

                // Update properties from response
                propertiesMap := map[string]attr.Value{
                        "direction": types.StringValue(string(rule.Properties.Direction)),
                        "protocol":  types.StringValue(protocolForState),
                        "port":      types.StringValue(rule.Properties.Port),
                }

                // Update target
                if rule.Properties.Target != nil </span><span class="cov0" title="0">{
                        targetMap := map[string]attr.Value{
                                "kind":  types.StringValue(string(rule.Properties.Target.Kind)),
                                "value": types.StringValue(rule.Properties.Target.Value),
                        }
                        targetObj, diags := types.ObjectValue(map[string]attr.Type{
                                "kind":  types.StringType,
                                "value": types.StringType,
                        }, targetMap)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                propertiesMap["target"] = targetObj
                        }</span>
                }

                <span class="cov0" title="0">propertiesObj, diags := types.ObjectValue(map[string]attr.Type{
                        "direction": types.StringType,
                        "protocol":  types.StringType,
                        "port":      types.StringType,
                        "target": types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "kind":  types.StringType,
                                        "value": types.StringType,
                                },
                        },
                }, propertiesMap)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Properties = propertiesObj
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(rule.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(rule.Metadata.Tags))
                        for i, tag := range rule.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        // API has no tags - set to null
                        data.Tags = types.ListNull(types.StringType)
                }</span>

        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityRuleResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SecurityRuleResourceModel
        var state SecurityRuleResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Use IDs from state (they are immutable)
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        securityGroupID := state.SecurityGroupId.ValueString()
        ruleID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || securityGroupID == "" || ruleID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, Security Group ID, and Rule ID are required to update the security rule",
                )
                return
        }</span>

        // Get current security rule details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().SecurityGroupRules().Get(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current security rule",
                        fmt.Sprintf("Unable to get current security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Security Rule Not Found",
                        "Security rule not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if security rule is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update Security Rule",
                        "Cannot update security rule while it is in 'InCreation' state. Please wait until the security rule is fully created.",
                )
                return
        }</span>

        // Check if properties have changed - if so, security rule must be recreated
        // Extract properties from plan using the same method as Create
        <span class="cov0" title="0">var planDirection, planProtocol, planPort, planTargetKind, planTargetValue string
        if !data.Properties.IsNull() &amp;&amp; !data.Properties.IsUnknown() </span><span class="cov0" title="0">{
                propertiesObj, diags := data.Properties.ToObjectValue(ctx)
                if !diags.HasError() </span><span class="cov0" title="0">{
                        propertiesAttrs := propertiesObj.Attributes()
                        if dir, ok := propertiesAttrs["direction"]; ok &amp;&amp; dir != nil </span><span class="cov0" title="0">{
                                if dirStr, ok := dir.(types.String); ok </span><span class="cov0" title="0">{
                                        planDirection = dirStr.ValueString()
                                }</span>
                        }
                        <span class="cov0" title="0">if prot, ok := propertiesAttrs["protocol"]; ok &amp;&amp; prot != nil </span><span class="cov0" title="0">{
                                if protStr, ok := prot.(types.String); ok </span><span class="cov0" title="0">{
                                        // Keep protocol in uppercase format (matching state format)
                                        // Will be normalized to API format ("Any") when sending to API
                                        planProtocol = strings.ToUpper(protStr.ValueString())
                                }</span>
                        }
                        <span class="cov0" title="0">if portAttr, ok := propertiesAttrs["port"]; ok &amp;&amp; portAttr != nil </span><span class="cov0" title="0">{
                                if portStr, ok := portAttr.(types.String); ok &amp;&amp; !portStr.IsNull() </span><span class="cov0" title="0">{
                                        planPort = portStr.ValueString()
                                }</span>
                        }

                        // Adapter: If protocol is ANY or ICMP, port must not be set (API requirement)
                        // planProtocol is now in uppercase format
                        <span class="cov0" title="0">if planProtocol == "ANY" || planProtocol == "ICMP" </span><span class="cov0" title="0">{
                                planPort = ""
                        }</span>

                        <span class="cov0" title="0">if targetAttr, ok := propertiesAttrs["target"]; ok &amp;&amp; targetAttr != nil </span><span class="cov0" title="0">{
                                if targetObj, ok := targetAttr.(types.Object); ok </span><span class="cov0" title="0">{
                                        targetObjValue, targetDiags := targetObj.ToObjectValue(ctx)
                                        if !targetDiags.HasError() </span><span class="cov0" title="0">{
                                                targetAttrs := targetObjValue.Attributes()
                                                if kind, ok := targetAttrs["kind"]; ok &amp;&amp; kind != nil </span><span class="cov0" title="0">{
                                                        if kindStr, ok := kind.(types.String); ok </span><span class="cov0" title="0">{
                                                                planTargetKind = normalizeTargetKind(kindStr.ValueString())
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">if value, ok := targetAttrs["value"]; ok &amp;&amp; value != nil </span><span class="cov0" title="0">{
                                                        if valueStr, ok := value.(types.String); ok </span><span class="cov0" title="0">{
                                                                planTargetValue = valueStr.ValueString()
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Compare with current properties
        // Normalize both current and plan protocol values to uppercase before comparison
        // State stores protocol in uppercase (e.g., "ANY"), plan is also normalized to uppercase by plan modifier
        <span class="cov0" title="0">currentProtocolNormalized := strings.ToUpper(current.Properties.Protocol)
        planProtocolNormalized := strings.ToUpper(planProtocol)

        var propertiesChanged bool
        if planDirection != "" &amp;&amp; string(current.Properties.Direction) != planDirection </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>
        <span class="cov0" title="0">if planProtocol != "" &amp;&amp; currentProtocolNormalized != planProtocolNormalized </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>
        <span class="cov0" title="0">currentPort := current.Properties.Port
        if planPort != "" &amp;&amp; currentPort != planPort </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>
        <span class="cov0" title="0">if planTargetKind != "" &amp;&amp; string(current.Properties.Target.Kind) != planTargetKind </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>
        <span class="cov0" title="0">if planTargetValue != "" &amp;&amp; current.Properties.Target.Value != planTargetValue </span><span class="cov0" title="0">{
                propertiesChanged = true
        }</span>

        <span class="cov0" title="0">if propertiesChanged </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update Security Rule Properties",
                        "Security rule properties (direction, protocol, port, target) cannot be updated. To change properties, delete and recreate the security rule.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                // Try to get from VPC
                vpcResp, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
                if err == nil &amp;&amp; vpcResp != nil &amp;&amp; !vpcResp.IsError() &amp;&amp; vpcResp.Data != nil </span><span class="cov0" title="0">{
                        if vpcResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                                regionValue = vpcResp.Data.Metadata.LocationResponse.Value
                        }</span>
                }
        }
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for security rule",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated, properties must remain unchanged
        // Note: Properties must be included in the request but will use current values (they cannot be changed)

        // Build properties conditionally - omit Port field if it's empty (for ANY/ICMP protocols)
        <span class="cov0" title="0">var updateProperties sdktypes.SecurityRulePropertiesRequest
        if current.Properties.Port == "" </span><span class="cov0" title="0">{
                // Build without Port field by using JSON manipulation
                propertiesMap := map[string]interface{}{
                        "direction": current.Properties.Direction,
                        "protocol":  current.Properties.Protocol,
                        "target": map[string]interface{}{
                                "kind":  current.Properties.Target.Kind,
                                "value": current.Properties.Target.Value,
                        },
                }
                // Marshal to JSON and back to ensure Port field is not present
                jsonData, _ := json.Marshal(propertiesMap)
                if err := json.Unmarshal(jsonData, &amp;updateProperties); err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError("Failed to unmarshal properties", err.Error())
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Normal case with Port field
                updateProperties = sdktypes.SecurityRulePropertiesRequest{
                        Direction: current.Properties.Direction,
                        Protocol:  current.Properties.Protocol,
                        Port:      current.Properties.Port,
                        Target:    current.Properties.Target,
                }
        }</span>

        <span class="cov0" title="0">updateRequest := sdktypes.SecurityRuleRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: updateProperties,
        }

        // Log the update request for debugging
        tflog.Debug(ctx, "Updating security rule", map[string]interface{}{
                "rule_id":    ruleID,
                "name":       data.Name.ValueString(),
                "tags":       tags,
                "properties": fmt.Sprintf("Direction=%s, Protocol=%s, Port=%s", current.Properties.Direction, current.Properties.Protocol, current.Properties.Port),
        })

        // Update the security rule using the SDK
        response, err := r.client.Client.FromNetwork().SecurityGroupRules().Update(ctx, projectID, vpcID, securityGroupID, ruleID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                tflog.Error(ctx, fmt.Sprintf("Error calling Update API: %v", err))
                resp.Diagnostics.AddError(
                        "Error updating security rule",
                        fmt.Sprintf("Unable to update security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update security rule"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                // Include status code if available
                <span class="cov0" title="0">if response.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s (HTTP %d)", errorMsg, response.StatusCode)
                }</span>

                // Log full error response JSON only on errors for debugging
                <span class="cov0" title="0">if errorJSON, jsonErr := json.MarshalIndent(response.Error, "", "  "); jsonErr == nil </span><span class="cov0" title="0">{
                        tflog.Debug(ctx, "Full API error response JSON", map[string]interface{}{
                                "error_json": string(errorJSON),
                        })
                }</span>

                <span class="cov0" title="0">tflog.Error(ctx, "API error updating security rule", map[string]interface{}{
                        "error": fmt.Sprintf("%+v", response.Error),
                })
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Verify the update was successful
        <span class="cov0" title="0">if response == nil || response.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Security rule updated but no data returned from API",
                )
                return
        }</span>

        // Update the state with the response data
        // At this point, we know response != nil &amp;&amp; response.Data != nil from the check above
        <span class="cov0" title="0">updated := response.Data
        if updated.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*updated.Metadata.ID)
        }</span>
        <span class="cov0" title="0">if updated.Metadata.Name != nil </span><span class="cov0" title="0">{
                data.Name = types.StringValue(*updated.Metadata.Name)
        }</span>
        <span class="cov0" title="0">if updated.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                data.Location = types.StringValue(updated.Metadata.LocationResponse.Value)
        }</span>

        // Update tags from response
        <span class="cov0" title="0">if len(updated.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagValues := make([]types.String, len(updated.Metadata.Tags))
                for i, tag := range updated.Metadata.Tags </span><span class="cov0" title="0">{
                        tagValues[i] = types.StringValue(tag)
                }</span>
                <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Tags = tagsList
                }</span>
        } else<span class="cov0" title="0"> {
                data.Tags = types.ListNull(types.StringType)
        }</span>

        // Properties remain unchanged - they are immutable
        // Keep the existing state values to ensure Terraform state matches what the user configured

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId
        data.SecurityGroupId = state.SecurityGroupId

        // Update ID from response (should match state)
        // At this point, we know response != nil &amp;&amp; response.Data != nil from the check above
        if updated.Metadata.ID != nil </span><span class="cov0" title="0">{
                data.Id = types.StringValue(*updated.Metadata.ID)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SecurityRuleResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SecurityRuleResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        securityGroupID := data.SecurityGroupId.ValueString()
        ruleID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || securityGroupID == "" || ruleID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, Security Group ID, and Rule ID are required to delete the security rule",
                )
                return
        }</span>

        // Delete the security rule using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().SecurityGroupRules().Delete(ctx, projectID, vpcID, securityGroupID, ruleID, nil)
                }</span>,
                ExtractSDKError,
                "SecurityRule",
                ruleID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting security rule",
                        fmt.Sprintf("Unable to delete security rule: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Security Rule resource", map[string]interface{}{
                "securityrule_id": ruleID,
        })</span>
}

func (r *SecurityRuleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;SnapshotDataSource{}

func NewSnapshotDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;SnapshotDataSource{}
}</span>

type SnapshotDataSource struct {
        client *ArubaCloudClient
}

type SnapshotDataSourceModel struct {
        Id            types.String `tfsdk:"id"`
        Name          types.String `tfsdk:"name"`
        ProjectId     types.String `tfsdk:"project_id"`
        Location      types.String `tfsdk:"location"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        VolumeId      types.String `tfsdk:"volume_id"`
}

func (d *SnapshotDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_snapshot"
}</span>

func (d *SnapshotDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Snapshot data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Snapshot identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Snapshot name",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Snapshot belongs to",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Snapshot location",
                                Computed:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (only 'Hour' allowed)",
                                Computed:            true,
                        },
                        "volume_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the volume this snapshot is for",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *SnapshotDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *SnapshotDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data SnapshotDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-snapshot")
        data.ProjectId = types.StringValue("example-project-id")
        data.Location = types.StringValue("it-dc1")
        data.BillingPeriod = types.StringValue("Hour")
        data.VolumeId = types.StringValue("example-volume-id")
        tflog.Trace(ctx, "read a Snapshot data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;SnapshotResource{}
var _ resource.ResourceWithImportState = &amp;SnapshotResource{}

func NewSnapshotResource() resource.Resource <span class="cov8" title="1">{
        return &amp;SnapshotResource{}
}</span>

type SnapshotResourceModel struct {
        Id            types.String `tfsdk:"id"`
        Uri           types.String `tfsdk:"uri"`
        Name          types.String `tfsdk:"name"`
        ProjectId     types.String `tfsdk:"project_id"`
        Location      types.String `tfsdk:"location"`
        BillingPeriod types.String `tfsdk:"billing_period"`
        VolumeUri     types.String `tfsdk:"volume_uri"`
        Tags          types.List   `tfsdk:"tags"`
}

type SnapshotResource struct {
        client *ArubaCloudClient
}

func (r *SnapshotResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_snapshot"
}</span>

func (r *SnapshotResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Snapshot resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Snapshot identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Snapshot URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Snapshot name",
                                Required:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this Snapshot belongs to",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Snapshot location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (only 'Hour' allowed)",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "volume_uri": schema.StringAttribute{
                                MarkdownDescription: "URI of the volume this snapshot is for. Should be the volume URI (e.g., `/projects/{project_id}/providers/Aruba.Storage/volumes/{volume_id}`). You can reference the `uri` attribute from an `arubacloud_blockstorage` resource.",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the snapshot",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *SnapshotResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *SnapshotResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SnapshotResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a snapshot",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Get volume URI from the plan
        <span class="cov0" title="0">volumeURI := data.VolumeUri.ValueString()
        if volumeURI == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Volume URI",
                        "Volume URI is required to create a snapshot",
                )
                return
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.SnapshotRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.SnapshotPropertiesRequest{
                        Volume: sdktypes.ReferenceResource{
                                URI: volumeURI,
                        },
                },
        }

        // Create the snapshot using the SDK
        response, err := r.client.Client.FromStorage().Snapshots().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating snapshot",
                        fmt.Sprintf("Unable to create snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create snapshot", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span> else<span class="cov0" title="0"> {
                        resp.Diagnostics.AddError(
                                "Invalid API Response",
                                "Snapshot created but ID not returned from API",
                        )
                        return
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Snapshot created but no data returned from API",
                )
                return
        }</span>

        // Wait for Snapshot to be active before returning (Snapshot references Volume)
        // This ensures Terraform doesn't proceed to create dependent resources until Snapshot is ready
        <span class="cov0" title="0">snapshotID := data.Id.ValueString()
        if snapshotID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Snapshot ID",
                        "Snapshot ID is required but was not set",
                )
                return
        }</span>
        <span class="cov0" title="0">checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromStorage().Snapshots().Get(ctx, projectID, snapshotID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Snapshot to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Snapshot", snapshotID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Snapshot Not Active",
                        fmt.Sprintf("Snapshot was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Read the Snapshot again to ensure ID and other fields are properly set from metadata
        <span class="cov0" title="0">getResp, err := r.client.Client.FromStorage().Snapshots().Get(ctx, projectID, snapshotID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(getResp.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(getResp.Data.Metadata.Tags))
                        for i, tag := range getResp.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Snapshot after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Snapshot resource", map[string]interface{}{
                "snapshot_id":   data.Id.ValueString(),
                "snapshot_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SnapshotResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SnapshotResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        snapshotID := data.Id.ValueString()

        // If ID is unknown or null, check if this is a new resource (no state) or existing resource (state exists but ID missing)
        // For new resources (during plan), we can return early
        // For existing resources, we need the ID to read - if it's missing, that's an error
        if data.Id.IsUnknown() || data.Id.IsNull() || snapshotID == "" </span><span class="cov0" title="0">{
                // Check if we have any other state data that indicates this is an existing resource
                // If name is set in state, this is likely an existing resource with missing ID (error case)
                if !data.Name.IsUnknown() &amp;&amp; !data.Name.IsNull() &amp;&amp; data.Name.ValueString() != "" </span><span class="cov0" title="0">{
                        tflog.Error(ctx, "Snapshot exists in state but ID is missing - this indicates a state corruption issue")
                        resp.Diagnostics.AddError(
                                "Missing Snapshot ID",
                                "Snapshot ID is required to read the snapshot. The resource exists in state but the ID is missing. This may indicate a state corruption issue. Try running 'terraform refresh' or 'terraform import arubacloud_snapshot.test &lt;snapshot_id&gt;'.",
                        )
                        return
                }</span>
                // Otherwise, this is likely a new resource during plan - return early
                <span class="cov0" title="0">tflog.Info(ctx, "Snapshot ID is unknown or null during read, skipping API call (likely new resource).")
                return</span> // Do not error, as this is expected during plan for new resources
        }

        <span class="cov0" title="0">if projectID == "" </span><span class="cov0" title="0">{
                // Check if ProjectID is unknown (new resource) vs missing (error)
                if data.ProjectId.IsUnknown() || data.ProjectId.IsNull() </span><span class="cov0" title="0">{
                        tflog.Info(ctx, "Snapshot Project ID is unknown or null during read, skipping API call (likely new resource).")
                        return // Do not error, as this is expected during plan for new resources
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID is required to read the snapshot",
                )
                return</span>
        }

        // Get snapshot details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromStorage().Snapshots().Get(ctx, projectID, snapshotID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading snapshot",
                        fmt.Sprintf("Unable to read snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id":  projectID,
                        "snapshot_id": snapshotID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read snapshot", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                snapshot := response.Data

                // Preserve immutable fields from state (they're not returned by API)
                projectIdFromState := data.ProjectId
                billingPeriodFromState := data.BillingPeriod
                volumeUriFromState := data.VolumeUri
                tagsFromState := data.Tags
                locationFromState := data.Location

                if snapshot.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*snapshot.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if snapshot.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*snapshot.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if snapshot.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*snapshot.Metadata.Name)
                }</span>
                // Location is immutable - always preserve from state
                // This prevents false changes when the referenced block storage is updated
                <span class="cov0" title="0">if !locationFromState.IsUnknown() &amp;&amp; !locationFromState.IsNull() </span><span class="cov0" title="0">{
                        data.Location = locationFromState
                }</span> else<span class="cov0" title="0"> {
                        // Only use API value if state doesn't have it (new resources during plan)
                        if snapshot.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                                data.Location = types.StringValue(snapshot.Metadata.LocationResponse.Value)
                        }</span>
                }

                // Handle volume_uri: Always preserve from state since it's immutable
                // The volume_uri never changes after snapshot creation, so we should always use the value from state
                // This prevents false changes when the referenced block storage is updated
                <span class="cov0" title="0">if !volumeUriFromState.IsUnknown() &amp;&amp; !volumeUriFromState.IsNull() </span><span class="cov0" title="0">{
                        // Always preserve volume_uri from state (it's immutable)
                        data.VolumeUri = volumeUriFromState
                }</span> else<span class="cov0" title="0"> {
                        // Only use API value if state doesn't have it (shouldn't happen for existing resources)
                        if snapshot.Properties.Volume.URI != nil &amp;&amp; *snapshot.Properties.Volume.URI != "" </span><span class="cov0" title="0">{
                                data.VolumeUri = types.StringValue(*snapshot.Properties.Volume.URI)
                        }</span>
                }

                // Update tags from response
                // If tags are null/unknown in state, preserve null (user didn't specify tags)
                // If tags exist in state or API has tags, update from API
                <span class="cov0" title="0">if len(snapshot.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(snapshot.Metadata.Tags))
                        for i, tag := range snapshot.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        // API has no tags - preserve from state if null/unknown, otherwise set to empty list
                        if tagsFromState.IsNull() || tagsFromState.IsUnknown() </span><span class="cov0" title="0">{
                                data.Tags = tagsFromState // Preserve null/unknown from state
                        }</span> else<span class="cov0" title="0"> {
                                // State has tags (even if empty), update to empty list to match API
                                emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        data.Tags = emptyList
                                }</span>
                        }
                }

                // Restore immutable fields from state (they're not returned by API)
                <span class="cov0" title="0">data.ProjectId = projectIdFromState
                data.BillingPeriod = billingPeriodFromState</span>
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SnapshotResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SnapshotResourceModel
        var state SnapshotResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        snapshotID := state.Id.ValueString()

        if projectID == "" || snapshotID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Snapshot ID are required to update the snapshot",
                )
                return
        }</span>

        // Get current snapshot details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromStorage().Snapshots().Get(ctx, projectID, snapshotID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current snapshot",
                        fmt.Sprintf("Unable to get current snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Snapshot Not Found",
                        "Snapshot not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for snapshot",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Preserve existing tags if not provided
                tags = current.Metadata.Tags
        }</span>

        // Build the update request
        <span class="cov0" title="0">updateRequest := sdktypes.SnapshotRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.SnapshotPropertiesRequest{
                        // Volume cannot be updated - preserve from create request or state
                        // Note: VolumeInfo may need to be converted to ReferenceResource
                        // For now, Volume is read-only in updates
                },
        }

        // Update the snapshot using the SDK
        response, err := r.client.Client.FromStorage().Snapshots().Update(ctx, projectID, snapshotID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating snapshot",
                        fmt.Sprintf("Unable to update snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update snapshot", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VolumeUri = state.VolumeUri // Preserve volume_uri from state (it's immutable)

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = state.Uri
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(response.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(response.Data.Metadata.Tags))
                        for i, tag := range response.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI and tags from state
                data.Uri = state.Uri
                data.Tags = state.Tags
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SnapshotResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SnapshotResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        snapshotID := data.Id.ValueString()

        if projectID == "" || snapshotID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Snapshot ID are required to delete the snapshot",
                )
                return
        }</span>

        // Delete the snapshot using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromStorage().Snapshots().Delete(ctx, projectID, snapshotID, nil)
                }</span>,
                ExtractSDKError,
                "Snapshot",
                snapshotID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting snapshot",
                        fmt.Sprintf("Unable to delete snapshot: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Snapshot resource", map[string]interface{}{
                "snapshot_id": snapshotID,
        })</span>
}

func (r *SnapshotResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;SubnetDataSource{}

func NewSubnetDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;SubnetDataSource{}
}</span>

type SubnetDataSource struct {
        client *ArubaCloudClient
}

type SubnetDataSourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
        Type      types.String `tfsdk:"type"`
        // Network fields (flattened)
        Address types.String `tfsdk:"address"`
        // DHCP fields (flattened)
        DhcpEnabled    types.Bool   `tfsdk:"dhcp_enabled"`
        DhcpRangeStart types.String `tfsdk:"dhcp_range_start"`
        DhcpRangeCount types.Int64  `tfsdk:"dhcp_range_count"`
        DhcpRoutes     types.List   `tfsdk:"dhcp_routes"`
        Dns            types.List   `tfsdk:"dns"`
}

type RouteDataSourceModel struct {
        Address types.String `tfsdk:"address"`
        Gateway types.String `tfsdk:"gateway"`
}

func (d *SubnetDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_subnet"
}</span>

func (d *SubnetDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Subnet data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Subnet identifier",
                                Required:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Subnet URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Subnet name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Subnet location",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the subnet",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this subnet belongs to",
                                Computed:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this subnet belongs to",
                                Computed:            true,
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Subnet type (Basic or Advanced)",
                                Computed:            true,
                        },
                        "address": schema.StringAttribute{
                                MarkdownDescription: "Address of the network in CIDR notation (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)",
                                Computed:            true,
                        },
                        "dhcp_enabled": schema.BoolAttribute{
                                MarkdownDescription: "Enable DHCP",
                                Computed:            true,
                        },
                        "dhcp_range_start": schema.StringAttribute{
                                MarkdownDescription: "Starting IP address for DHCP range",
                                Computed:            true,
                        },
                        "dhcp_range_count": schema.Int64Attribute{
                                MarkdownDescription: "Number of available IP addresses in DHCP range",
                                Computed:            true,
                        },
                        "dhcp_routes": schema.ListNestedAttribute{
                                MarkdownDescription: "DHCP routes configuration",
                                Computed:            true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "address": schema.StringAttribute{
                                                        MarkdownDescription: "Destination network address in CIDR notation",
                                                        Computed:            true,
                                                },
                                                "gateway": schema.StringAttribute{
                                                        MarkdownDescription: "Gateway IP address",
                                                        Computed:            true,
                                                },
                                        },
                                },
                        },
                        "dns": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of DNS IP addresses",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *SubnetDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *SubnetDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data SubnetDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Uri = types.StringValue("/v2/subnets/subnet-68398923fb2cb026400d4d32")
        data.Name = types.StringValue("example-subnet")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.ProjectId = types.StringValue("68398923fb2cb026400d4d31")
        data.VpcId = types.StringValue("vpc-68398923fb2cb026400d4d32")
        data.Type = types.StringValue("Advanced")
        data.Address = types.StringValue("10.0.1.0/24")
        data.DhcpEnabled = types.BoolValue(true)
        data.DhcpRangeStart = types.StringValue("10.0.1.10")
        data.DhcpRangeCount = types.Int64Value(200)

        // Create routes list
        routeType := types.ObjectType{
                AttrTypes: map[string]attr.Type{
                        "address": types.StringType,
                        "gateway": types.StringType,
                },
        }
        route1, _ := types.ObjectValue(routeType.AttrTypes, map[string]attr.Value{
                "address": types.StringValue("0.0.0.0/0"),
                "gateway": types.StringValue("10.0.1.1"),
        })
        route2, _ := types.ObjectValue(routeType.AttrTypes, map[string]attr.Value{
                "address": types.StringValue("192.168.0.0/16"),
                "gateway": types.StringValue("10.0.1.254"),
        })
        data.DhcpRoutes = types.ListValueMust(routeType, []attr.Value{route1, route2})

        data.Dns = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("8.8.8.8"),
                types.StringValue("8.8.4.4"),
        })
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("network"),
                types.StringValue("private"),
        })

        tflog.Trace(ctx, "read a Subnet data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;SubnetResource{}
var _ resource.ResourceWithImportState = &amp;SubnetResource{}

func NewSubnetResource() resource.Resource <span class="cov8" title="1">{
        return &amp;SubnetResource{}
}</span>

type SubnetResource struct {
        client *ArubaCloudClient
}

type SubnetResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
        Type      types.String `tfsdk:"type"`
        Network   types.Object `tfsdk:"network"`
}

type NetworkModel struct {
        Address types.String `tfsdk:"address"`
        Dhcp    types.Object `tfsdk:"dhcp"`
}

type DhcpModel struct {
        Enabled types.Bool   `tfsdk:"enabled"`
        Range   types.Object `tfsdk:"range"`
        Routes  types.List   `tfsdk:"routes"`
        Dns     types.List   `tfsdk:"dns"`
}

type DhcpRangeModel struct {
        Start types.String `tfsdk:"start"`
        Count types.Int64  `tfsdk:"count"`
}

type RouteModel struct {
        Address types.String `tfsdk:"address"`
        Gateway types.String `tfsdk:"gateway"`
}

func (r *SubnetResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_subnet"
}</span>

func (r *SubnetResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Subnet resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "Subnet identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "Subnet URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Subnet name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "Subnet location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the subnet",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this subnet belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this subnet belongs to",
                                Required:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "type": schema.StringAttribute{
                                MarkdownDescription: "Subnet type (Basic or Advanced)",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "network": schema.SingleNestedAttribute{
                                Attributes: map[string]schema.Attribute{
                                        "address": schema.StringAttribute{
                                                MarkdownDescription: "Address of the network in CIDR notation (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)",
                                                Optional:            true,
                                        },
                                        "dhcp": schema.SingleNestedAttribute{
                                                Attributes: map[string]schema.Attribute{
                                                        "enabled": schema.BoolAttribute{
                                                                MarkdownDescription: "Enable DHCP",
                                                                Optional:            true,
                                                        },
                                                        "range": schema.SingleNestedAttribute{
                                                                Attributes: map[string]schema.Attribute{
                                                                        "start": schema.StringAttribute{
                                                                                MarkdownDescription: "Starting IP address",
                                                                                Optional:            true,
                                                                        },
                                                                        "count": schema.Int64Attribute{
                                                                                MarkdownDescription: "Number of available IP addresses",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                                Optional: true,
                                                        },
                                                        "routes": schema.ListNestedAttribute{
                                                                NestedObject: schema.NestedAttributeObject{
                                                                        Attributes: map[string]schema.Attribute{
                                                                                "address": schema.StringAttribute{
                                                                                        MarkdownDescription: "Destination network address in CIDR notation (e.g., 0.0.0.0/0)",
                                                                                        Optional:            true,
                                                                                },
                                                                                "gateway": schema.StringAttribute{
                                                                                        MarkdownDescription: "Gateway IP address for the route",
                                                                                        Optional:            true,
                                                                                },
                                                                        },
                                                                },
                                                                MarkdownDescription: "DHCP routes configuration",
                                                                Optional:            true,
                                                        },
                                                        "dns": schema.ListAttribute{
                                                                ElementType:         types.StringType,
                                                                MarkdownDescription: "DNS server addresses",
                                                                Optional:            true,
                                                        },
                                                },
                                                Optional: true,
                                        },
                                },
                                Optional: true,
                        },
                },
        }
}</span>

func (r *SubnetResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *SubnetResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data SubnetResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to create a subnet",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">subnetType := data.Type.ValueString()

        // Validation: If type is Advanced, network block is mandatory
        if subnetType == "Advanced" </span><span class="cov0" title="0">{
                if data.Network.IsNull() || data.Network.IsUnknown() </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Missing Required Field",
                                "The 'network' block is required when subnet type is 'Advanced'",
                        )
                        return
                }</span>
        }

        // Extract network CIDR and DHCP if provided
        <span class="cov0" title="0">var network *sdktypes.SubnetNetwork
        var dhcp *sdktypes.SubnetDHCP
        if !data.Network.IsNull() &amp;&amp; !data.Network.IsUnknown() </span><span class="cov0" title="0">{
                networkObj, diags := data.Network.ToObjectValue(ctx)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        attrs := networkObj.Attributes()

                        // Extract network address
                        var addressValue string
                        if addressAttr, ok := attrs["address"]; ok &amp;&amp; addressAttr != nil </span><span class="cov0" title="0">{
                                if addressStr, ok := addressAttr.(types.String); ok &amp;&amp; !addressStr.IsNull() </span><span class="cov0" title="0">{
                                        addressValue = addressStr.ValueString()
                                        if addressValue != "" </span><span class="cov0" title="0">{
                                                network = &amp;sdktypes.SubnetNetwork{
                                                        Address: addressValue,
                                                }
                                        }</span>
                                }
                        }

                        // Validation: If type is Advanced, address is mandatory
                        <span class="cov0" title="0">if subnetType == "Advanced" &amp;&amp; addressValue == "" </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddError(
                                        "Missing Required Field",
                                        "The 'network.address' field is required when subnet type is 'Advanced'",
                                )
                                return
                        }</span>

                        // Extract DHCP configuration from network.dhcp
                        <span class="cov0" title="0">var dhcpEnabledSet bool
                        var dhcpRangeStart string
                        var dhcpRangeCount int

                        if dhcpAttr, ok := attrs["dhcp"]; ok &amp;&amp; dhcpAttr != nil </span><span class="cov0" title="0">{
                                if dhcpObj, ok := dhcpAttr.(types.Object); ok &amp;&amp; !dhcpObj.IsNull() </span><span class="cov0" title="0">{
                                        dhcpAttrs := dhcpObj.Attributes()
                                        dhcp = &amp;sdktypes.SubnetDHCP{}

                                        // Extract enabled
                                        if enabledAttr, ok := dhcpAttrs["enabled"]; ok &amp;&amp; enabledAttr != nil </span><span class="cov0" title="0">{
                                                if enabledBool, ok := enabledAttr.(types.Bool); ok &amp;&amp; !enabledBool.IsNull() </span><span class="cov0" title="0">{
                                                        dhcp.Enabled = enabledBool.ValueBool()
                                                        dhcpEnabledSet = true
                                                }</span>
                                        }

                                        // Extract range
                                        <span class="cov0" title="0">if rangeAttr, ok := dhcpAttrs["range"]; ok &amp;&amp; rangeAttr != nil </span><span class="cov0" title="0">{
                                                if rangeObj, ok := rangeAttr.(types.Object); ok &amp;&amp; !rangeObj.IsNull() </span><span class="cov0" title="0">{
                                                        rangeAttrs := rangeObj.Attributes()
                                                        dhcpRange := &amp;sdktypes.SubnetDHCPRange{}
                                                        if startAttr, ok := rangeAttrs["start"]; ok &amp;&amp; startAttr != nil </span><span class="cov0" title="0">{
                                                                if startStr, ok := startAttr.(types.String); ok &amp;&amp; !startStr.IsNull() </span><span class="cov0" title="0">{
                                                                        dhcpRange.Start = startStr.ValueString()
                                                                        dhcpRangeStart = dhcpRange.Start
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if countAttr, ok := rangeAttrs["count"]; ok &amp;&amp; countAttr != nil </span><span class="cov0" title="0">{
                                                                if countInt, ok := countAttr.(types.Int64); ok &amp;&amp; !countInt.IsNull() </span><span class="cov0" title="0">{
                                                                        dhcpRange.Count = int(countInt.ValueInt64())
                                                                        dhcpRangeCount = dhcpRange.Count
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dhcpRange.Start != "" || dhcpRange.Count &gt; 0 </span><span class="cov0" title="0">{
                                                                dhcp.Range = dhcpRange
                                                        }</span>
                                                }
                                        }

                                        // Extract routes
                                        <span class="cov0" title="0">if routesAttr, ok := dhcpAttrs["routes"]; ok &amp;&amp; routesAttr != nil </span><span class="cov0" title="0">{
                                                if routesList, ok := routesAttr.(types.List); ok &amp;&amp; !routesList.IsNull() </span><span class="cov0" title="0">{
                                                        var routesData []types.Object
                                                        diags := routesList.ElementsAs(ctx, &amp;routesData, false)
                                                        resp.Diagnostics.Append(diags...)
                                                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                                dhcpRoutes := make([]sdktypes.SubnetDHCPRoute, 0, len(routesData))
                                                                for _, routeObj := range routesData </span><span class="cov0" title="0">{
                                                                        routeAttrs := routeObj.Attributes()
                                                                        route := sdktypes.SubnetDHCPRoute{}
                                                                        if addrAttr, ok := routeAttrs["address"]; ok &amp;&amp; addrAttr != nil </span><span class="cov0" title="0">{
                                                                                if addrStr, ok := addrAttr.(types.String); ok &amp;&amp; !addrStr.IsNull() </span><span class="cov0" title="0">{
                                                                                        route.Address = addrStr.ValueString()
                                                                                }</span>
                                                                        }
                                                                        <span class="cov0" title="0">if gwAttr, ok := routeAttrs["gateway"]; ok &amp;&amp; gwAttr != nil </span><span class="cov0" title="0">{
                                                                                if gwStr, ok := gwAttr.(types.String); ok &amp;&amp; !gwStr.IsNull() </span><span class="cov0" title="0">{
                                                                                        route.Gateway = gwStr.ValueString()
                                                                                }</span>
                                                                        }
                                                                        <span class="cov0" title="0">if route.Address != "" || route.Gateway != "" </span><span class="cov0" title="0">{
                                                                                dhcpRoutes = append(dhcpRoutes, route)
                                                                        }</span>
                                                                }
                                                                <span class="cov0" title="0">if len(dhcpRoutes) &gt; 0 </span><span class="cov0" title="0">{
                                                                        dhcp.Routes = dhcpRoutes
                                                                }</span>
                                                        }
                                                }
                                        }

                                        // Extract DNS
                                        <span class="cov0" title="0">if dnsAttr, ok := dhcpAttrs["dns"]; ok &amp;&amp; dnsAttr != nil </span><span class="cov0" title="0">{
                                                if dnsList, ok := dnsAttr.(types.List); ok &amp;&amp; !dnsList.IsNull() </span><span class="cov0" title="0">{
                                                        var dnsServers []string
                                                        diags := dnsList.ElementsAs(ctx, &amp;dnsServers, false)
                                                        resp.Diagnostics.Append(diags...)
                                                        if !resp.Diagnostics.HasError() &amp;&amp; len(dnsServers) &gt; 0 </span><span class="cov0" title="0">{
                                                                dhcp.DNS = dnsServers
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // Validation: If type is Advanced, dhcp block with enabled, range.start and range.count are mandatory
                        <span class="cov0" title="0">if subnetType == "Advanced" </span><span class="cov0" title="0">{
                                if dhcp == nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Missing Required Field",
                                                "The 'network.dhcp' block is required when subnet type is 'Advanced'",
                                        )
                                        return
                                }</span>
                                <span class="cov0" title="0">if !dhcpEnabledSet </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Missing Required Field",
                                                "The 'network.dhcp.enabled' field is required when subnet type is 'Advanced'",
                                        )
                                        return
                                }</span>
                                <span class="cov0" title="0">if dhcp.Range == nil || dhcpRangeStart == "" || dhcpRangeCount == 0 </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                "Missing Required Fields",
                                                "The 'network.dhcp.range' block with 'start' and 'count' fields is required when subnet type is 'Advanced'",
                                        )
                                        return
                                }</span>
                        }
                }
        }

        // Determine SubnetType for SDK: Advanced if CIDR is provided, Basic otherwise
        <span class="cov0" title="0">sdkSubnetType := sdktypes.SubnetTypeBasic
        if network != nil &amp;&amp; network.Address != "" </span><span class="cov0" title="0">{
                sdkSubnetType = sdktypes.SubnetTypeAdvanced
        }</span> else<span class="cov0" title="0"> if data.Type.ValueString() == "Advanced" </span><span class="cov0" title="0">{
                sdkSubnetType = sdktypes.SubnetTypeAdvanced
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.SubnetRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.SubnetPropertiesRequest{
                        Type:    sdkSubnetType,
                        Network: network,
                        DHCP:    dhcp,
                },
        }

        // Create the subnet using the SDK
        response, err := r.client.Client.FromNetwork().Subnets().Create(ctx, projectID, vpcID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating subnet",
                        fmt.Sprintf("Unable to create subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create subnet", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "Subnet created but no data returned from API",
                )
                return
        }</span>

        // Wait for Subnet to be active before returning (Subnet is referenced by CloudServer)
        // This ensures Terraform doesn't proceed to create dependent resources until Subnet is ready
        <span class="cov0" title="0">subnetID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for Subnet to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "Subnet", subnetID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Subnet Not Active",
                        fmt.Sprintf("Subnet was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the Subnet to get the URI and ensure all fields are properly set
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(getResp.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(getResp.Data.Metadata.Tags))
                        for i, tag := range getResp.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh Subnet after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a Subnet resource", map[string]interface{}{
                "subnet_id":   data.Id.ValueString(),
                "subnet_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SubnetResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data SubnetResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        subnetID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || subnetID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Subnet ID are required to read the subnet",
                )
                return
        }</span>

        // Get subnet details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading subnet",
                        fmt.Sprintf("Unable to read subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "subnet_id":  subnetID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read subnet", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                subnet := response.Data

                if subnet.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*subnet.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if subnet.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*subnet.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if subnet.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*subnet.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if subnet.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(subnet.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">data.Type = types.StringValue(string(subnet.Properties.Type))
                subnetType := string(subnet.Properties.Type)

                // Update network and DHCP if available
                networkAttrs := make(map[string]attr.Value)
                networkAttrTypes := map[string]attr.Type{
                        "address": types.StringType,
                        "dhcp": types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "enabled": types.BoolType,
                                        "range": types.ObjectType{
                                                AttrTypes: map[string]attr.Type{
                                                        "start": types.StringType,
                                                        "count": types.Int64Type,
                                                },
                                        },
                                        "routes": types.ListType{
                                                ElemType: types.ObjectType{
                                                        AttrTypes: map[string]attr.Type{
                                                                "address": types.StringType,
                                                                "gateway": types.StringType,
                                                        },
                                                },
                                        },
                                        "dns": types.ListType{ElemType: types.StringType},
                                },
                        },
                }

                // Set network address
                // For Basic subnets, only set network if it was in the original state (to avoid drift)
                // For Advanced subnets, always set network if available from API
                networkWasInState := !data.Network.IsNull() &amp;&amp; !data.Network.IsUnknown()
                shouldSetNetwork := subnetType == "Advanced" || networkWasInState

                if shouldSetNetwork </span><span class="cov0" title="0">{
                        // Set network address
                        if subnet.Properties.Network != nil &amp;&amp; subnet.Properties.Network.Address != "" </span><span class="cov0" title="0">{
                                networkAttrs["address"] = types.StringValue(subnet.Properties.Network.Address)
                        }</span> else<span class="cov0" title="0"> {
                                networkAttrs["address"] = types.StringNull()
                        }</span>

                        // Set DHCP if available
                        <span class="cov0" title="0">if subnet.Properties.DHCP != nil </span><span class="cov0" title="0">{
                                dhcpAttrs := make(map[string]attr.Value)
                                dhcpAttrs["enabled"] = types.BoolValue(subnet.Properties.DHCP.Enabled)

                                // Handle DHCP range
                                if subnet.Properties.DHCP.Range != nil </span><span class="cov0" title="0">{
                                        rangeObj, diags := types.ObjectValue(map[string]attr.Type{
                                                "start": types.StringType,
                                                "count": types.Int64Type,
                                        }, map[string]attr.Value{
                                                "start": types.StringValue(subnet.Properties.DHCP.Range.Start),
                                                "count": types.Int64Value(int64(subnet.Properties.DHCP.Range.Count)),
                                        })
                                        resp.Diagnostics.Append(diags...)
                                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                dhcpAttrs["range"] = rangeObj
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        dhcpAttrs["range"] = types.ObjectNull(map[string]attr.Type{
                                                "start": types.StringType,
                                                "count": types.Int64Type,
                                        })
                                }</span>

                                // Handle DHCP routes
                                <span class="cov0" title="0">if len(subnet.Properties.DHCP.Routes) &gt; 0 </span><span class="cov0" title="0">{
                                        routeObjs := make([]attr.Value, 0, len(subnet.Properties.DHCP.Routes))
                                        for _, route := range subnet.Properties.DHCP.Routes </span><span class="cov0" title="0">{
                                                routeObj, diags := types.ObjectValue(map[string]attr.Type{
                                                        "address": types.StringType,
                                                        "gateway": types.StringType,
                                                }, map[string]attr.Value{
                                                        "address": types.StringValue(route.Address),
                                                        "gateway": types.StringValue(route.Gateway),
                                                })
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        routeObjs = append(routeObjs, routeObj)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">routesList, diags := types.ListValue(types.ObjectType{
                                                AttrTypes: map[string]attr.Type{
                                                        "address": types.StringType,
                                                        "gateway": types.StringType,
                                                },
                                        }, routeObjs)
                                        resp.Diagnostics.Append(diags...)
                                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                dhcpAttrs["routes"] = routesList
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        dhcpAttrs["routes"] = types.ListNull(types.ObjectType{
                                                AttrTypes: map[string]attr.Type{
                                                        "address": types.StringType,
                                                        "gateway": types.StringType,
                                                },
                                        })
                                }</span>

                                // Handle DNS
                                <span class="cov0" title="0">if len(subnet.Properties.DHCP.DNS) &gt; 0 </span><span class="cov0" title="0">{
                                        dnsValues := make([]attr.Value, 0, len(subnet.Properties.DHCP.DNS))
                                        for _, dns := range subnet.Properties.DHCP.DNS </span><span class="cov0" title="0">{
                                                dnsValues = append(dnsValues, types.StringValue(dns))
                                        }</span>
                                        <span class="cov0" title="0">dnsList, diags := types.ListValue(types.StringType, dnsValues)
                                        resp.Diagnostics.Append(diags...)
                                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                dhcpAttrs["dns"] = dnsList
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        dhcpAttrs["dns"] = types.ListNull(types.StringType)
                                }</span>

                                <span class="cov0" title="0">dhcpObj, diags := types.ObjectValue(map[string]attr.Type{
                                        "enabled": types.BoolType,
                                        "range": types.ObjectType{
                                                AttrTypes: map[string]attr.Type{
                                                        "start": types.StringType,
                                                        "count": types.Int64Type,
                                                },
                                        },
                                        "routes": types.ListType{
                                                ElemType: types.ObjectType{
                                                        AttrTypes: map[string]attr.Type{
                                                                "address": types.StringType,
                                                                "gateway": types.StringType,
                                                        },
                                                },
                                        },
                                        "dns": types.ListType{ElemType: types.StringType},
                                }, dhcpAttrs)
                                resp.Diagnostics.Append(diags...)
                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                        networkAttrs["dhcp"] = dhcpObj
                                }</span>
                        } else<span class="cov0" title="0"> {
                                networkAttrs["dhcp"] = types.ObjectNull(map[string]attr.Type{
                                        "enabled": types.BoolType,
                                        "range": types.ObjectType{
                                                AttrTypes: map[string]attr.Type{
                                                        "start": types.StringType,
                                                        "count": types.Int64Type,
                                                },
                                        },
                                        "routes": types.ListType{
                                                ElemType: types.ObjectType{
                                                        AttrTypes: map[string]attr.Type{
                                                                "address": types.StringType,
                                                                "gateway": types.StringType,
                                                        },
                                                },
                                        },
                                        "dns": types.ListType{ElemType: types.StringType},
                                })
                        }</span>

                        // Build network object with nested dhcp
                        <span class="cov0" title="0">networkObj, diags := types.ObjectValue(networkAttrTypes, networkAttrs)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Network = networkObj
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Basic subnet without network in state - set entire network block to null
                        // This prevents drift when API returns network info but it wasn't configured
                        data.Network = types.ObjectNull(networkAttrTypes)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(subnet.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(subnet.Metadata.Tags))
                        for i, tag := range subnet.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SubnetResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data SubnetResourceModel
        var state SubnetResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        subnetID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || subnetID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Subnet ID are required to update the subnet",
                )
                return
        }</span>

        // Get current subnet details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current subnet",
                        fmt.Sprintf("Unable to get current subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Subnet Not Found",
                        "Subnet not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for subnet",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Preserve network from current state
        <span class="cov0" title="0">network := current.Properties.Network

        // Extract DHCP configuration from network.dhcp if provided
        var dhcp *sdktypes.SubnetDHCP
        if !data.Network.IsNull() &amp;&amp; !data.Network.IsUnknown() </span><span class="cov0" title="0">{
                networkObj, diags := data.Network.ToObjectValue(ctx)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        attrs := networkObj.Attributes()

                        // Extract DHCP configuration from network.dhcp
                        if dhcpAttr, ok := attrs["dhcp"]; ok &amp;&amp; dhcpAttr != nil </span><span class="cov0" title="0">{
                                if dhcpObj, ok := dhcpAttr.(types.Object); ok &amp;&amp; !dhcpObj.IsNull() </span><span class="cov0" title="0">{
                                        dhcpAttrs := dhcpObj.Attributes()
                                        dhcp = &amp;sdktypes.SubnetDHCP{}

                                        // Extract enabled
                                        if enabledAttr, ok := dhcpAttrs["enabled"]; ok &amp;&amp; enabledAttr != nil </span><span class="cov0" title="0">{
                                                if enabledBool, ok := enabledAttr.(types.Bool); ok &amp;&amp; !enabledBool.IsNull() </span><span class="cov0" title="0">{
                                                        dhcp.Enabled = enabledBool.ValueBool()
                                                }</span>
                                        }

                                        // Extract range
                                        <span class="cov0" title="0">if rangeAttr, ok := dhcpAttrs["range"]; ok &amp;&amp; rangeAttr != nil </span><span class="cov0" title="0">{
                                                if rangeObj, ok := rangeAttr.(types.Object); ok &amp;&amp; !rangeObj.IsNull() </span><span class="cov0" title="0">{
                                                        rangeAttrs := rangeObj.Attributes()
                                                        dhcpRange := &amp;sdktypes.SubnetDHCPRange{}
                                                        if startAttr, ok := rangeAttrs["start"]; ok &amp;&amp; startAttr != nil </span><span class="cov0" title="0">{
                                                                if startStr, ok := startAttr.(types.String); ok &amp;&amp; !startStr.IsNull() </span><span class="cov0" title="0">{
                                                                        dhcpRange.Start = startStr.ValueString()
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if countAttr, ok := rangeAttrs["count"]; ok &amp;&amp; countAttr != nil </span><span class="cov0" title="0">{
                                                                if countInt, ok := countAttr.(types.Int64); ok &amp;&amp; !countInt.IsNull() </span><span class="cov0" title="0">{
                                                                        dhcpRange.Count = int(countInt.ValueInt64())
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dhcpRange.Start != "" || dhcpRange.Count &gt; 0 </span><span class="cov0" title="0">{
                                                                dhcp.Range = dhcpRange
                                                        }</span>
                                                }
                                        }

                                        // Extract routes
                                        <span class="cov0" title="0">if routesAttr, ok := dhcpAttrs["routes"]; ok &amp;&amp; routesAttr != nil </span><span class="cov0" title="0">{
                                                if routesList, ok := routesAttr.(types.List); ok &amp;&amp; !routesList.IsNull() </span><span class="cov0" title="0">{
                                                        var routesData []types.Object
                                                        diags := routesList.ElementsAs(ctx, &amp;routesData, false)
                                                        resp.Diagnostics.Append(diags...)
                                                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                                dhcpRoutes := make([]sdktypes.SubnetDHCPRoute, 0, len(routesData))
                                                                for _, routeObj := range routesData </span><span class="cov0" title="0">{
                                                                        routeAttrs := routeObj.Attributes()
                                                                        route := sdktypes.SubnetDHCPRoute{}
                                                                        if addrAttr, ok := routeAttrs["address"]; ok &amp;&amp; addrAttr != nil </span><span class="cov0" title="0">{
                                                                                if addrStr, ok := addrAttr.(types.String); ok &amp;&amp; !addrStr.IsNull() </span><span class="cov0" title="0">{
                                                                                        route.Address = addrStr.ValueString()
                                                                                }</span>
                                                                        }
                                                                        <span class="cov0" title="0">if gwAttr, ok := routeAttrs["gateway"]; ok &amp;&amp; gwAttr != nil </span><span class="cov0" title="0">{
                                                                                if gwStr, ok := gwAttr.(types.String); ok &amp;&amp; !gwStr.IsNull() </span><span class="cov0" title="0">{
                                                                                        route.Gateway = gwStr.ValueString()
                                                                                }</span>
                                                                        }
                                                                        <span class="cov0" title="0">if route.Address != "" || route.Gateway != "" </span><span class="cov0" title="0">{
                                                                                dhcpRoutes = append(dhcpRoutes, route)
                                                                        }</span>
                                                                }
                                                                <span class="cov0" title="0">if len(dhcpRoutes) &gt; 0 </span><span class="cov0" title="0">{
                                                                        dhcp.Routes = dhcpRoutes
                                                                }</span>
                                                        }
                                                }
                                        }

                                        // Extract DNS
                                        <span class="cov0" title="0">if dnsAttr, ok := dhcpAttrs["dns"]; ok &amp;&amp; dnsAttr != nil </span><span class="cov0" title="0">{
                                                if dnsList, ok := dnsAttr.(types.List); ok &amp;&amp; !dnsList.IsNull() </span><span class="cov0" title="0">{
                                                        var dnsServers []string
                                                        diags := dnsList.ElementsAs(ctx, &amp;dnsServers, false)
                                                        resp.Diagnostics.Append(diags...)
                                                        if !resp.Diagnostics.HasError() &amp;&amp; len(dnsServers) &gt; 0 </span><span class="cov0" title="0">{
                                                                dhcp.DNS = dnsServers
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // If dhcp wasn't provided in the plan, preserve from current state
        <span class="cov0" title="0">if dhcp == nil </span><span class="cov0" title="0">{
                dhcp = current.Properties.DHCP
        }</span>

        // Build the update request
        <span class="cov0" title="0">updateRequest := sdktypes.SubnetRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.SubnetPropertiesRequest{
                        Type:    current.Properties.Type,
                        Network: network,
                        DHCP:    dhcp,
                },
        }

        // Update the subnet using the SDK
        response, err := r.client.Client.FromNetwork().Subnets().Update(ctx, projectID, vpcID, subnetID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating subnet",
                        fmt.Sprintf("Unable to update subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update subnet", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId
        data.Uri = state.Uri // Preserve URI from state

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If no URI in response, re-read the subnet to get the latest state
                        getResp, err := r.client.Client.FromNetwork().Subnets().Get(ctx, projectID, vpcID, subnetID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                                }</span> else<span class="cov0" title="0"> {
                                        data.Uri = state.Uri // Fallback to state if not available
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if re-read fails
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI from state
                data.Uri = state.Uri
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *SubnetResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data SubnetResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        subnetID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || subnetID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Subnet ID are required to delete the subnet",
                )
                return
        }</span>

        // Delete the subnet using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().Subnets().Delete(ctx, projectID, vpcID, subnetID, nil)
                }</span>,
                ExtractSDKError,
                "Subnet",
                subnetID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting subnet",
                        fmt.Sprintf("Unable to delete subnet: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a Subnet resource", map[string]interface{}{
                "subnet_id": subnetID,
        })</span>
}

func (r *SubnetResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPCDataSource{}

func NewVPCDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;VPCDataSource{}
}</span>

type VPCDataSource struct {
        client *ArubaCloudClient
}

type VPCDataSourceModel struct {
        Id        types.String `tfsdk:"id"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        ProjectId types.String `tfsdk:"project_id"`
        Tags      types.List   `tfsdk:"tags"`
}

func (d *VPCDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpc"
}</span>

func (d *VPCDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC name",
                                Computed:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPC location",
                                Computed:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPC belongs to",
                                Computed:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPC",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPCDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *VPCDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data VPCDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Populate all fields with example data
        <span class="cov8" title="1">data.Name = types.StringValue("example-vpc")
        data.Location = types.StringValue("ITBG-Bergamo")
        data.ProjectId = types.StringValue("68398923fb2cb026400d4d31")
        data.Tags = types.ListValueMust(types.StringType, []attr.Value{
                types.StringValue("network"),
                types.StringValue("production"),
                types.StringValue("vpc-main"),
        })

        tflog.Trace(ctx, "read a VPC data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "reflect"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type VPCResource struct {
        client *ArubaCloudClient
}

type VPCResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        ProjectID types.String `tfsdk:"project_id"`
        Tags      types.List   `tfsdk:"tags"`
}

var _ resource.Resource = &amp;VPCResource{}
var _ resource.ResourceWithImportState = &amp;VPCResource{}

func NewVPCResource() resource.Resource <span class="cov8" title="1">{
        return &amp;VPCResource{}
}</span>

func (r *VPCResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC identifier",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPC URI",
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPC location",
                                Required:            true,
                                // Validators removed for v1.16.1 compatibility
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "Project ID",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPC",
                                Optional:            true,
                        },
                },
        }
}</span>

func (r *VPCResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VPCResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VPCResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a VPC",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">setDefault := false
        setPreset := false
        createRequest := sdktypes.VPCRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.VPCPropertiesRequest{
                        Properties: &amp;sdktypes.VPCProperties{
                                Default: &amp;setDefault,
                                Preset:  &amp;setPreset,
                        },
                },
        }

        // Create the VPC using the SDK
        response, err := r.client.Client.FromNetwork().VPCs().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPC",
                        fmt.Sprintf("Unable to create VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create VPC", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPC created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPC to be active before returning (VPC is referenced by Subnets, SecurityGroups, etc.)
        // This ensures Terraform doesn't proceed to create dependent resources until VPC is ready
        <span class="cov0" title="0">vpcID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPC to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VPC", vpcID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Not Active",
                        fmt.Sprintf("VPC was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        // Re-read the VPC to get the URI and ensure all fields are properly set
        <span class="cov0" title="0">getResp, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                // Ensure ID is set from metadata (should already be set, but double-check)
                if getResp.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*getResp.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                // Also update other fields that might have changed
                <span class="cov0" title="0">if getResp.Data.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*getResp.Data.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if getResp.Data.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(getResp.Data.Metadata.LocationResponse.Value)
                }</span>
                // Update tags from response
                <span class="cov0" title="0">if len(getResp.Data.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(getResp.Data.Metadata.Tags))
                        for i, tag := range getResp.Data.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If Get fails, log but don't fail - we already have the ID from create response
                tflog.Warn(ctx, fmt.Sprintf("Failed to refresh VPC after creation: %v", err))
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPC resource", map[string]interface{}{
                "vpc_id":   data.Id.ValueString(),
                "vpc_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPCResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VPCResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        vpcID := data.Id.ValueString()

        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to read the VPC",
                )
                return
        }</span>

        // Get VPC details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPC",
                        fmt.Sprintf("Unable to read VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "vpc_id":     vpcID,
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read VPC", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                vpc := response.Data

                if vpc.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*vpc.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if vpc.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*vpc.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if vpc.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*vpc.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if vpc.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(vpc.Metadata.LocationResponse.Value)
                }</span>

                // Update tags from response
                <span class="cov0" title="0">if len(vpc.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(vpc.Metadata.Tags))
                        for i, tag := range vpc.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPCResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VPCResourceModel
        var state VPCResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectID.ValueString()
        vpcID := state.Id.ValueString()

        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to update the VPC",
                )
                return
        }</span>

        // Get current VPC details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPC",
                        fmt.Sprintf("Unable to get current VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Not Found",
                        "VPC not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Get region value
        regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for VPC",
                )
                return
        }</span>

        // Extract tags from Terraform list
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build the update request
        <span class="cov0" title="0">setDefault := current.Properties.Default
        // Note: Preset field may not be available in VPCPropertiesResponse
        // Only preserve Default if it exists
        updateRequest := sdktypes.VPCRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.VPCPropertiesRequest{
                        Properties: &amp;sdktypes.VPCProperties{
                                Default: &amp;setDefault,
                                // Preset field not available in response type - omit if not needed
                        },
                },
        }

        // Update the VPC using the SDK
        response, err := r.client.Client.FromNetwork().VPCs().Update(ctx, projectID, vpcID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPC",
                        fmt.Sprintf("Unable to update VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{
                        "vpc_id":     vpcID,
                        "project_id": projectID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update VPC", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectID = state.ProjectID
        data.Uri = state.Uri // Preserve URI from state

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        // If no URI in response, re-read the VPC to get the latest state
                        getResp, err := r.client.Client.FromNetwork().VPCs().Get(ctx, projectID, vpcID, nil)
                        if err == nil &amp;&amp; getResp != nil &amp;&amp; getResp.Data != nil </span><span class="cov0" title="0">{
                                if getResp.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                                        data.Uri = types.StringValue(*getResp.Data.Metadata.URI)
                                }</span> else<span class="cov0" title="0"> {
                                        data.Uri = state.Uri // Fallback to state if not available
                                }</span>
                        } else<span class="cov0" title="0"> {
                                data.Uri = state.Uri // Fallback to state if re-read fails
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no response, preserve URI from state
                data.Uri = state.Uri
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPCResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VPCResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectID.ValueString()
        vpcID := data.Id.ValueString()

        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to delete the VPC",
                )
                return
        }</span>

        // Delete the VPC using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        // The response from VPCs().Delete() has StatusCode and Error fields directly accessible
        <span class="cov0" title="0">deleteFunc := func() (interface{}, error) </span><span class="cov0" title="0">{
                return r.client.Client.FromNetwork().VPCs().Delete(ctx, projectID, vpcID, nil)
        }</span>

        // Extract error info - the response type has StatusCode and Error as fields
        // The response from VPCs().Delete() is the same type as in Read/Update methods
        // which access response.StatusCode and response.Error.Title directly
        <span class="cov0" title="0">extractErrorFunc := func(response interface{}) (int, *string, *string, bool) </span><span class="cov0" title="0">{
                // Check if response has IsError() method
                type errorResponse interface {
                        IsError() bool
                }
                resp, ok := response.(errorResponse)
                if !ok </span><span class="cov0" title="0">{
                        return 0, nil, nil, false
                }</span>
                <span class="cov0" title="0">if !resp.IsError() </span><span class="cov0" title="0">{
                        return 0, nil, nil, false
                }</span>

                // The response from deleteFunc is the actual SDK response type
                // which has StatusCode and Error as direct struct fields
                // We can access them by type asserting to the actual response type
                // Since deleteFunc returns the concrete type, we can access fields directly
                // The response type matches what we see in Read/Update: response.StatusCode, response.Error.Title
                // We'll access them using the response directly where we know the type
                // For VPC, the response is the same type as used elsewhere in this file
                // We can access response.StatusCode and response.Error.Title directly
                // by using the response type from the SDK
                <span class="cov0" title="0">return extractVPCDelError(response)</span>
        }

        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                deleteFunc,
                extractErrorFunc,
                "VPC",
                vpcID,
                r.client.ResourceTimeout,
        )

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPC",
                        fmt.Sprintf("Unable to delete VPC: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPC resource", map[string]interface{}{
                "vpc_id": vpcID,
        })</span>
}

// extractVPCDelError extracts error from VPC delete response using reflection.
// The response from VPCs().Delete() has StatusCode and Error as direct struct fields.
// We use reflection to access these fields since we have interface{}.
func extractVPCDelError(response interface{}) (int, *string, *string, bool) <span class="cov0" title="0">{
        // Use reflection to access StatusCode and Error fields
        v := reflect.ValueOf(response)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        // Access StatusCode field
        <span class="cov0" title="0">statusCodeField := v.FieldByName("StatusCode")
        if !statusCodeField.IsValid() || !statusCodeField.CanInterface() </span><span class="cov0" title="0">{
                return 0, nil, nil, true // Return that it's an error, but can't extract details
        }</span>
        <span class="cov0" title="0">statusCode := int(statusCodeField.Int())

        // Access Error field
        errorField := v.FieldByName("Error")
        if !errorField.IsValid() </span><span class="cov0" title="0">{
                return statusCode, nil, nil, true
        }</span>

        // Access Error.Title and Error.Detail
        <span class="cov0" title="0">var errorTitle, errorDetail *string
        if errorField.Kind() == reflect.Struct || (errorField.Kind() == reflect.Ptr &amp;&amp; errorField.Elem().Kind() == reflect.Struct) </span><span class="cov0" title="0">{
                errorVal := errorField
                if errorVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        errorVal = errorVal.Elem()
                }</span>

                <span class="cov0" title="0">titleField := errorVal.FieldByName("Title")
                if titleField.IsValid() &amp;&amp; titleField.CanInterface() &amp;&amp; !titleField.IsNil() </span><span class="cov0" title="0">{
                        if titlePtr, ok := titleField.Interface().(*string); ok </span><span class="cov0" title="0">{
                                errorTitle = titlePtr
                        }</span>
                }

                <span class="cov0" title="0">detailField := errorVal.FieldByName("Detail")
                if detailField.IsValid() &amp;&amp; detailField.CanInterface() &amp;&amp; !detailField.IsNil() </span><span class="cov0" title="0">{
                        if detailPtr, ok := detailField.Interface().(*string); ok </span><span class="cov0" title="0">{
                                errorDetail = detailPtr
                        }</span>
                }
        }

        <span class="cov0" title="0">return statusCode, errorTitle, errorDetail, true</span>
}

func (r *VPCResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

func (r *VPCResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpc"
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPCPeeringDataSource{}

func NewVPCPeeringDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;VPCPeeringDataSource{}
}</span>

type VPCPeeringDataSource struct {
        client *ArubaCloudClient
}

type VPCPeeringDataSourceModel struct {
        Id   types.String `tfsdk:"id"`
        Name types.String `tfsdk:"name"`
}

func (d *VPCPeeringDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpcpeering"
}</span>

func (d *VPCPeeringDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC Peering data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering name",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPCPeeringDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *VPCPeeringDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data VPCPeeringDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-vpcpeering")
        tflog.Trace(ctx, "read a VPC Peering data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;VpcPeeringResource{}
var _ resource.ResourceWithImportState = &amp;VpcPeeringResource{}

func NewVpcPeeringResource() resource.Resource <span class="cov8" title="1">{
        return &amp;VpcPeeringResource{}
}</span>

type VpcPeeringResource struct {
        client *ArubaCloudClient
}

type VpcPeeringResourceModel struct {
        Id        types.String `tfsdk:"id"`
        Uri       types.String `tfsdk:"uri"`
        Name      types.String `tfsdk:"name"`
        Location  types.String `tfsdk:"location"`
        Tags      types.List   `tfsdk:"tags"`
        ProjectId types.String `tfsdk:"project_id"`
        VpcId     types.String `tfsdk:"vpc_id"`
        PeerVpc   types.String `tfsdk:"peer_vpc"`
}

func (r *VpcPeeringResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpcpeering"
}</span>

func (r *VpcPeeringResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC Peering resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPC Peering",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPC Peering belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this peering belongs to",
                                Required:            true,
                        },
                        "peer_vpc": schema.StringAttribute{
                                MarkdownDescription: "ID or URI of the peer VPC to connect to",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *VpcPeeringResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VpcPeeringResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VpcPeeringResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()

        if projectID == "" || vpcID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPC ID are required to create a VPC peering",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build peer VPC URI
        <span class="cov0" title="0">peerVPCURI := data.PeerVpc.ValueString()
        if !strings.HasPrefix(peerVPCURI, "/") </span><span class="cov0" title="0">{
                peerVPCURI = fmt.Sprintf("/projects/%s/providers/Aruba.Network/vpcs/%s", projectID, peerVPCURI)
        }</span>

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.VPCPeeringRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.VPCPeeringPropertiesRequest{
                        RemoteVPC: &amp;sdktypes.ReferenceResource{
                                URI: peerVPCURI,
                        },
                },
        }

        // Create the VPC peering using the SDK
        response, err := r.client.Client.FromNetwork().VPCPeerings().Create(ctx, projectID, vpcID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPC peering",
                        fmt.Sprintf("Unable to create VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create VPC peering", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPC peering created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPC Peering to be active before returning (VpcPeering is referenced by VpcPeeringRoute)
        // This ensures Terraform doesn't proceed to create dependent resources until VPC Peering is ready
        <span class="cov0" title="0">peeringID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPCPeerings().Get(ctx, projectID, vpcID, peeringID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPC Peering to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VpcPeering", peeringID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Peering Not Active",
                        fmt.Sprintf("VPC peering was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPC Peering resource", map[string]interface{}{
                "vpcpeering_id":   data.Id.ValueString(),
                "vpcpeering_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VpcPeeringResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Peering ID are required to read the VPC peering",
                )
                return
        }</span>

        // Get VPC peering details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPCPeerings().Get(ctx, projectID, vpcID, peeringID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPC peering",
                        fmt.Sprintf("Unable to read VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "peering_id": peeringID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read VPC peering", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                peering := response.Data

                if peering.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*peering.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if peering.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*peering.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if peering.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*peering.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if peering.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(peering.Metadata.LocationResponse.Value)
                }</span>
                <span class="cov0" title="0">if peering.Properties.RemoteVPC != nil </span><span class="cov0" title="0">{
                        data.PeerVpc = types.StringValue(peering.Properties.RemoteVPC.URI)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(peering.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(peering.Metadata.Tags))
                        for i, tag := range peering.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VpcPeeringResourceModel
        var state VpcPeeringResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        peeringID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Peering ID are required to update the VPC peering",
                )
                return
        }</span>

        // Get current VPC peering details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPCPeerings().Get(ctx, projectID, vpcID, peeringID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPC peering",
                        fmt.Sprintf("Unable to get current VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Peering Not Found",
                        "VPC peering not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if VPC peering is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update VPC Peering",
                        "Cannot update VPC peering while it is in 'InCreation' state. Please wait until the VPC peering is fully created.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for VPC peering",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated, peer VPC must remain unchanged
        <span class="cov0" title="0">updateRequest := sdktypes.VPCPeeringRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.VPCPeeringPropertiesRequest{
                        // Peer VPC cannot be updated - use current value
                        RemoteVPC: current.Properties.RemoteVPC,
                },
        }

        // Update the VPC peering using the SDK
        response, err := r.client.Client.FromNetwork().VPCPeerings().Update(ctx, projectID, vpcID, peeringID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPC peering",
                        fmt.Sprintf("Unable to update VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update VPC peering", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VpcPeeringResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and Peering ID are required to delete the VPC peering",
                )
                return
        }</span>

        // Delete the VPC peering using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().VPCPeerings().Delete(ctx, projectID, vpcID, peeringID, nil)
                }</span>,
                ExtractSDKError,
                "VPCPeering",
                peeringID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPC peering",
                        fmt.Sprintf("Unable to delete VPC peering: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPC Peering resource", map[string]interface{}{
                "vpcpeering_id": peeringID,
        })</span>
}

func (r *VpcPeeringResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPCPeeringRouteDataSource{}

func NewVPCPeeringRouteDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;VPCPeeringRouteDataSource{}
}</span>

type VPCPeeringRouteDataSource struct {
        client *ArubaCloudClient
}

type VPCPeeringRouteDataSourceModel struct {
        Id   types.String `tfsdk:"id"`
        Name types.String `tfsdk:"name"`
}

func (d *VPCPeeringRouteDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpcpeeringroute"
}</span>

func (d *VPCPeeringRouteDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC Peering Route data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route name",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPCPeeringRouteDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *VPCPeeringRouteDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data VPCPeeringRouteDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-vpcpeeringroute")
        tflog.Trace(ctx, "read a VPC Peering Route data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;VpcPeeringRouteResource{}
var _ resource.ResourceWithImportState = &amp;VpcPeeringRouteResource{}

func NewVpcPeeringRouteResource() resource.Resource <span class="cov8" title="1">{
        return &amp;VpcPeeringRouteResource{}
}</span>

type VpcPeeringRouteResource struct {
        client *ArubaCloudClient
}

type VpcPeeringRouteResourceModel struct {
        Id                   types.String `tfsdk:"id"`
        Uri                  types.String `tfsdk:"uri"`
        Name                 types.String `tfsdk:"name"`
        Tags                 types.List   `tfsdk:"tags"`
        ProjectId            types.String `tfsdk:"project_id"`
        VpcId                types.String `tfsdk:"vpc_id"`
        VpcPeeringId         types.String `tfsdk:"vpc_peering_id"`
        LocalNetworkAddress  types.String `tfsdk:"local_network_address"`
        RemoteNetworkAddress types.String `tfsdk:"remote_network_address"`
        BillingPeriod        types.String `tfsdk:"billing_period"`
}

func (r *VpcPeeringRouteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpcpeeringroute"
}</span>

func (r *VpcPeeringRouteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPC Peering Route resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPC Peering Route name",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPC Peering Route",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPC Peering Route belongs to",
                                Required:            true,
                        },
                        "vpc_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC this peering route belongs to",
                                Required:            true,
                        },
                        "vpc_peering_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPC Peering this route belongs to",
                                Required:            true,
                        },
                        "local_network_address": schema.StringAttribute{
                                MarkdownDescription: "Local network address in CIDR notation",
                                Required:            true,
                        },
                        "remote_network_address": schema.StringAttribute{
                                MarkdownDescription: "Remote network address in CIDR notation",
                                Required:            true,
                        },
                        "billing_period": schema.StringAttribute{
                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                Required:            true,
                        },
                },
        }
}</span>

func (r *VpcPeeringRouteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VpcPeeringRouteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VpcPeeringRouteResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.VpcPeeringId.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, and VPC Peering ID are required to create a VPC peering route",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.VPCPeeringRouteRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
                Properties: sdktypes.VPCPeeringRoutePropertiesRequest{
                        LocalNetworkAddress:  data.LocalNetworkAddress.ValueString(),
                        RemoteNetworkAddress: data.RemoteNetworkAddress.ValueString(),
                        BillingPlan: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Create the VPC peering route using the SDK
        response, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Create(ctx, projectID, vpcID, peeringID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPC peering route",
                        fmt.Sprintf("Unable to create VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to create VPC peering route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // VPC Peering Route uses name as ID
                data.Id = types.StringValue(response.Data.Metadata.Name)
                // VPC Peering Route uses RegionalResourceMetadataRequest which doesn't have URI
                data.Uri = types.StringNull()
        }</span> else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPC peering route created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPC Peering Route to be active before returning
        // This ensures Terraform doesn't proceed until VPC Peering Route is ready
        <span class="cov0" title="0">routeID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Get(ctx, projectID, vpcID, peeringID, routeID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPC Peering Route to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VpcPeeringRoute", routeID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Peering Route Not Active",
                        fmt.Sprintf("VPC peering route was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPC Peering Route resource", map[string]interface{}{
                "vpcpeeringroute_id":   data.Id.ValueString(),
                "vpcpeeringroute_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringRouteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VpcPeeringRouteResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.VpcPeeringId.ValueString()
        routeID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, VPC Peering ID, and Route ID are required to read the VPC peering route",
                )
                return
        }</span>

        // Get VPC peering route details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Get(ctx, projectID, vpcID, peeringID, routeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPC peering route",
                        fmt.Sprintf("Unable to read VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">errorMsg := "Failed to read VPC peering route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                route := response.Data

                data.Id = types.StringValue(route.Metadata.Name)
                // VPC Peering Route uses RegionalResourceMetadataRequest which doesn't have URI
                data.Uri = types.StringNull()
                data.Name = types.StringValue(route.Metadata.Name)
                data.LocalNetworkAddress = types.StringValue(route.Properties.LocalNetworkAddress)
                data.RemoteNetworkAddress = types.StringValue(route.Properties.RemoteNetworkAddress)
                if route.Properties.BillingPlan.BillingPeriod != "" </span><span class="cov0" title="0">{
                        data.BillingPeriod = types.StringValue(route.Properties.BillingPlan.BillingPeriod)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(route.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(route.Metadata.Tags))
                        for i, tag := range route.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringRouteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VpcPeeringRouteResourceModel
        var state VpcPeeringRouteResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpcID := state.VpcId.ValueString()
        peeringID := state.VpcPeeringId.ValueString()
        routeID := state.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, VPC Peering ID, and Route ID are required to update the VPC peering route",
                )
                return
        }</span>

        // Get current VPC peering route details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Get(ctx, projectID, vpcID, peeringID, routeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPC peering route",
                        fmt.Sprintf("Unable to get current VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPC Peering Route Not Found",
                        "VPC peering route not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if VPC peering route is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update VPC Peering Route",
                        "Cannot update VPC peering route while it is in 'InCreation' state. Please wait until the VPC peering route is fully created.",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request
        <span class="cov0" title="0">updateRequest := sdktypes.VPCPeeringRouteRequest{
                Metadata: sdktypes.ResourceMetadataRequest{
                        Name: data.Name.ValueString(),
                        Tags: tags,
                },
                Properties: sdktypes.VPCPeeringRoutePropertiesRequest{
                        LocalNetworkAddress:  data.LocalNetworkAddress.ValueString(),
                        RemoteNetworkAddress: data.RemoteNetworkAddress.ValueString(),
                        BillingPlan: sdktypes.BillingPeriodResource{
                                BillingPeriod: data.BillingPeriod.ValueString(),
                        },
                },
        }

        // Update the VPC peering route using the SDK
        response, err := r.client.Client.FromNetwork().VPCPeeringRoutes().Update(ctx, projectID, vpcID, peeringID, routeID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPC peering route",
                        fmt.Sprintf("Unable to update VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                errorMsg := "Failed to update VPC peering route"
                if response.Error.Title != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s: %s", errorMsg, *response.Error.Title)
                }</span>
                <span class="cov0" title="0">if response.Error.Detail != nil </span><span class="cov0" title="0">{
                        errorMsg = fmt.Sprintf("%s - %s", errorMsg, *response.Error.Detail)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VpcId = state.VpcId
        data.VpcPeeringId = state.VpcPeeringId

        // Note: VpcPeeringRoute uses name as ID and response doesn't have Metadata.ID
        // ID is already set from state above

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VpcPeeringRouteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VpcPeeringRouteResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpcID := data.VpcId.ValueString()
        peeringID := data.VpcPeeringId.ValueString()
        routeID := data.Id.ValueString()

        if projectID == "" || vpcID == "" || peeringID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPC ID, VPC Peering ID, and Route ID are required to delete the VPC peering route",
                )
                return
        }</span>

        // Delete the VPC peering route using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().VPCPeeringRoutes().Delete(ctx, projectID, vpcID, peeringID, routeID, nil)
                }</span>,
                ExtractSDKError,
                "VPCPeeringRoute",
                routeID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPC peering route",
                        fmt.Sprintf("Unable to delete VPC peering route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPC Peering Route resource", map[string]interface{}{
                "vpcpeeringroute_id": routeID,
        })</span>
}

func (r *VpcPeeringRouteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPNRouteDataSource{}

func NewVPNRouteDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;VPNRouteDataSource{}
}</span>

type VPNRouteDataSource struct {
        client *ArubaCloudClient
}

type VPNRouteDataSourceModel struct {
        Id          types.String `tfsdk:"id"`
        Name        types.String `tfsdk:"name"`
        Destination types.String `tfsdk:"destination"`
        Gateway     types.String `tfsdk:"gateway"`
}

func (d *VPNRouteDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpnroute"
}</span>

func (d *VPNRouteDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPN Route data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPN Route identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPN Route name",
                                Computed:            true,
                        },
                        "destination": schema.StringAttribute{
                                MarkdownDescription: "Destination network for the VPN route",
                                Computed:            true,
                        },
                        "gateway": schema.StringAttribute{
                                MarkdownDescription: "Gateway for the VPN route",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPNRouteDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *VPNRouteDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data VPNRouteDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-vpnroute")
        data.Destination = types.StringValue("10.0.0.0/24")
        data.Gateway = types.StringValue("10.0.0.1")
        tflog.Trace(ctx, "read a VPN Route data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;VPNRouteResource{}
var _ resource.ResourceWithImportState = &amp;VPNRouteResource{}

func NewVPNRouteResource() resource.Resource <span class="cov8" title="1">{
        return &amp;VPNRouteResource{}
}</span>

type VPNRouteResourceModel struct {
        Id          types.String `tfsdk:"id"`
        Uri         types.String `tfsdk:"uri"`
        Name        types.String `tfsdk:"name"`
        Location    types.String `tfsdk:"location"`
        Tags        types.List   `tfsdk:"tags"`
        ProjectId   types.String `tfsdk:"project_id"`
        VPNTunnelId types.String `tfsdk:"vpn_tunnel_id"`
        Properties  types.Object `tfsdk:"properties"`
}

type VPNRouteResource struct {
        client *ArubaCloudClient
}

func (r *VPNRouteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpnroute"
}</span>

func (r *VPNRouteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPN Route resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPN Route identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPN Route URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPN Route name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPN Route location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPN Route",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPN Route belongs to",
                                Required:            true,
                        },
                        "vpn_tunnel_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the VPN Tunnel this route belongs to",
                                Required:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                MarkdownDescription: "Properties of the VPN Route",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "cloud_subnet": schema.StringAttribute{
                                                MarkdownDescription: "CIDR of the cloud subnet",
                                                Required:            true,
                                        },
                                        "on_prem_subnet": schema.StringAttribute{
                                                MarkdownDescription: "CIDR of the on-prem subnet",
                                                Required:            true,
                                        },
                                },
                        },
                },
        }
}</span>

func (r *VPNRouteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VPNRouteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VPNRouteResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpnTunnelID := data.VPNTunnelId.ValueString()

        if projectID == "" || vpnTunnelID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and VPN Tunnel ID are required to create a VPN route",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract properties from Terraform object
        <span class="cov0" title="0">propertiesObj, diags := data.Properties.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">propertiesAttrs := propertiesObj.Attributes()
        cloudSubnetAttr, ok := propertiesAttrs["cloud_subnet"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "cloud_subnet must be a String")
                return
        }</span>
        <span class="cov0" title="0">cloudSubnet := cloudSubnetAttr.ValueString()

        onPremSubnetAttr, ok := propertiesAttrs["on_prem_subnet"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "on_prem_subnet must be a String")
                return
        }</span>
        <span class="cov0" title="0">onPremSubnet := onPremSubnetAttr.ValueString()

        // Build the create request
        createRequest := sdktypes.VPNRouteRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.VPNRoutePropertiesRequest{
                        CloudSubnet:  cloudSubnet,
                        OnPremSubnet: onPremSubnet,
                },
        }

        // Create the VPN route using the SDK
        response, err := r.client.Client.FromNetwork().VPNRoutes().Create(ctx, projectID, vpnTunnelID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPN route",
                        fmt.Sprintf("Unable to create VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create VPN route", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPN route created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPN Route to be active before returning (VPNRoute references VPNTunnel)
        // This ensures Terraform doesn't proceed to create dependent resources until VPN Route is ready
        <span class="cov0" title="0">routeID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPNRoutes().Get(ctx, projectID, vpnTunnelID, routeID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPN Route to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VPNRoute", routeID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPN Route Not Active",
                        fmt.Sprintf("VPN route was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPN Route resource", map[string]interface{}{
                "vpnroute_id":   data.Id.ValueString(),
                "vpnroute_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNRouteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VPNRouteResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpnTunnelID := data.VPNTunnelId.ValueString()
        routeID := data.Id.ValueString()

        if projectID == "" || vpnTunnelID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPN Tunnel ID, and Route ID are required to read the VPN route",
                )
                return
        }</span>

        // Get VPN route details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPNRoutes().Get(ctx, projectID, vpnTunnelID, routeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPN route",
                        fmt.Sprintf("Unable to read VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "route_id":   routeID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read VPN route", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                route := response.Data

                if route.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*route.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if route.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*route.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if route.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*route.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if route.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(route.Metadata.LocationResponse.Value)
                }</span>

                // Update properties from response
                <span class="cov0" title="0">propertiesMap := map[string]attr.Value{
                        "cloud_subnet":   types.StringValue(route.Properties.CloudSubnet),
                        "on_prem_subnet": types.StringValue(route.Properties.OnPremSubnet),
                }

                propertiesObj, diags := types.ObjectValue(map[string]attr.Type{
                        "cloud_subnet":   types.StringType,
                        "on_prem_subnet": types.StringType,
                }, propertiesMap)
                resp.Diagnostics.Append(diags...)
                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        data.Properties = propertiesObj
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(route.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(route.Metadata.Tags))
                        for i, tag := range route.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNRouteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VPNRouteResourceModel
        var state VPNRouteResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        vpnTunnelID := state.VPNTunnelId.ValueString()
        routeID := state.Id.ValueString()

        if projectID == "" || vpnTunnelID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPN Tunnel ID, and Route ID are required to update the VPN route",
                )
                return
        }</span>

        // Get current VPN route details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPNRoutes().Get(ctx, projectID, vpnTunnelID, routeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPN route",
                        fmt.Sprintf("Unable to get current VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPN Route Not Found",
                        "VPN route not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if VPN route is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update VPN Route",
                        "Cannot update VPN route while it is in 'InCreation' state. Please wait until the VPN route is fully created.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for VPN route",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Extract properties
        <span class="cov0" title="0">propertiesObj, diags := data.Properties.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">propertiesAttrs := propertiesObj.Attributes()
        cloudSubnetAttr, ok := propertiesAttrs["cloud_subnet"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "cloud_subnet must be a String")
                return
        }</span>
        <span class="cov0" title="0">cloudSubnet := cloudSubnetAttr.ValueString()

        onPremSubnetAttr, ok := propertiesAttrs["on_prem_subnet"].(types.String)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Invalid Type", "on_prem_subnet must be a String")
                return
        }</span>
        <span class="cov0" title="0">onPremSubnet := onPremSubnetAttr.ValueString()

        // Build update request
        updateRequest := sdktypes.VPNRouteRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.VPNRoutePropertiesRequest{
                        CloudSubnet:  cloudSubnet,
                        OnPremSubnet: onPremSubnet,
                },
        }

        // Update the VPN route using the SDK
        response, err := r.client.Client.FromNetwork().VPNRoutes().Update(ctx, projectID, vpnTunnelID, routeID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPN route",
                        fmt.Sprintf("Unable to update VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update VPN route", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId
        data.VPNTunnelId = state.VPNTunnelId

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNRouteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VPNRouteResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        vpnTunnelID := data.VPNTunnelId.ValueString()
        routeID := data.Id.ValueString()

        if projectID == "" || vpnTunnelID == "" || routeID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID, VPN Tunnel ID, and Route ID are required to delete the VPN route",
                )
                return
        }</span>

        // Delete the VPN route using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().VPNRoutes().Delete(ctx, projectID, vpnTunnelID, routeID, nil)
                }</span>,
                ExtractSDKError,
                "VPNRoute",
                routeID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPN route",
                        fmt.Sprintf("Unable to delete VPN route: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPN Route resource", map[string]interface{}{
                "vpnroute_id": routeID,
        })</span>
}

func (r *VPNRouteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = &amp;VPNTunnelDataSource{}

func NewVPNTunnelDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;VPNTunnelDataSource{}
}</span>

type VPNTunnelDataSource struct {
        client *ArubaCloudClient
}

type VPNTunnelDataSourceModel struct {
        Id         types.String `tfsdk:"id"`
        Name       types.String `tfsdk:"name"`
        RemotePeer types.String `tfsdk:"remote_peer"`
        Status     types.String `tfsdk:"status"`
}

func (d *VPNTunnelDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpntunnel"
}</span>

func (d *VPNTunnelDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPN Tunnel data source",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel identifier",
                                Required:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel name",
                                Computed:            true,
                        },
                        "remote_peer": schema.StringAttribute{
                                MarkdownDescription: "Remote peer address for the VPN tunnel",
                                Computed:            true,
                        },
                        "status": schema.StringAttribute{
                                MarkdownDescription: "Status of the VPN tunnel",
                                Computed:            true,
                        },
                },
        }
}</span>

func (d *VPNTunnelDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov8" title="1">d.client = client</span>
}

func (d *VPNTunnelDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var data VPNTunnelDataSourceModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data.Name = types.StringValue("example-vpntunnel")
        data.RemotePeer = types.StringValue("203.0.113.1")
        data.Status = types.StringValue("active")
        tflog.Trace(ctx, "read a VPN Tunnel data source")
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        sdktypes "github.com/Arubacloud/sdk-go/pkg/types"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ resource.Resource = &amp;VPNTunnelResource{}
var _ resource.ResourceWithImportState = &amp;VPNTunnelResource{}

func NewVPNTunnelResource() resource.Resource <span class="cov8" title="1">{
        return &amp;VPNTunnelResource{}
}</span>

type VPNTunnelResourceModel struct {
        Id         types.String `tfsdk:"id"`
        Uri        types.String `tfsdk:"uri"`
        Name       types.String `tfsdk:"name"`
        Location   types.String `tfsdk:"location"`
        Tags       types.List   `tfsdk:"tags"`
        ProjectId  types.String `tfsdk:"project_id"`
        Properties types.Object `tfsdk:"properties"`
}

type VPNTunnelResource struct {
        client *ArubaCloudClient
}

func (r *VPNTunnelResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_vpntunnel"
}</span>

func (r *VPNTunnelResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "VPN Tunnel resource",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel identifier",
                                Computed:            true,
                        },
                        "uri": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel URI",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel name",
                                Required:            true,
                        },
                        "location": schema.StringAttribute{
                                MarkdownDescription: "VPN Tunnel location",
                                Required:            true,
                        },
                        "tags": schema.ListAttribute{
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of tags for the VPN Tunnel",
                                Optional:            true,
                        },
                        "project_id": schema.StringAttribute{
                                MarkdownDescription: "ID of the project this VPN Tunnel belongs to",
                                Required:            true,
                        },
                        "properties": schema.SingleNestedAttribute{
                                MarkdownDescription: "Properties of the VPN Tunnel",
                                Required:            true,
                                Attributes: map[string]schema.Attribute{
                                        "vpn_type": schema.StringAttribute{
                                                MarkdownDescription: "Type of VPN tunnel (Site-To-Site)",
                                                Optional:            true,
                                        },
                                        "vpn_client_protocol": schema.StringAttribute{
                                                MarkdownDescription: "Protocol of the VPN tunnel (ikev2)",
                                                Optional:            true,
                                        },
                                        "billing_period": schema.StringAttribute{
                                                MarkdownDescription: "Billing period (Hour, Month, Year)",
                                                Optional:            true,
                                        },
                                        "ip_configurations": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Network configuration of the VPN tunnel",
                                                Optional:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "vpc": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "VPC reference",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "id": schema.StringAttribute{
                                                                                MarkdownDescription: "VPC id",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "subnet": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "Subnet reference",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "id": schema.StringAttribute{
                                                                                MarkdownDescription: "Subnet id",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "public_ip": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "Public IP reference",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "id": schema.StringAttribute{
                                                                                MarkdownDescription: "Public IP id",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                        "vpn_client_settings": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Client settings of the VPN tunnel",
                                                Optional:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "ike": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "IKE settings",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "lifetime": schema.Int64Attribute{
                                                                                MarkdownDescription: "IKE lifetime",
                                                                                Optional:            true,
                                                                        },
                                                                        "encryption": schema.StringAttribute{
                                                                                MarkdownDescription: "IKE encryption algorithm",
                                                                                Optional:            true,
                                                                        },
                                                                        "hash": schema.StringAttribute{
                                                                                MarkdownDescription: "IKE hash algorithm",
                                                                                Optional:            true,
                                                                        },
                                                                        "dh_group": schema.StringAttribute{
                                                                                MarkdownDescription: "IKE DH group",
                                                                                Optional:            true,
                                                                        },
                                                                        "dpd_action": schema.StringAttribute{
                                                                                MarkdownDescription: "IKE DPD action",
                                                                                Optional:            true,
                                                                        },
                                                                        "dpd_interval": schema.Int64Attribute{
                                                                                MarkdownDescription: "IKE DPD interval",
                                                                                Optional:            true,
                                                                        },
                                                                        "dpd_timeout": schema.Int64Attribute{
                                                                                MarkdownDescription: "IKE DPD timeout",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "esp": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "ESP settings",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "lifetime": schema.Int64Attribute{
                                                                                MarkdownDescription: "ESP lifetime",
                                                                                Optional:            true,
                                                                        },
                                                                        "encryption": schema.StringAttribute{
                                                                                MarkdownDescription: "ESP encryption algorithm",
                                                                                Optional:            true,
                                                                        },
                                                                        "hash": schema.StringAttribute{
                                                                                MarkdownDescription: "ESP hash algorithm",
                                                                                Optional:            true,
                                                                        },
                                                                        "pfs": schema.StringAttribute{
                                                                                MarkdownDescription: "ESP PFS",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "psk": schema.SingleNestedAttribute{
                                                                MarkdownDescription: "PSK settings",
                                                                Optional:            true,
                                                                Attributes: map[string]schema.Attribute{
                                                                        "cloud_site": schema.StringAttribute{
                                                                                MarkdownDescription: "PSK cloud site",
                                                                                Optional:            true,
                                                                        },
                                                                        "on_prem_site": schema.StringAttribute{
                                                                                MarkdownDescription: "PSK on-prem site",
                                                                                Optional:            true,
                                                                        },
                                                                        "secret": schema.StringAttribute{
                                                                                MarkdownDescription: "PSK secret",
                                                                                Optional:            true,
                                                                        },
                                                                },
                                                        },
                                                        "peer_client_public_ip": schema.StringAttribute{
                                                                MarkdownDescription: "Peer client public IP address",
                                                                Optional:            true,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func (r *VPNTunnelResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">client, ok := req.ProviderData.(*ArubaCloudClient)
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *ArubaCloudClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>
        <span class="cov0" title="0">r.client = client</span>
}

func (r *VPNTunnelResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data VPNTunnelResourceModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        if projectID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Project ID",
                        "Project ID is required to create a VPN tunnel",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Extract properties from Terraform object
        <span class="cov0" title="0">propertiesObj, diags := data.Properties.ToObjectValue(ctx)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">propertiesAttrs := propertiesObj.Attributes()

        // Extract VPN type and protocol
        vpnType := "Site-To-Site"
        if vpnTypeAttr, ok := propertiesAttrs["vpn_type"]; ok &amp;&amp; vpnTypeAttr != nil </span><span class="cov0" title="0">{
                if vpnTypeStr, ok := vpnTypeAttr.(types.String); ok &amp;&amp; !vpnTypeStr.IsNull() </span><span class="cov0" title="0">{
                        vpnType = vpnTypeStr.ValueString()
                }</span>
        }

        <span class="cov0" title="0">protocol := "ikev2"
        if protocolAttr, ok := propertiesAttrs["vpn_client_protocol"]; ok &amp;&amp; protocolAttr != nil </span><span class="cov0" title="0">{
                if protocolStr, ok := protocolAttr.(types.String); ok &amp;&amp; !protocolStr.IsNull() </span><span class="cov0" title="0">{
                        protocol = protocolStr.ValueString()
                }</span>
        }

        <span class="cov0" title="0">billingPeriod := "Hour"
        if billingAttr, ok := propertiesAttrs["billing_period"]; ok &amp;&amp; billingAttr != nil </span><span class="cov0" title="0">{
                if billingStr, ok := billingAttr.(types.String); ok &amp;&amp; !billingStr.IsNull() </span><span class="cov0" title="0">{
                        billingPeriod = billingStr.ValueString()
                }</span>
        }

        // Extract IP configurations
        <span class="cov0" title="0">var ipConfig *sdktypes.IPConfigurations
        if ipConfigAttr, ok := propertiesAttrs["ip_configurations"]; ok &amp;&amp; ipConfigAttr != nil </span><span class="cov0" title="0">{
                if ipConfigObj, ok := ipConfigAttr.(types.Object); ok &amp;&amp; !ipConfigObj.IsNull() </span><span class="cov0" title="0">{
                        ipConfigObjValue, diags := ipConfigObj.ToObjectValue(ctx)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                ipConfigAttrs := ipConfigObjValue.Attributes()
                                ipConfig = &amp;sdktypes.IPConfigurations{}

                                // Extract VPC
                                if vpcAttr, ok := ipConfigAttrs["vpc"]; ok &amp;&amp; vpcAttr != nil </span><span class="cov0" title="0">{
                                        if vpcObj, ok := vpcAttr.(types.Object); ok &amp;&amp; !vpcObj.IsNull() </span><span class="cov0" title="0">{
                                                vpcObjValue, diags := vpcObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        vpcAttrs := vpcObjValue.Attributes()
                                                        if vpcIDAttr, ok := vpcAttrs["id"]; ok &amp;&amp; vpcIDAttr != nil </span><span class="cov0" title="0">{
                                                                if vpcIDStr, ok := vpcIDAttr.(types.String); ok &amp;&amp; !vpcIDStr.IsNull() </span><span class="cov0" title="0">{
                                                                        vpcID := vpcIDStr.ValueString()
                                                                        if !strings.HasPrefix(vpcID, "/") </span><span class="cov0" title="0">{
                                                                                vpcID = fmt.Sprintf("/projects/%s/providers/Aruba.Network/vpcs/%s", projectID, vpcID)
                                                                        }</span>
                                                                        <span class="cov0" title="0">ipConfig.VPC = &amp;sdktypes.ReferenceResource{URI: vpcID}</span>
                                                                }
                                                        }
                                                }
                                        }
                                }

                                // Extract Subnet
                                <span class="cov0" title="0">if subnetAttr, ok := ipConfigAttrs["subnet"]; ok &amp;&amp; subnetAttr != nil </span><span class="cov0" title="0">{
                                        if subnetObj, ok := subnetAttr.(types.Object); ok &amp;&amp; !subnetObj.IsNull() </span><span class="cov0" title="0">{
                                                subnetObjValue, diags := subnetObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        subnetAttrs := subnetObjValue.Attributes()
                                                        if subnetIDAttr, ok := subnetAttrs["id"]; ok &amp;&amp; subnetIDAttr != nil </span><span class="cov0" title="0">{
                                                                if subnetIDStr, ok := subnetIDAttr.(types.String); ok &amp;&amp; !subnetIDStr.IsNull() </span><span class="cov0" title="0">{
                                                                        subnetID := subnetIDStr.ValueString()
                                                                        if !strings.HasPrefix(subnetID, "/") </span><span class="cov0" title="0">{
                                                                                // Need VPC ID for subnet URI - try to get from VPC if available
                                                                                if ipConfig.VPC != nil </span><span class="cov0" title="0">{
                                                                                        // Extract VPC ID from URI
                                                                                        vpcURI := ipConfig.VPC.URI
                                                                                        parts := strings.Split(vpcURI, "/")
                                                                                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                                                                                vpcID := parts[len(parts)-1]
                                                                                                subnetID = fmt.Sprintf("/projects/%s/providers/Aruba.Network/vpcs/%s/subnets/%s", projectID, vpcID, subnetID)
                                                                                        }</span>
                                                                                }
                                                                        }
                                                                        // Subnet field expects SubnetInfo, which has CIDR and Name fields
                                                                        // Extract subnet name from URI or use the ID as name
                                                                        <span class="cov0" title="0">subnetName := subnetID
                                                                        if strings.Contains(subnetID, "/") </span><span class="cov0" title="0">{
                                                                                parts := strings.Split(subnetID, "/")
                                                                                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                                                                        subnetName = parts[len(parts)-1]
                                                                                }</span>
                                                                        }
                                                                        <span class="cov0" title="0">ipConfig.Subnet = &amp;sdktypes.SubnetInfo{
                                                                                Name: subnetName,
                                                                                // CIDR can be empty if not provided
                                                                        }</span>
                                                                }
                                                        }
                                                }
                                        }
                                }

                                // Extract Public IP
                                <span class="cov0" title="0">if publicIPAttr, ok := ipConfigAttrs["public_ip"]; ok &amp;&amp; publicIPAttr != nil </span><span class="cov0" title="0">{
                                        if publicIPObj, ok := publicIPAttr.(types.Object); ok &amp;&amp; !publicIPObj.IsNull() </span><span class="cov0" title="0">{
                                                publicIPObjValue, diags := publicIPObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        publicIPAttrs := publicIPObjValue.Attributes()
                                                        if publicIPIDAttr, ok := publicIPAttrs["id"]; ok &amp;&amp; publicIPIDAttr != nil </span><span class="cov0" title="0">{
                                                                if publicIPIDStr, ok := publicIPIDAttr.(types.String); ok &amp;&amp; !publicIPIDStr.IsNull() </span><span class="cov0" title="0">{
                                                                        publicIPID := publicIPIDStr.ValueString()
                                                                        if !strings.HasPrefix(publicIPID, "/") </span><span class="cov0" title="0">{
                                                                                publicIPID = fmt.Sprintf("/projects/%s/providers/Aruba.Network/elasticips/%s", projectID, publicIPID)
                                                                        }</span>
                                                                        <span class="cov0" title="0">ipConfig.PublicIP = &amp;sdktypes.ReferenceResource{URI: publicIPID}</span>
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        // Extract VPN client settings
        <span class="cov0" title="0">var vpnClientSettings *sdktypes.VPNClientSettings
        if vpnClientAttr, ok := propertiesAttrs["vpn_client_settings"]; ok &amp;&amp; vpnClientAttr != nil </span><span class="cov0" title="0">{
                if vpnClientObj, ok := vpnClientAttr.(types.Object); ok &amp;&amp; !vpnClientObj.IsNull() </span><span class="cov0" title="0">{
                        vpnClientObjValue, diags := vpnClientObj.ToObjectValue(ctx)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                vpnClientAttrs := vpnClientObjValue.Attributes()
                                vpnClientSettings = &amp;sdktypes.VPNClientSettings{}

                                // Extract IKE settings
                                if ikeAttr, ok := vpnClientAttrs["ike"]; ok &amp;&amp; ikeAttr != nil </span><span class="cov0" title="0">{
                                        if ikeObj, ok := ikeAttr.(types.Object); ok &amp;&amp; !ikeObj.IsNull() </span><span class="cov0" title="0">{
                                                ikeObjValue, diags := ikeObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        ikeAttrs := ikeObjValue.Attributes()
                                                        ikeSettings := &amp;sdktypes.IKESettings{}

                                                        if lifetimeAttr, ok := ikeAttrs["lifetime"]; ok &amp;&amp; lifetimeAttr != nil </span><span class="cov0" title="0">{
                                                                if lifetimeInt, ok := lifetimeAttr.(types.Int64); ok &amp;&amp; !lifetimeInt.IsNull() </span><span class="cov0" title="0">{
                                                                        lifetime := int32(lifetimeInt.ValueInt64())
                                                                        // Lifetime field expects int32, not *int32
                                                                        ikeSettings.Lifetime = lifetime
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if encryptionAttr, ok := ikeAttrs["encryption"]; ok &amp;&amp; encryptionAttr != nil </span><span class="cov0" title="0">{
                                                                if encryptionStr, ok := encryptionAttr.(types.String); ok &amp;&amp; !encryptionStr.IsNull() </span><span class="cov0" title="0">{
                                                                        encryption := encryptionStr.ValueString()
                                                                        ikeSettings.Encryption = &amp;encryption
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if hashAttr, ok := ikeAttrs["hash"]; ok &amp;&amp; hashAttr != nil </span><span class="cov0" title="0">{
                                                                if hashStr, ok := hashAttr.(types.String); ok &amp;&amp; !hashStr.IsNull() </span><span class="cov0" title="0">{
                                                                        hash := hashStr.ValueString()
                                                                        ikeSettings.Hash = &amp;hash
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dhGroupAttr, ok := ikeAttrs["dh_group"]; ok &amp;&amp; dhGroupAttr != nil </span><span class="cov0" title="0">{
                                                                if dhGroupStr, ok := dhGroupAttr.(types.String); ok &amp;&amp; !dhGroupStr.IsNull() </span><span class="cov0" title="0">{
                                                                        dhGroup := dhGroupStr.ValueString()
                                                                        ikeSettings.DHGroup = &amp;dhGroup
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dpdActionAttr, ok := ikeAttrs["dpd_action"]; ok &amp;&amp; dpdActionAttr != nil </span><span class="cov0" title="0">{
                                                                if dpdActionStr, ok := dpdActionAttr.(types.String); ok &amp;&amp; !dpdActionStr.IsNull() </span><span class="cov0" title="0">{
                                                                        dpdAction := dpdActionStr.ValueString()
                                                                        ikeSettings.DPDAction = &amp;dpdAction
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dpdIntervalAttr, ok := ikeAttrs["dpd_interval"]; ok &amp;&amp; dpdIntervalAttr != nil </span><span class="cov0" title="0">{
                                                                if dpdIntervalInt, ok := dpdIntervalAttr.(types.Int64); ok &amp;&amp; !dpdIntervalInt.IsNull() </span><span class="cov0" title="0">{
                                                                        dpdInterval := int32(dpdIntervalInt.ValueInt64())
                                                                        // DPDInterval field expects int32, not *int32
                                                                        ikeSettings.DPDInterval = dpdInterval
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if dpdTimeoutAttr, ok := ikeAttrs["dpd_timeout"]; ok &amp;&amp; dpdTimeoutAttr != nil </span><span class="cov0" title="0">{
                                                                if dpdTimeoutInt, ok := dpdTimeoutAttr.(types.Int64); ok &amp;&amp; !dpdTimeoutInt.IsNull() </span><span class="cov0" title="0">{
                                                                        dpdTimeout := int32(dpdTimeoutInt.ValueInt64())
                                                                        // DPDTimeout field expects int32, not *int32
                                                                        ikeSettings.DPDTimeout = dpdTimeout
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">vpnClientSettings.IKE = ikeSettings</span>
                                                }
                                        }
                                }

                                // Extract ESP settings
                                <span class="cov0" title="0">if espAttr, ok := vpnClientAttrs["esp"]; ok &amp;&amp; espAttr != nil </span><span class="cov0" title="0">{
                                        if espObj, ok := espAttr.(types.Object); ok &amp;&amp; !espObj.IsNull() </span><span class="cov0" title="0">{
                                                espObjValue, diags := espObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        espAttrs := espObjValue.Attributes()
                                                        espSettings := &amp;sdktypes.ESPSettings{}

                                                        if lifetimeAttr, ok := espAttrs["lifetime"]; ok &amp;&amp; lifetimeAttr != nil </span><span class="cov0" title="0">{
                                                                if lifetimeInt, ok := lifetimeAttr.(types.Int64); ok &amp;&amp; !lifetimeInt.IsNull() </span><span class="cov0" title="0">{
                                                                        lifetime := int32(lifetimeInt.ValueInt64())
                                                                        // Lifetime field expects int32, not *int32
                                                                        espSettings.Lifetime = lifetime
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if encryptionAttr, ok := espAttrs["encryption"]; ok &amp;&amp; encryptionAttr != nil </span><span class="cov0" title="0">{
                                                                if encryptionStr, ok := encryptionAttr.(types.String); ok &amp;&amp; !encryptionStr.IsNull() </span><span class="cov0" title="0">{
                                                                        encryption := encryptionStr.ValueString()
                                                                        espSettings.Encryption = &amp;encryption
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if hashAttr, ok := espAttrs["hash"]; ok &amp;&amp; hashAttr != nil </span><span class="cov0" title="0">{
                                                                if hashStr, ok := hashAttr.(types.String); ok &amp;&amp; !hashStr.IsNull() </span><span class="cov0" title="0">{
                                                                        hash := hashStr.ValueString()
                                                                        espSettings.Hash = &amp;hash
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if pfsAttr, ok := espAttrs["pfs"]; ok &amp;&amp; pfsAttr != nil </span><span class="cov0" title="0">{
                                                                if pfsStr, ok := pfsAttr.(types.String); ok &amp;&amp; !pfsStr.IsNull() </span><span class="cov0" title="0">{
                                                                        pfs := pfsStr.ValueString()
                                                                        espSettings.PFS = &amp;pfs
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">vpnClientSettings.ESP = espSettings</span>
                                                }
                                        }
                                }

                                // Extract PSK settings
                                <span class="cov0" title="0">if pskAttr, ok := vpnClientAttrs["psk"]; ok &amp;&amp; pskAttr != nil </span><span class="cov0" title="0">{
                                        if pskObj, ok := pskAttr.(types.Object); ok &amp;&amp; !pskObj.IsNull() </span><span class="cov0" title="0">{
                                                pskObjValue, diags := pskObj.ToObjectValue(ctx)
                                                resp.Diagnostics.Append(diags...)
                                                if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                                        pskAttrs := pskObjValue.Attributes()
                                                        pskSettings := &amp;sdktypes.PSKSettings{}

                                                        if cloudSiteAttr, ok := pskAttrs["cloud_site"]; ok &amp;&amp; cloudSiteAttr != nil </span><span class="cov0" title="0">{
                                                                if cloudSiteStr, ok := cloudSiteAttr.(types.String); ok &amp;&amp; !cloudSiteStr.IsNull() </span><span class="cov0" title="0">{
                                                                        cloudSite := cloudSiteStr.ValueString()
                                                                        pskSettings.CloudSite = &amp;cloudSite
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if onPremSiteAttr, ok := pskAttrs["on_prem_site"]; ok &amp;&amp; onPremSiteAttr != nil </span><span class="cov0" title="0">{
                                                                if onPremSiteStr, ok := onPremSiteAttr.(types.String); ok &amp;&amp; !onPremSiteStr.IsNull() </span><span class="cov0" title="0">{
                                                                        onPremSite := onPremSiteStr.ValueString()
                                                                        pskSettings.OnPremSite = &amp;onPremSite
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">if secretAttr, ok := pskAttrs["secret"]; ok &amp;&amp; secretAttr != nil </span><span class="cov0" title="0">{
                                                                if secretStr, ok := secretAttr.(types.String); ok &amp;&amp; !secretStr.IsNull() </span><span class="cov0" title="0">{
                                                                        secret := secretStr.ValueString()
                                                                        pskSettings.Secret = &amp;secret
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">vpnClientSettings.PSK = pskSettings</span>
                                                }
                                        }
                                }

                                // Extract peer client public IP
                                <span class="cov0" title="0">if peerIPAttr, ok := vpnClientAttrs["peer_client_public_ip"]; ok &amp;&amp; peerIPAttr != nil </span><span class="cov0" title="0">{
                                        if peerIPStr, ok := peerIPAttr.(types.String); ok &amp;&amp; !peerIPStr.IsNull() </span><span class="cov0" title="0">{
                                                peerIP := peerIPStr.ValueString()
                                                vpnClientSettings.PeerClientPublicIP = &amp;peerIP
                                        }</span>
                                }
                        }
                }
        }

        // Build the create request
        <span class="cov0" title="0">createRequest := sdktypes.VPNTunnelRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: data.Location.ValueString(),
                        },
                },
                Properties: sdktypes.VPNTunnelPropertiesRequest{
                        VPNType:           &amp;vpnType,
                        VPNClientProtocol: &amp;protocol,
                        IPConfigurations:  ipConfig,
                        VPNClientSettings: vpnClientSettings,
                        BillingPlan: &amp;sdktypes.BillingPeriodResource{
                                BillingPeriod: billingPeriod,
                        },
                },
        }

        // Create the VPN tunnel using the SDK
        response, err := r.client.Client.FromNetwork().VPNTunnels().Create(ctx, projectID, createRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating VPN tunnel",
                        fmt.Sprintf("Unable to create VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to create VPN tunnel", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if response.Data.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*response.Data.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
        } else<span class="cov0" title="0"> {
                resp.Diagnostics.AddError(
                        "Invalid API Response",
                        "VPN tunnel created but no data returned from API",
                )
                return
        }</span>

        // Wait for VPN Tunnel to be active before returning
        // This ensures Terraform doesn't proceed to create dependent resources until VPN Tunnel is ready
        <span class="cov0" title="0">tunnelID := data.Id.ValueString()
        checker := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                getResp, err := r.client.Client.FromNetwork().VPNTunnels().Get(ctx, projectID, tunnelID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if getResp != nil &amp;&amp; getResp.Data != nil &amp;&amp; getResp.Data.Status.State != nil </span><span class="cov0" title="0">{
                        return *getResp.Data.Status.State, nil
                }</span>
                <span class="cov0" title="0">return "Unknown", nil</span>
        }

        // Wait for VPN Tunnel to be active - block until ready (using configured timeout)
        <span class="cov0" title="0">if err := WaitForResourceActive(ctx, checker, "VPNTunnel", tunnelID, r.client.ResourceTimeout); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPN Tunnel Not Active",
                        fmt.Sprintf("VPN tunnel was created but did not become active within the timeout period: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "created a VPN Tunnel resource", map[string]interface{}{
                "vpntunnel_id":   data.Id.ValueString(),
                "vpntunnel_name": data.Name.ValueString(),
        })

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNTunnelResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data VPNTunnelResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        tunnelID := data.Id.ValueString()

        if projectID == "" || tunnelID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Tunnel ID are required to read the VPN tunnel",
                )
                return
        }</span>

        // Get VPN tunnel details using the SDK
        <span class="cov0" title="0">response, err := r.client.Client.FromNetwork().VPNTunnels().Get(ctx, projectID, tunnelID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error reading VPN tunnel",
                        fmt.Sprintf("Unable to read VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                if response.StatusCode == 404 </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                        return
                }</span>
                <span class="cov0" title="0">logContext := map[string]interface{}{
                        "project_id": projectID,
                        "tunnel_id":  tunnelID,
                }
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to read VPN tunnel", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return</span>
        }

        <span class="cov0" title="0">if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                tunnel := response.Data

                if tunnel.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*tunnel.Metadata.ID)
                }</span>
                <span class="cov0" title="0">if tunnel.Metadata.URI != nil </span><span class="cov0" title="0">{
                        data.Uri = types.StringValue(*tunnel.Metadata.URI)
                }</span> else<span class="cov0" title="0"> {
                        data.Uri = types.StringNull()
                }</span>
                <span class="cov0" title="0">if tunnel.Metadata.Name != nil </span><span class="cov0" title="0">{
                        data.Name = types.StringValue(*tunnel.Metadata.Name)
                }</span>
                <span class="cov0" title="0">if tunnel.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                        data.Location = types.StringValue(tunnel.Metadata.LocationResponse.Value)
                }</span>

                // Update tags
                <span class="cov0" title="0">if len(tunnel.Metadata.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        tagValues := make([]types.String, len(tunnel.Metadata.Tags))
                        for i, tag := range tunnel.Metadata.Tags </span><span class="cov0" title="0">{
                                tagValues[i] = types.StringValue(tag)
                        }</span>
                        <span class="cov0" title="0">tagsList, diags := types.ListValueFrom(ctx, types.StringType, tagValues)
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = tagsList
                        }</span>
                } else<span class="cov0" title="0"> {
                        emptyList, diags := types.ListValue(types.StringType, []attr.Value{})
                        resp.Diagnostics.Append(diags...)
                        if !resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                                data.Tags = emptyList
                        }</span>
                }

                // Note: Properties are complex nested structures - for now, we preserve the existing state
                // A full implementation would reconstruct the properties object from the API response
        } else<span class="cov0" title="0"> {
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNTunnelResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data VPNTunnelResourceModel
        var state VPNTunnelResourceModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get IDs from state (not plan) - IDs are immutable and should always be in state
        <span class="cov0" title="0">projectID := state.ProjectId.ValueString()
        tunnelID := state.Id.ValueString()

        if projectID == "" || tunnelID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Tunnel ID are required to update the VPN tunnel",
                )
                return
        }</span>

        // Get current VPN tunnel details
        <span class="cov0" title="0">getResponse, err := r.client.Client.FromNetwork().VPNTunnels().Get(ctx, projectID, tunnelID, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error fetching current VPN tunnel",
                        fmt.Sprintf("Unable to get current VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if getResponse == nil || getResponse.Data == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "VPN Tunnel Not Found",
                        "VPN tunnel not found or no data returned",
                )
                return
        }</span>

        <span class="cov0" title="0">current := getResponse.Data

        // Check if VPN tunnel is in InCreation state
        if current.Status.State != nil &amp;&amp; *current.Status.State == "InCreation" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cannot Update VPN Tunnel",
                        "Cannot update VPN tunnel while it is in 'InCreation' state. Please wait until the VPN tunnel is fully created.",
                )
                return
        }</span>

        // Get region value
        <span class="cov0" title="0">regionValue := ""
        if current.Metadata.LocationResponse != nil </span><span class="cov0" title="0">{
                regionValue = current.Metadata.LocationResponse.Value
        }</span>
        <span class="cov0" title="0">if regionValue == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Region",
                        "Unable to determine region value for VPN tunnel",
                )
                return
        }</span>

        // Extract tags
        <span class="cov0" title="0">var tags []string
        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov0" title="0">{
                diags := data.Tags.ElementsAs(ctx, &amp;tags, false)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tags = current.Metadata.Tags
        }</span>

        // Build update request - only name and tags can be updated, properties must remain unchanged
        <span class="cov0" title="0">updateRequest := sdktypes.VPNTunnelRequest{
                Metadata: sdktypes.RegionalResourceMetadataRequest{
                        ResourceMetadataRequest: sdktypes.ResourceMetadataRequest{
                                Name: data.Name.ValueString(),
                                Tags: tags,
                        },
                        Location: sdktypes.LocationRequest{
                                Value: regionValue,
                        },
                },
                Properties: sdktypes.VPNTunnelPropertiesRequest{
                        // Properties cannot be updated - use current values
                        VPNType:           current.Properties.VPNType,
                        VPNClientProtocol: current.Properties.VPNClientProtocol,
                        IPConfigurations:  current.Properties.IPConfigurations,
                        VPNClientSettings: current.Properties.VPNClientSettings,
                        BillingPlan:       current.Properties.BillingPlan,
                },
        }

        // Update the VPN tunnel using the SDK
        response, err := r.client.Client.FromNetwork().VPNTunnels().Update(ctx, projectID, tunnelID, updateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error updating VPN tunnel",
                        fmt.Sprintf("Unable to update VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">if response != nil &amp;&amp; response.IsError() &amp;&amp; response.Error != nil </span><span class="cov0" title="0">{
                logContext := map[string]interface{}{}
                errorMsg := FormatAPIError(ctx, response.Error, "Failed to update VPN tunnel", logContext)
                resp.Diagnostics.AddError("API Error", errorMsg)
                return
        }</span>

        // Ensure immutable fields are set from state before saving
        <span class="cov0" title="0">data.Id = state.Id
        data.ProjectId = state.ProjectId

        if response != nil &amp;&amp; response.Data != nil </span><span class="cov0" title="0">{
                // Update from response if available (should match state)
                if response.Data.Metadata.ID != nil </span><span class="cov0" title="0">{
                        data.Id = types.StringValue(*response.Data.Metadata.ID)
                }</span>
        }

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *VPNTunnelResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data VPNTunnelResourceModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">projectID := data.ProjectId.ValueString()
        tunnelID := data.Id.ValueString()

        if projectID == "" || tunnelID == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Missing Required Fields",
                        "Project ID and Tunnel ID are required to delete the VPN tunnel",
                )
                return
        }</span>

        // Delete the VPN tunnel using the SDK with retry mechanism
        // Retry on any error except 404 (Resource Not Found)
        <span class="cov0" title="0">err := DeleteResourceWithRetry(
                ctx,
                func() (interface{}, error) </span><span class="cov0" title="0">{
                        return r.client.Client.FromNetwork().VPNTunnels().Delete(ctx, projectID, tunnelID, nil)
                }</span>,
                ExtractSDKError,
                "VPNTunnel",
                tunnelID,
                r.client.ResourceTimeout,
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting VPN tunnel",
                        fmt.Sprintf("Unable to delete VPN tunnel: %s", err),
                )
                return
        }</span>

        <span class="cov0" title="0">tflog.Trace(ctx, "deleted a VPN Tunnel resource", map[string]interface{}{
                "vpntunnel_id": tunnelID,
        })</span>
}

func (r *VPNTunnelResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
